<!doctype html>
<html lang="en">
<head>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <!-- Version: 2025-09-19-18:50:00 - Fixed WK34_HORECA_JSON CORS issue -->
  <meta name="cache-buster" content="2025-09-19-18:50:00">
  <script>
    // Force cache bust
    console.log('üî• CACHE BUSTER: 2025-09-19-18:35:00');
    console.log('üî• Timestamp:', Date.now());
    console.log('üîç HORECA Debug Popup Added');
    console.log('üî• Browser User Agent:', navigator.userAgent);
    console.log('üî• Current URL:', window.location.href);
  </script>
<meta charset="utf-8" />
<title>Y3 Price Compare</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  /* === Google Shopping‚Äìstyle layout (clean, tile-first, light) === */
  :root{
    --bg:#fff; --text:#111; --muted:#566; --line:#e6e8eb; --pill:#f5f6f8; --blue:#1a73e8; --ok:#188038; --warn:#b06000;
  }
  html,body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;}
  header{position:sticky;top:0;background:#fff;border-bottom:1px solid var(--line);z-index:20}
  .wrap{max-width:1200px;margin:0 auto;padding:12px 16px}
  .brand{display:flex;align-items:center;gap:10px;font-weight:700}
  .brand-badge{width:26px;height:26px;border-radius:6px;background:var(--blue)}
  .brand span{letter-spacing:.2px}
  
  /* Tab system */
  .tabs{display:flex;gap:0;margin-top:10px;border-bottom:1px solid var(--line)}
  .tab{padding:12px 20px;border:none;background:transparent;color:var(--muted);cursor:pointer;border-bottom:2px solid transparent;font-weight:500}
  .tab.active{color:var(--blue);border-bottom-color:var(--blue);background:#f8f9ff}
  .tab:hover{background:#f5f6f8}
  
  .tab-content{display:none}
  .tab-content.active{display:block}
  
  .toolbar{display:grid;grid-template-columns: 1fr auto;gap:12px;margin-top:10px}
  .search{display:flex;gap:8px}
  .search input{flex:1;padding:10px 12px;border:1px solid var(--line);border-radius:24px}
  .filters{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .chip{padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:var(--pill);cursor:pointer}
  .chip[data-active="true"]{border-color:var(--blue);color:var(--blue);background:#eef4ff}

  main{display:grid;grid-template-columns:240px 1fr;gap:18px}
  aside{border-right:1px solid var(--line);padding-right:8px}
  .facet{margin:14px 0}
  .facet h4{margin:0 0 8px;font-size:13px}
  .facet label{display:block;color:#333;margin:6px 0;cursor:pointer}
  .facet input{margin-right:6px}

  /* Product grid tiles */
  .grid{display:grid;grid-template-columns: repeat(12,1fr);gap:16px}
  .tile{grid-column: span 12; border:1px solid var(--line); border-radius:12px; padding:12px; display:grid; grid-template-columns: 20px 140px 1fr; gap:12px; position: relative}
  .tile.selected{border-color: var(--blue); background: #f0f8ff}
  .product-checkbox{width: 18px; height: 18px; margin: 0; cursor: pointer}
  @media(min-width:860px){ .tile{grid-column: span 6} }
  @media(min-width:1120px){ .tile{grid-column: span 4} }
  .media{display:flex;align-items:center;justify-content:center}
  .media img{width:120px;height:120px;object-fit:contain}

  .title{font-weight:600;margin:0 0 6px}
  .meta{color:#444;font-size:12px;margin-bottom:6px}
  .badges{display:flex;gap:6px;flex-wrap:wrap;margin:6px 0}
  .badge{font-size:11px;padding:3px 8px;border-radius:999px;background:var(--pill);border:1px solid var(--line);color:#333}

  .price-line{display:flex;gap:10px;align-items:center;margin:6px 0}
  .price{font-weight:700}
  .merchant{color:#333}
  .shipping{font-size:12px;color:var(--ok)}
  .stars{display:inline-flex;gap:2px;vertical-align:middle}
  .star{width:12px;height:12px;display:inline-block;background:linear-gradient(#fc0,#fc0) left/100% 100% no-repeat;border:1px solid #e2c400;border-radius:2px}

  .compare{margin-top:8px}
  .compare button{background:transparent;color:var(--blue);border:0;padding:0;cursor:pointer}
  details.offers{margin-top:8px;border-top:1px dashed var(--line);padding-top:8px}
  details summary{cursor:pointer;list-style:none;font-weight:600}
  details summary::-webkit-details-marker{display:none}
  table.offerlist{width:100%;border-collapse:collapse;margin-top:8px}
  table.offerlist th, table.offerlist td{padding:10px 6px;border-bottom:1px solid var(--line);text-align:left;vertical-align:middle}
  .avail[data-status="in-stock"]{color:var(--ok)}
  .avail[data-status="out-of-stock"]{color:#c62828}
  .go a{color:var(--blue);text-decoration:none;font-weight:600}

  footer{border-top:1px solid var(--line);margin-top:18px;color:#555}
  small.muted{color:#667}
  
  /* Category browsing styles */
  .category-tree{max-width:800px;margin:20px 0}
  .category-node{margin:8px 0;border-left:2px solid var(--line);padding-left:16px}
  .category-node.expanded{border-left-color:var(--blue)}
  .category-item{display:flex;align-items:center;padding:8px 12px;border-radius:6px;cursor:pointer;transition:all 0.2s;margin:2px 0}
  .category-item:hover{background:#f8f9ff;border-left:3px solid var(--blue);padding-left:9px}
  .category-item.selected{background:#eef4ff;border-left:3px solid var(--blue);padding-left:9px}
  .category-toggle{width:20px;height:20px;display:flex;align-items:center;justify-content:center;margin-right:8px;font-size:12px;color:var(--muted)}
  .category-toggle.expanded{transform:rotate(90deg)}
  .category-name{font-weight:500;flex:1;color:var(--text)}
  .category-count{font-size:11px;color:var(--muted);background:var(--pill);padding:2px 6px;border-radius:10px;margin-left:8px}
  .category-level-0 .category-name{font-weight:700;font-size:16px}
  .category-level-1 .category-name{font-weight:600;font-size:14px}
  .category-level-2 .category-name{font-weight:500;font-size:13px}
  .category-level-3 .category-name{font-weight:400;font-size:12px}
  
  .products-in-category{display:grid;grid-template-columns:repeat(auto-fill, minmax(250px, 1fr));gap:16px;margin:20px 0}
  .product-card{padding:12px;border:1px solid var(--line);border-radius:8px;background:var(--bg);transition:all 0.2s}
  .product-card:hover{border-color:var(--blue);background:#f8f9ff}
  .product-image{width:100%;height:120px;object-fit:contain;margin-bottom:8px}
  .product-title{font-weight:600;margin-bottom:4px;font-size:14px}
  .product-price{color:var(--blue);font-weight:700;margin-bottom:4px}
  .product-merchant{font-size:12px;color:var(--muted)}
  
  /* Enhanced product tile styles */
  .tile {
    padding: 16px;
    border: 1px solid #e0e0e0;
    border-radius: 12px;
    background: white;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  }
  .tile:hover {
    border-color: #4285f4;
    box-shadow: 0 4px 12px rgba(66,133,244,0.15);
    transform: translateY(-2px);
  }
  
  /* Enhanced product image styles for reusable Lotus URLs */
  .product-image-container{position:relative;background:#f8f9fa;border:1px solid #e9ecef;border-radius:8px;overflow:hidden}
  .product-image-container img{transition:opacity 0.3s ease}
  .product-image-container img.loading{opacity:0.5}
  .product-image-container img.loaded{opacity:1}
  .product-image-container img.error{opacity:0.3;filter:grayscale(100%)}
  
  /* Real Categories Styles */
  .real-categories{padding:20px}
  .real-category-item{display:flex;justify-content:space-between;align-items:center;padding:15px;margin:10px 0;border:1px solid #e0e0e0;border-radius:8px;cursor:pointer;transition:all 0.3s ease;background:white}
  .real-category-item:hover{border-color:#4285f4;box-shadow:0 2px 8px rgba(66,133,244,0.1);transform:translateY(-1px)}
  .category-info{display:flex;flex-direction:column;gap:5px}
  .category-name{font-weight:600;color:#333;font-size:16px}
  .category-type{font-size:12px;color:#666;background:#f0f0f0;padding:2px 8px;border-radius:12px;display:inline-block}
  .category-arrow{font-size:18px;color:#4285f4;font-weight:bold}
  
  /* Category Products Interface */
  .category-products-interface{padding:20px}
  .selected-category-header{margin-bottom:20px;padding-bottom:15px;border-bottom:1px solid #e0e0e0}
  .back-button{background:#f5f5f5;border:1px solid #ddd;padding:8px 16px;border-radius:6px;cursor:pointer;margin-bottom:10px;transition:all 0.3s ease}
  .back-button:hover{background:#e0e0e0}
  .category-products-display{margin-top:20px}
  .category-products-grid{display:grid;grid-template-columns:repeat(auto-fill, minmax(200px, 1fr));gap:15px;margin-top:15px}
  .category-product-card{border:1px solid #e0e0e0;border-radius:8px;padding:15px;cursor:pointer;transition:all 0.3s ease;background:white}
  .category-product-card:hover{border-color:#4285f4;box-shadow:0 2px 8px rgba(66,133,244,0.1);transform:translateY(-1px)}
  .category-product-card .product-image{width:100%;height:120px;object-fit:cover;border-radius:6px;margin-bottom:10px}
  .category-product-card .product-title{font-size:14px;font-weight:600;color:#333;margin:0 0 5px 0;line-height:1.3}
  .category-product-card .product-price{font-size:16px;font-weight:bold;color:#4285f4;margin:0 0 5px 0}
  .category-product-card .product-category{font-size:12px;color:#666;margin:0}
  
  /* Loading animation for live categories */
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* Live category card styles */
  .live-category-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(40,167,69,0.15);
  }
  
  /* Pagination styles */
  .pagination-container {
    margin: 20px 0;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  /* Sidebar pagination styles */
  aside .pagination-container {
    margin: 15px 0;
    justify-content: flex-start;
  }
  
  aside .pagination {
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
  }
  
  aside .pagination-btn {
    width: 100%;
    text-align: center;
    font-size: 13px;
    padding: 6px 8px;
  }
  
  aside .pagination-info {
    margin-left: 0;
    margin-top: 8px;
    text-align: center;
    font-size: 12px;
    line-height: 1.3;
  }
  
  .pagination {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }
  
  .pagination-btn {
    padding: 8px 12px;
    border: 1px solid var(--line);
    background: var(--bg);
    color: var(--text);
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
    min-width: 40px;
    text-align: center;
  }
  
  .pagination-btn:hover:not(.disabled) {
    background: var(--blue);
    color: white;
    border-color: var(--blue);
    transform: translateY(-1px);
  }
  
  .pagination-btn.active {
    background: var(--blue);
    color: white;
    border-color: var(--blue);
    font-weight: 600;
  }
  
  .pagination-btn.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    background: var(--pill);
    color: var(--muted);
  }
  
  .pagination-ellipsis {
    padding: 8px 4px;
    color: var(--muted);
    font-weight: 500;
  }
  
  .pagination-info {
    margin-left: 16px;
    color: var(--muted);
    font-size: 14px;
    font-weight: 500;
  }
  
  @media (max-width: 768px) {
    .pagination {
      gap: 4px;
    }
    
    .pagination-btn {
      padding: 6px 10px;
      font-size: 13px;
      min-width: 36px;
    }
    
    .pagination-info {
      margin-left: 8px;
      font-size: 13px;
    }
  }
  
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="brand"><span class="brand-badge"></span><span>Y3 Price Compare</span></div>
    <div id="lastUpdated" style="font-size: 12px; color: #666; margin-left: 20px; padding: 4px 8px; background: #f0f0f0; border-radius: 4px;">
      Last updated: <span id="updateTime">Loading...</span>
    </div>
    
    <!-- Tab Navigation - Hidden -->
    <!-- <div class="tabs">
      <button class="tab active" data-tab="search">üîç Search Products</button>
    </div> -->
    
    
    <!-- Search Tab Content -->
    <div id="search-tab" class="tab-content active">
      <div class="toolbar" role="search">
        <div class="search">
          <input id="q" type="search" placeholder="Search product name / GTIN‚Ä¶" />
        </div>
        <div class="filters" aria-label="Source filters">
          <select id="dataSource" style="margin-left: 10px; padding: 6px 10px; border: 1px solid var(--line); border-radius: 6px; background: var(--pill);">
            <option value="postgresql_direct" style="display: none;">Lotus's Products</option>
            <option value="show_all_products" style="display: none;">üì¶ Show All Products (Lazy Loading)</option>
            <option value="postgresql_all_horeca" style="display: none;">All HORECA</option>
            <option value="postgresql_horeca" style="display: none;">HORECA_WK34</option>
            <option value="wk34_horeca_json" style="display: none;">Hotel Restaurant Catering WK34</option>
            <option value="postgresql_horeca_openai" style="display: none;">HORECA_WK34_OpenAI_Processing</option>
            <option value="postgresql_lotus_wk34_horeca" style="display: none;">Lotus_WK34_HORECA_Processing</option>
            <option value="postgresql_horeca_image_ocr" style="display: none;">HORECA_Image_OCR_Processing</option>
            <option value="lotus_online_aws" style="display: none;">Lotus Online (AWS)</option>
            <option value="lotus_scraper" style="display: none;">üîÑ Lotus Real-time Scraper</option>
            <option value="flask_app_localhost" selected>üè™ Lotus's product listing</option>
          </select>
          
          <!-- Lotus Scraper Controls -->
          <div id="lotusScraperControls" style="display: none; margin-left: 10px; padding: 10px; background: #f8f9ff; border: 1px solid var(--blue); border-radius: 8px;">
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
              <button id="startLotusScraper" style="padding: 8px 16px; background: var(--ok); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                üöÄ Start Scraping
              </button>
              <button id="stopLotusScraper" style="padding: 8px 16px; background: var(--warn); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; display: none;">
                ‚èπÔ∏è Stop Scraping
              </button>
            </div>
            <div id="lotusScraperStatus" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; font-size: 12px;">
              <div>
                <div style="color: var(--muted);">Status</div>
                <div id="scraperStatus" style="font-weight: 600;">Ready</div>
              </div>
              <div>
                <div style="color: var(--muted);">Products</div>
                <div id="scraperProducts" style="font-weight: 600;">0</div>
              </div>
              <div>
                <div style="color: var(--muted);">Inserted</div>
                <div id="scraperInserted" style="font-weight: 600;">0</div>
              </div>
              <div>
                <div style="color: var(--muted);">Run #</div>
                <div id="scraperRunNumber" style="font-weight: 600;">-</div>
              </div>
            </div>
            <div id="lotusScraperError" style="display: none; margin-top: 10px; padding: 8px; background: #ffe6e6; color: #d00; border-radius: 4px; font-size: 12px;"></div>
          </div>
          <button id="refreshData" style="margin-left: 10px; padding: 6px 12px; border: 1px solid var(--blue); border-radius: 6px; background: var(--blue); color: white; cursor: pointer;">Refresh Data</button>
          <button id="testAWSWriteBtn" style="margin-left: 10px; padding: 6px 12px; border: 1px solid #ffc107; border-radius: 6px; background: #ffc107; color: black; cursor: pointer; display: none;">üíæ Save Lotus's All Products</button>
          <button id="clearProducts" style="margin-left: 10px; padding: 6px 12px; border: 1px solid var(--red); border-radius: 6px; background: var(--red); color: white; cursor: pointer;">üóëÔ∏è Clear Products</button>
          <button id="fetchLotusUrls" style="margin-left: 10px; padding: 6px 12px; border: 1px solid #ff6b35; border-radius: 6px; background: #ff6b35; color: white; cursor: pointer; display: none;">üåê Fetch Lotus URLs</button>
          <button id="fetchAllProducts" style="margin-left: 10px; padding: 6px 12px; border: 1px solid #28a745; border-radius: 6px; background: #28a745; color: white; cursor: pointer; display: none;">üõí Fetch All Products</button>
          <button id="processBatch100" style="margin-left: 10px; padding: 6px 12px; border: 1px solid #17a2b8; border-radius: 6px; background: #17a2b8; color: white; cursor: pointer; display: none;">üì¶ Process Next 100</button>
          <button id="processAllRecords" style="margin-left: 10px; padding: 6px 12px; border: 1px solid #6f42c1; border-radius: 6px; background: #6f42c1; color: white; cursor: pointer; display: none;">üöÄ Process All Records</button>
          <button id="testFirecrawlResponse" style="margin-left: 10px; padding: 6px 12px; border: 1px solid #17a2b8; border-radius: 6px; background: #17a2b8; color: white; cursor: pointer; display: none;">üîç Test Firecrawl Response</button>
          <button id="stopProcessing" style="margin-left: 10px; padding: 6px 12px; border: 1px solid #dc3545; border-radius: 6px; background: #dc3545; color: white; cursor: pointer; display: none;">‚èπÔ∏è Stop Processing</button>
          <button id="compareSelectedProducts" style="margin-left: 10px; padding: 6px 12px; border: 1px solid #6f42c1; border-radius: 6px; background: #6f42c1; color: white; cursor: pointer; opacity: 0.5; display: none;">‚öñÔ∏è Compare Selected</button>
          <button id="lotusScraperBtn" style="margin-left: 10px; padding: 6px 12px; border: 1px solid #28a745; border-radius: 6px; background: #28a745; color: white; cursor: pointer; display: none;">üîÑ Lotus Real-time Scraper</button>
          <label style="margin-left: 10px; display: flex; align-items: center; gap: 5px;">
            <input type="checkbox" id="showOriginalNamesSearch" style="margin: 0;">
            <span style="font-size: 12px; color: var(--muted);">Show Original Names</span>
          </label>
          <select id="lotusUrlSelector" style="margin-left: 10px; padding: 6px 10px; border: 1px solid var(--line); border-radius: 6px; background: var(--pill); display: none;">
            <option value="">Select Lotus URL to view details...</option>
          </select>
          
          <!-- Record counter display -->
          <div id="recordCounter" style="margin-left: 10px; padding: 6px 12px; background: #e8f5e8; border: 1px solid #28a745; border-radius: 6px; font-size: 12px; color: #2e7d32; display: none;">
            <span id="recordCountText">üì¶ 0 Lotus records fetched</span>
          </div>
          
          <!-- Database progress display -->
          <div id="databaseProgress" style="margin-left: 10px; padding: 8px 12px; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 6px; font-size: 12px; color: #0d47a1; display: none; min-width: 300px;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
              <span id="progressIcon">üíæ</span>
              <span id="progressText">Database Progress</span>
            </div>
            <div style="background: #fff; border-radius: 4px; height: 6px; overflow: hidden; margin-bottom: 4px;">
              <div id="progressBar" style="background: #2196f3; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
            </div>
            <div id="progressDetails" style="font-size: 11px; color: #666;">
              <span id="progressStats">Ready to process</span>
            </div>
          </div>
          
        </div>
      </div>
    </div>
    
    
    
  </div>
</header>

<main class="wrap">
  <!-- Left facets (optional) -->
  <aside>
    <div class="facet">
      <h4>Marketplaces</h4>
      <p style="font-size: 11px; color: #666; margin-bottom: 10px; line-height: 1.4;">Select marketplaces to compare prices.</p>
      <label><input type="checkbox" class="marketplace-filter" data-marketplace="lotuss" checked onchange="updateMarketplaceSelection()"> <span style="color: #28a745; font-weight: 600;">üõí Lotus's</span></label>
      <label><input type="checkbox" class="marketplace-filter" data-marketplace="shopee" onchange="updateMarketplaceSelection()"> <span style="color: #ff6b35; font-weight: 600;">üõçÔ∏è Shopee</span></label>
      <label><input type="checkbox" class="marketplace-filter" data-marketplace="lazada" onchange="updateMarketplaceSelection()"> <span style="color: #ff6600; font-weight: 600;">üõí Lazada</span></label>
      <label style="display: none;"><input type="checkbox" class="marketplace-filter" data-marketplace="horeca" checked onchange="updateMarketplaceSelection()"> <span style="color: #6f42c1; font-weight: 600;">üè¢ HORECA WK34</span></label>
      <label style="display: none;"><input type="checkbox" class="marketplace-filter" data-marketplace="horeca-openai" checked onchange="updateMarketplaceSelection()"> <span style="color: #6f42c1; font-weight: 600;">ü§ñ HORECA WK34 (OpenAI)</span></label>
    </div>
    <div class="facet">
      <h4>Price</h4>
      <label><input type="radio" name="pr" class="fxp" data-min="0" data-max="999999" checked> Any</label>
      <label><input type="radio" name="pr" class="fxp" data-min="0" data-max="10"> ‚â§ RM10</label>
      <label><input type="radio" name="pr" class="fxp" data-min="10" data-max="20"> RM10‚Äì20</label>
      <label><input type="radio" name="pr" class="fxp" data-min="20" data-max="999999"> ‚â• RM20</label>
    </div>
    
    <div class="facet">
      <h4>Special Offers</h4>
      <label style="display: none;"><input type="checkbox" id="specialPriceFilter" onchange="toggleSpecialPriceFilter()"> üè∑Ô∏è Special Price</label>
      <label><input type="checkbox" id="discountFilter" checked onchange="toggleDiscountFilter()"> üí∞ Discounted Items</label>
        <label style="display: none;"><input type="checkbox" id="horecaWk34Filter" onchange="toggleHorecaWk34Filter()"> üè¢ HORECA_WK34</label>
        <label><input type="checkbox" id="loadHorecaWk34Filter" onchange="toggleLoadHorecaWk34Filter()"> üè¢ HORECA_WK34</label>
        <button onclick="debugDatabaseContents()" style="display: none; margin-top: 5px; padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">Debug DB Contents</button>
    </div>
    
    <!-- Pagination moved here underneath price filter -->
    <div id="pagination" class="pagination-container"></div>
    
    <!-- Refresh Notification Area -->
    <div class="facet" id="refreshNotification" style="display: none;">
      <h4>üîÑ Refresh Status</h4>
      <div id="refreshStatusMessage" style="padding: 10px; border-radius: 6px; font-size: 12px; line-height: 1.4;"></div>
    </div>
  </aside>

  <!-- Product grid -->
  <section class="grid" id="grid" aria-label="Results"></section>
  
  <!-- Category browsing content -->
  <section id="category-content" style="display: none;">
    <div id="categories-container">
      <h2>Browse Products by Category</h2>
      <p style="color: var(--muted); margin-bottom: 20px;">Click on categories to expand and browse products. Categories are organized hierarchically based on real product data.</p>
      <div id="category-tree" class="category-tree"></div>
    </div>
    <div id="products-container" style="display: none;">
      <h2 id="category-title">Products in Category</h2>
      <div id="products-in-category" class="products-in-category"></div>
    </div>
  </section>
</main>

<footer class="wrap">
</footer>

<!-- ===== Dynamic Product Loading from Lotus's Data ===== -->
<script>
let isLoading = false;

// Category browsing variables
let categories = [];
let selectedCategory = null;
let categoryProducts = [];

// Product name translation mapping
const productTranslations = {
  // Meat & Poultry
  'ayam': 'Chicken',
  'daging': 'Beef',
  'kambing': 'Lamb',
  'mutton': 'Lamb',
  'ikan': 'Fish',
  'siakap': 'Sea Bass',
  'dory': 'Dory Fish',
  'sotong': 'Squid',
  'kerang': 'Clams',
  'udang': 'Prawns',
  
  // Vegetables
  'bawang': 'Onion',
  'kentang': 'Potato',
  'brokoli': 'Broccoli',
  'halia': 'Ginger',
  'bawang putih': 'Garlic',
  'ubi kentang': 'Potato',
  
  // Dairy & Beverages
  'susu': 'Milk',
  'minuman': 'Beverage',
  'air': 'Water',
  'jus': 'Juice',
  'kopi': 'Coffee',
  'teh': 'Tea',
  
  // Grains & Staples
  'beras': 'Rice',
  'nasi': 'Rice',
  'minyak': 'Oil',
  'garam': 'Salt',
  'gula': 'Sugar',
  'sos': 'Sauce',
  'kicap': 'Soy Sauce',
  
  // Frozen & Canned
  'beku': 'Frozen',
  'tin': 'Canned',
  'ais krim': 'Ice Cream',
  
  // Other
  'penambah perasa': 'Seasoning',
  'cukup rasa': 'Flavor Enhancer',
  'manis': 'Sweet',
  'sili': 'Chili',
  'halal': 'Halal',
  'pembekal': 'Supplier',
  'import': 'Import',
  'dal': 'Lentils',
  'badan islam': 'Islamic Body',
  'mi segera': 'Instant Noodles',
  'mi goreng': 'Fried Noodles',
  'spesial': 'Special',
  
  // HORECA specific terms
  'dada': 'Breast',
  'ayam': 'Chicken',
  'tanpa tulang': 'Boneless',
  'sejuk': 'Cold',
  'beku': 'Frozen',
  'cair': 'Liquid',
  'serbuk': 'Powder',
  'krim': 'Cream',
  'sabun': 'Soap',
  'pencuci': 'Detergent',
  'pinggan': 'Dishes',
  'mangkuk': 'Bowls',
  'gelas': 'Glasses',
  'kain': 'Cloth',
  'tuala': 'Towel',
  'kertas': 'Paper',
  'plastik': 'Plastic',
  'botol': 'Bottle',
  'tin': 'Can',
  'kotak': 'Box',
  'pek': 'Pack',
  'bungkus': 'Package',
  'kecil': 'Small',
  'besar': 'Large',
  'sedang': 'Medium',
  'panjang': 'Long',
  'pendek': 'Short',
  'tebal': 'Thick',
  'nipis': 'Thin',
  'berat': 'Heavy',
  'ringan': 'Light',
  'bersih': 'Clean',
  'kotor': 'Dirty',
  'baru': 'New',
  'lama': 'Old',
  'murah': 'Cheap',
  'mahal': 'Expensive',
  'baik': 'Good',
  'buruk': 'Bad',
  'segar': 'Fresh',
  'busuk': 'Rotten',
  'panas': 'Hot',
  'dingin': 'Cold',
  'lembut': 'Soft',
  'keras': 'Hard',
  'manis': 'Sweet',
  'masam': 'Sour',
  'asin': 'Salty',
  'pedas': 'Spicy',
  'pahit': 'Bitter',
  'gurih': 'Savory',
  'enak': 'Delicious',
  'lezat': 'Tasty',
  'sehat': 'Healthy',
  'bergizi': 'Nutritious',
  'organik': 'Organic',
  'alami': 'Natural',
  'buatan': 'Artificial',
  'import': 'Imported',
  'lokal': 'Local',
  'premium': 'Premium',
  'ekonomis': 'Economical',
  'hemat': 'Economical',
  'praktis': 'Practical',
  'mudah': 'Easy',
  'sulit': 'Difficult',
  'cepat': 'Fast',
  'lambat': 'Slow',
  'aman': 'Safe',
  'berbahaya': 'Dangerous',
  'khusus': 'Special',
  'biasa': 'Regular',
  'standar': 'Standard',
  'kualitas': 'Quality',
  'mutu': 'Quality',
  'grade': 'Grade',
  'kelas': 'Class',
  'jenis': 'Type',
  'macam': 'Kind',
  'variasi': 'Variation',
  'pilihan': 'Choice',
  'terbaik': 'Best',
  'terburuk': 'Worst',
  'terbaru': 'Latest',
  'terlama': 'Oldest',
  'terbesar': 'Largest',
  'terkecil': 'Smallest',
  'tertinggi': 'Highest',
  'terendah': 'Lowest',
  'tercepat': 'Fastest',
  'terlambat': 'Slowest',
  'teraman': 'Safest',
  'terberbahaya': 'Most Dangerous'
};

// TMAPI Configuration
const TMAPI_CONFIG = {
  baseUrl: 'http://api.tmapi.top/trans/v1/general',
  apiToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVc2VybmFtZSI6InRyaXZpc2lvbiIsIkNvbWlkIjpudWxsLCJSb2xlaWQiOm51bGwsImlzcyI6InRtYXBpIiwic3ViIjoidHJpdmlzaW9uIiwiYXVkIjpbIiJdLCJpYXQiOjE3NDg5NTM1NDR9.vDjfMi9bmT3c0fPnnsabFugQjcx4s7fqkGtAtL88hX8',
  fromLang: 'my',     // Malay
  toLang: 'en'        // English
};

// Translation cache to avoid repeated API calls
const translationCache = new Map();

async function translateProductName(productName) {
  if (!productName) return 'Unknown Product';
  
  // Check cache first
  if (translationCache.has(productName)) {
    return translationCache.get(productName);
  }
  
  let translatedName = productName;
  
  // First apply local translations for common terms
  for (const [malay, english] of Object.entries(productTranslations)) {
    const regex = new RegExp(malay, 'gi');
    translatedName = translatedName.replace(regex, english);
  }
  
  // Check if the name contains Malay/Indonesian words that need translation
  const malayWords = ['ayam', 'dada', 'tanpa', 'tulang', 'sejuk', 'beku', 'cair', 'serbuk', 'krim', 'sabun', 'pencuci', 'pinggan', 'mangkuk', 'gelas', 'kain', 'tuala', 'kertas', 'plastik', 'botol', 'tin', 'kotak', 'pek', 'bungkus', 'kecil', 'besar', 'sedang', 'panjang', 'pendek', 'tebal', 'nipis', 'berat', 'ringan', 'bersih', 'kotor', 'baru', 'lama', 'murah', 'mahal', 'baik', 'buruk', 'segar', 'busuk', 'panas', 'dingin', 'lembut', 'keras', 'manis', 'masam', 'asin', 'pedas', 'pahit', 'gurih', 'enak', 'lezat', 'sehat', 'bergizi', 'organik', 'alami', 'buatan', 'import', 'lokal', 'premium', 'ekonomis', 'hemat', 'praktis', 'mudah', 'sulit', 'cepat', 'lambat', 'aman', 'berbahaya', 'khusus', 'biasa', 'standar', 'kualitas', 'mutu', 'grade', 'kelas', 'jenis', 'macam', 'variasi', 'pilihan', 'terbaik', 'terburuk', 'terbaru', 'terlama', 'terbesar', 'terkecil', 'tertinggi', 'terendah', 'tercepat', 'terlambat', 'teraman', 'terberbahaya'];
  
  const hasMalayWords = malayWords.some(word => 
    productName.toLowerCase().includes(word.toLowerCase())
  );
  
  if (hasMalayWords || productName !== translatedName) {
    try {
      // Use TMAPI for translation with API token
      const response = await fetch(`${TMAPI_CONFIG.baseUrl}?apiToken=${TMAPI_CONFIG.apiToken}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          format: "text",
          fromLang: TMAPI_CONFIG.fromLang,
          toLang: TMAPI_CONFIG.toLang,
          sourceText: productName
        })
      });
      
      console.log(`üîÑ Attempting TMAPI translation for: "${productName}"`);
      console.log(`üì° Response status: ${response.status}`);
      
      if (response.ok) {
        const result = await response.json();
        console.log(`üì• TMAPI Response:`, result);
        
        if (result && result.data && result.data.targetText) {
          translatedName = result.data.targetText;
          console.log(`‚úÖ TMAPI Translation Success: "${productName}" ‚Üí "${translatedName}"`);
        } else {
          console.warn(`‚ö†Ô∏è TMAPI response missing targetText:`, result);
          // Fallback to local translation if TMAPI doesn't return targetText
          console.log(`üîÑ Falling back to local translation for: "${productName}"`);
        }
      } else {
        const errorText = await response.text();
        console.warn(`‚ùå TMAPI translation failed for: ${productName}`, {
          status: response.status,
          statusText: response.statusText,
          error: errorText
        });
        // Fallback to local translation if TMAPI fails
        console.log(`üîÑ Falling back to local translation for: "${productName}"`);
      }
    } catch (error) {
      console.warn(`‚ùå TMAPI translation error for: ${productName}`, error);
      // Fallback to local translation if TMAPI throws error
      console.log(`üîÑ Falling back to local translation for: "${productName}"`);
    }
  }
  
  // Clean up common patterns
  translatedName = translatedName
    .replace(/\bkg\b/gi, 'kg')
    .replace(/\brm\b/gi, 'RM')
    .replace(/\bx\b/gi, 'x')
    .replace(/\bpek\b/gi, 'pack')
    .replace(/\bml\b/gi, 'ml')
    .replace(/\bgm\b/gi, 'gm')
    .replace(/\bhalal\b/gi, 'Halal')
    .replace(/\bchina\b/gi, 'China')
    .replace(/\bmalaysia\b/gi, 'Malaysia');
  
  // Capitalize first letter of each word
  translatedName = translatedName.replace(/\b\w/g, l => l.toUpperCase());
  
  // Cache the result
  translationCache.set(productName, translatedName);
  
  return translatedName;
}

// Test function for translation (can be called from browser console)
async function testTranslation(productName) {
  console.log(`üß™ Testing translation for: "${productName}"`);
  const result = await translateProductName(productName);
  console.log(`üìù Translation result: "${result}"`);
  return result;
}

// Available data sources
const DATA_SOURCES = [
  { name: "All", file: "postgresql_direct" },
  { name: "All HORECA", file: "postgresql_all_horeca" },
  { name: "HORECA_WK34", file: "postgresql_horeca" },
  { name: "HORECA_WK34_OpenAI_Processing", file: "postgresql_horeca_openai" },
  { name: "Lotus_WK34_HORECA_Processing", file: "postgresql_lotus_wk34_horeca" },
  { name: "HORECA_Image_OCR_Processing", file: "postgresql_horeca_image_ocr" },
  { name: "Lotus Online (AWS)", file: "lotus_online_aws" }
];

// Convert Lotus product data to our format
function convertLotusProduct(lotusProduct, index) {
  const price = parseFloat(lotusProduct.current_price) || parseFloat(lotusProduct.new_amount) || 0;
  const originalPrice = parseFloat(lotusProduct.original_amount) || 0;
  let productName = lotusProduct.label || lotusProduct.product_name || "Unknown Product";
  
  // Clean the product name by removing all variations of "| Lotus's Shop Online" suffix
  productName = productName
    .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
    .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
    .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
    .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
    .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
    .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '');
  
  // Debug log for first few products
  if (index < 3) {
    console.log(`üîç Converting Lotus Product ${index}:`, {
      label: lotusProduct.label,
      product_name: lotusProduct.product_name,
      productName: productName,
      current_price: lotusProduct.current_price
    });
  }
  
  return {
    id: `lotus-${index}`,
    gtin: `LOTUS${index.toString().padStart(6, '0')}`,
    title: productName || "Unknown Product",
    original_title: lotusProduct.label || lotusProduct.product_name || "Unknown Product",
    image_link: "https://via.placeholder.com/240x240.png?text=No+Image",
    brand: lotusProduct.brand || "Lotus's",
    category_path: lotusProduct.product_type || "General",
    rating: 4.0 + Math.random() * 1.0, // Simulated rating
    rating_count: Math.floor(Math.random() * 500) + 50,
    aggregate: { 
      currency: "MYR", 
      lowPrice: price, 
      highPrice: price, 
      offerCount: 1 
    },
    offers: [
      { 
        source: "lotuss", 
        marketplace: "lotuss", 
        merchant: "Lotus's", 
        price: price, 
        currency: "MYR", 
        url: "#", 
        promo: originalPrice > price ? "Special Price" : "Everyday Low",
        original_price: originalPrice > 0 ? originalPrice : null,
        size: lotusProduct.size || "",
        packaging: lotusProduct.packaging || ""
      }
    ],
    // Additional Lotus-specific data
    lotus_data: {
      size: lotusProduct.size || "",
      packaging: lotusProduct.packaging || "",
      price_unit: lotusProduct.price_unit || "",
      weight_unit: lotusProduct.weight_unit || "",
      source_image: lotusProduct.source_image || "",
      page_number: lotusProduct.page_number || 1,
      scraped_date: lotusProduct.scraped_date || ""
    }
  };
}

// Check if URL is an image URL
function isImageUrl(url) {
  if (!url) return false;
  
  const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'];
  const imagePaths = ['/images/', '/img/', '/pictures/', '/photos/', '/media/', '/assets/'];
  
  // Check for image file extensions
  const hasImageExtension = imageExtensions.some(ext => 
    url.toLowerCase().includes(ext.toLowerCase())
  );
  
  // Check for image paths
  const hasImagePath = imagePaths.some(path => 
    url.toLowerCase().includes(path.toLowerCase())
  );
  
  return hasImageExtension || hasImagePath;
}

// Clean product name function
function cleanProductName(name) {
  if (!name) return "Unknown Product";
  
  // Remove Lotus branding - comprehensive removal of all variations
  let cleanName = name
    .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
    .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
    .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
    .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
    .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
    .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '')
    .replace(/\s*\|\s*Lotus'?s?\s*Shop.*$/gi, '')
    .replace(/\s*\|\s*Lotus\s*Shop.*$/gi, '');
  
  // Clean up extra spaces and trim
  cleanName = cleanName.replace(/\s+/g, ' ').trim();
  
  return cleanName || "Unknown Product";
}

// Function to parse Firecrawl response and map to grocery table fields
function parseFirecrawlToGroceryFields(firecrawlData) {
  const metadata = firecrawlData.metadata || {};
  const content = firecrawlData.content || '';
  const url = metadata.url || metadata.sourceURL || '';
  
  // Extract product name from title
  const title = metadata.title || metadata.ogTitle || '';
  const productName = title.split('|')[0].trim();
  
  // Extract price from content
  const priceMatch = content.match(/RM\s*([\d,]+\.?\d*)/i);
  const price = priceMatch ? parseFloat(priceMatch[1].replace(',', '')) : 0;
  
  // Extract brand from content or metadata
  const brandMatch = content.match(/\*\*Brand:\s*([^*]+)\*\*/i);
  const brand = brandMatch ? brandMatch[1].trim() : 'Unknown';
  
  // Extract category from content
  const categoryMatch = content.match(/\*\*Category:\s*([^*]+)\*\*/i);
  const category = categoryMatch ? categoryMatch[1].trim() : 'General';
  
  // Extract image URL
  const imageUrl = metadata.ogImage || metadata['og:image'] || '';
  
  // Extract description
  const descriptionMatch = content.match(/Enjoy a quick and delicious meal with ([^.]+\.)/i);
  const description = descriptionMatch ? descriptionMatch[1] : metadata.ogDescription || '';
  
  // Extract product ID from URL
  const productIdMatch = url.match(/\/product\/(\d+)/);
  const productId = productIdMatch ? productIdMatch[1] : '';
  
  // Map to grocery table fields
  const groceryFields = {
    // Basic product info
    product_id: productId,
    product_name: productName,
    brand: brand,
    category: category,
    subcategory: category.includes('/') ? category.split('/').pop() : category,
    
    // Pricing
    price: price,
    original_price: price, // Assuming no discount for now
    currency: 'MYR',
    
    // Product details
    description: description,
    product_url: url,
    image_url: imageUrl,
    
    // Availability and stock
    availability: 'in_stock', // Default assumption
    stock_quantity: null,
    
    // Nutritional/Product info
    weight: extractWeight(content),
    packaging: extractPackaging(content),
    ingredients: extractIngredients(content),
    
    // Store info
    store_name: "Lotus's",
    store_location: "Malaysia",
    
    // Metadata
    scraped_at: new Date().toISOString(),
    source: 'firecrawl',
    data_source: 'lotuss.com.my',
    
    // Additional fields
    gtin: generateGTIN(productId),
    barcode: productId,
    sku: productId,
    
    // Raw data for reference
    raw_firecrawl_data: firecrawlData
  };
  
  return groceryFields;
}

// Helper functions for extraction
function extractWeight(content) {
  const weightMatch = content.match(/(\d+(?:\.\d+)?)\s*(?:g|gram|kg|kilogram|ml|liter|l)/i);
  return weightMatch ? weightMatch[0] : null;
}

function extractPackaging(content) {
  const packagingMatch = content.match(/(\d+)\s*(?:pack|pcs|pieces|units?)/i);
  return packagingMatch ? packagingMatch[0] : '1 unit';
}

function extractIngredients(content) {
  const ingredientsMatch = content.match(/Ingredients?:\s*([^.]+\.[^.]*)/i);
  return ingredientsMatch ? ingredientsMatch[1].trim() : null;
}

function generateGTIN(productId) {
  return `LOTUS${productId.padStart(8, '0')}`;
}

// Function to show Firecrawl API response in popup with grocery table mapping
function showFirecrawlResponse(url, status, data) {
  const popup = document.createElement('div');
  popup.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border: 2px solid #007bff;
    border-radius: 10px;
    padding: 20px;
    max-width: 90%;
    max-height: 90%;
    overflow: auto;
    z-index: 10000;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    font-family: Arial, sans-serif;
    font-size: 14px;
  `;
  
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Close';
  closeBtn.style.cssText = `
    position: absolute;
    top: 10px;
    right: 10px;
    background: #dc3545;
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
  `;
  closeBtn.onclick = () => document.body.removeChild(popup);
  
  const title = document.createElement('h3');
  title.textContent = `Firecrawl Response - Grocery Table Mapping`;
  title.style.cssText = 'margin-top: 0; color: #007bff; font-size: 18px;';
  
  const urlDiv = document.createElement('div');
  urlDiv.innerHTML = `<strong>URL:</strong> ${url}`;
  urlDiv.style.cssText = 'margin-bottom: 10px; word-break: break-all; font-size: 12px; color: #666;';
  
  const statusDiv = document.createElement('div');
  statusDiv.innerHTML = `<strong>Status:</strong> ${status}`;
  statusDiv.style.cssText = 'margin-bottom: 15px; font-size: 12px; color: #666;';
  
  // Parse the data to grocery table fields
  const groceryFields = parseFirecrawlToGroceryFields(data);
  
  // Create tabs for different views
  const tabContainer = document.createElement('div');
  tabContainer.style.cssText = 'margin-bottom: 15px;';
  
  const extractedTab = document.createElement('button');
  extractedTab.textContent = 'üìä Extracted Data';
  extractedTab.style.cssText = `
    padding: 8px 15px;
    margin-right: 5px;
    background: #28a745;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
  `;
  
  const groceryTab = document.createElement('button');
  groceryTab.textContent = 'üóÉÔ∏è Grocery Table Fields';
  groceryTab.style.cssText = `
    padding: 8px 15px;
    margin-right: 5px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
  `;
  
  const rawTab = document.createElement('button');
  rawTab.textContent = 'üîç Raw Response';
  rawTab.style.cssText = `
    padding: 8px 15px;
    background: #6c757d;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
  `;
  
  const contentDiv = document.createElement('div');
  contentDiv.style.cssText = 'margin-top: 15px;';
  
  // Extracted data content (new tab)
  const extractedContent = document.createElement('div');
  extractedContent.id = 'extracted-content';
  extractedContent.innerHTML = `
    <h4 style="color: #28a745; margin-bottom: 10px;">üìä Extracted Product Data:</h4>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 12px;">
      <div><strong>Product Name:</strong> ${groceryFields.product_name}</div>
      <div><strong>Brand:</strong> ${groceryFields.brand}</div>
      <div><strong>Price:</strong> RM ${groceryFields.price}</div>
      <div><strong>Category:</strong> ${groceryFields.category}</div>
      <div><strong>Subcategory:</strong> ${groceryFields.subcategory}</div>
      <div><strong>Product ID:</strong> ${groceryFields.product_id}</div>
      <div><strong>Weight:</strong> ${groceryFields.weight || 'N/A'}</div>
      <div><strong>Packaging:</strong> ${groceryFields.packaging}</div>
      <div><strong>Currency:</strong> ${groceryFields.currency}</div>
      <div><strong>Store:</strong> ${groceryFields.store_name}</div>
      <div><strong>GTIN:</strong> ${groceryFields.gtin}</div>
      <div><strong>Availability:</strong> ${groceryFields.availability}</div>
    </div>
    <div style="margin-top: 15px;">
      <strong>Description:</strong><br>
      <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin-top: 5px;">
        ${groceryFields.description}
      </div>
    </div>
    <div style="margin-top: 15px;">
      <strong>Ingredients:</strong><br>
      <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin-top: 5px; font-size: 11px;">
        ${groceryFields.ingredients || 'Not available'}
      </div>
    </div>
    <div style="margin-top: 15px;">
      <strong>Image URL:</strong><br>
      <div style="word-break: break-all; font-size: 11px; color: #666;">
        ${groceryFields.image_url}
      </div>
    </div>
    <div style="margin-top: 15px;">
      <strong>Product URL:</strong><br>
      <div style="word-break: break-all; font-size: 11px; color: #666;">
        ${groceryFields.product_url}
      </div>
    </div>
  `;
  
  // Grocery fields content
  const groceryContent = document.createElement('div');
  groceryContent.id = 'grocery-content';
  groceryContent.style.display = 'none';
  groceryContent.innerHTML = `
    <h4 style="color: #28a745; margin-bottom: 10px;">üìä Mapped to Grocery Table Fields:</h4>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 12px;">
      <div><strong>Product ID:</strong> ${groceryFields.product_id}</div>
      <div><strong>Product Name:</strong> ${groceryFields.product_name}</div>
      <div><strong>Brand:</strong> ${groceryFields.brand}</div>
      <div><strong>Category:</strong> ${groceryFields.category}</div>
      <div><strong>Subcategory:</strong> ${groceryFields.subcategory}</div>
      <div><strong>Price:</strong> RM ${groceryFields.price}</div>
      <div><strong>Currency:</strong> ${groceryFields.currency}</div>
      <div><strong>Availability:</strong> ${groceryFields.availability}</div>
      <div><strong>Weight:</strong> ${groceryFields.weight || 'N/A'}</div>
      <div><strong>Packaging:</strong> ${groceryFields.packaging}</div>
      <div><strong>GTIN:</strong> ${groceryFields.gtin}</div>
      <div><strong>Store:</strong> ${groceryFields.store_name}</div>
    </div>
    <div style="margin-top: 15px;">
      <strong>Description:</strong><br>
      <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin-top: 5px;">
        ${groceryFields.description}
      </div>
    </div>
    <div style="margin-top: 15px;">
      <strong>Ingredients:</strong><br>
      <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin-top: 5px; font-size: 11px;">
        ${groceryFields.ingredients || 'Not available'}
      </div>
    </div>
    <div style="margin-top: 15px;">
      <strong>Image URL:</strong><br>
      <div style="word-break: break-all; font-size: 11px; color: #666;">
        ${groceryFields.image_url}
      </div>
    </div>
  `;
  
  // Raw response content
  const rawContent = document.createElement('div');
  rawContent.id = 'raw-content';
  rawContent.style.display = 'none';
  rawContent.innerHTML = `
    <h4 style="color: #dc3545; margin-bottom: 10px;">üîç Raw Firecrawl Response:</h4>
    <pre style="background: #f8f9fa; padding: 15px; border-radius: 5px; overflow: auto; max-height: 400px; font-size: 11px;">${JSON.stringify(data, null, 2)}</pre>
  `;
  
  // Tab functionality
  extractedTab.onclick = () => {
    extractedContent.style.display = 'block';
    groceryContent.style.display = 'none';
    rawContent.style.display = 'none';
    extractedTab.style.background = '#28a745';
    groceryTab.style.background = '#6c757d';
    rawTab.style.background = '#6c757d';
  };
  
  groceryTab.onclick = () => {
    extractedContent.style.display = 'none';
    groceryContent.style.display = 'block';
    rawContent.style.display = 'none';
    extractedTab.style.background = '#6c757d';
    groceryTab.style.background = '#007bff';
    rawTab.style.background = '#6c757d';
  };
  
  rawTab.onclick = () => {
    extractedContent.style.display = 'none';
    groceryContent.style.display = 'none';
    rawContent.style.display = 'block';
    extractedTab.style.background = '#6c757d';
    groceryTab.style.background = '#6c757d';
    rawTab.style.background = '#007bff';
  };
  
  contentDiv.appendChild(extractedContent);
  contentDiv.appendChild(groceryContent);
  contentDiv.appendChild(rawContent);
  
  popup.appendChild(closeBtn);
  popup.appendChild(title);
  popup.appendChild(urlDiv);
  popup.appendChild(statusDiv);
  popup.appendChild(tabContainer);
  tabContainer.appendChild(extractedTab);
  tabContainer.appendChild(groceryTab);
  tabContainer.appendChild(rawTab);
  popup.appendChild(contentDiv);
  
  document.body.appendChild(popup);
  
  // Auto-close after 15 seconds
  setTimeout(() => {
    if (document.body.contains(popup)) {
      document.body.removeChild(popup);
    }
  }, 15000);
}

// Test function to check if button exists
function testButtonExists() {
  const button = document.getElementById('showAllProducts');
  console.log('Button element:', button);
  if (button) {
    console.log('‚úÖ Button exists');
    alert('‚úÖ Button exists');
  } else {
    console.log('‚ùå Button does not exist');
    alert('‚ùå Button does not exist');
  }
}

// Function to show all available products with lazy loading (100 at a time)
async function showAllProducts() {
  console.log('üì¶ showAllProducts function called - loading ALL products');
  
  // Show loading message
  const grid = document.getElementById('grid');
  if (!grid) {
    console.error('‚ùå Grid element not found!');
    return;
  }
  
  grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">üîÑ Loading ALL products from all sources...</div>';
  showRefreshNotification('üîÑ Loading ALL products from all sources...', 'loading');
  
  try {
    // Reset global variables for fresh start
    allLoadedProducts = [];
    totalProductsAvailable = 0;
    sourceCounts = {};
    loadedSources = {
      'HORECA OpenAI': false,
      'HORECA Image OCR': false,
      'Lotus WK34 HORECA': false,
      'AWS Lotus Online': false
    };
    
    // Set up mode to load ALL products (not lazy loading)
    currentDataSource = 'all_products_complete';
   currentPage = 1;
    
    // Clear any search query to ensure all products are shown
    const searchInput = document.getElementById('q');
    if (searchInput) {
      searchInput.value = '';
    }
    
    console.log('üì¶ Loading ALL products from all sources...');
    
    // Load ALL products from all sources
    await loadAllProductsFromAllSources();
    
    showRefreshNotification(`‚úÖ Loaded ALL ${allLoadedProducts.length} products! You can now paginate through all records.`, 'success');
    
    } catch (error) {
    console.error('‚ùå Error loading all products:', error);
    grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #c62828;">‚ùå Error loading all products: ' + error.message + '</div>';
    showRefreshNotification('‚ùå Error loading all products: ' + error.message, 'error');
  }
}

// Global variables to track loaded data across batches
let allLoadedProducts = []; // Stores all products loaded so far
let totalProductsAvailable = 0; // Total products available across all sources
let sourceCounts = {}; // Track how many products each source has

// Function to load ALL products from all sources at once
async function loadAllProductsFromAllSources() {
  console.log('üì¶ Loading ALL products from all sources...');
  
  const sources = [
    { name: 'HORECA OpenAI', url: 'http://localhost:5004/products', converter: convertHorecaOpenAIProduct },
    { name: 'HORECA Image OCR', url: 'http://localhost:5003/products', converter: convertHorecaImageOCRProduct },
    { name: 'Lotus WK34 HORECA', url: 'http://localhost:5005/products', converter: convertLotusWK34HorecaProduct }
  ];
  
  // Load from PostgreSQL sources
  for (const source of sources) {
    try {
      console.log(`üîÑ Loading ALL products from ${source.name}...`);
      
      // Create AbortController for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout
      
      const response = await fetch(source.url, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log(`‚úÖ Loaded ${data.length} products from ${source.name}`);
      
      // Convert and add all products
      const convertedProducts = data.map(source.converter);
      allLoadedProducts = allLoadedProducts.concat(convertedProducts);
      
      // Update source tracking
      loadedSources[source.name] = true;
      sourceCounts[source.name] = data.length;
      
    } catch (error) {
      console.error(`‚ùå Error loading from ${source.name}:`, error);
      // Continue with other sources even if one fails
    }
  }
  
  // Load from AWS Lotus Online
  try {
    console.log('üîÑ Loading ALL products from AWS Lotus Online...');
    const awsProducts = await loadLotusOnlineAWSProducts();
    if (awsProducts && awsProducts.length > 0) {
      allLoadedProducts = allLoadedProducts.concat(awsProducts);
      loadedSources['AWS Lotus Online'] = true;
      sourceCounts['AWS Lotus Online'] = awsProducts.length;
      console.log(`‚úÖ Loaded ${awsProducts.length} products from AWS Lotus Online`);
    }
  } catch (error) {
    console.error('‚ùå Error loading from AWS Lotus Online:', error);
  }
  
  // Update total count
  totalProductsAvailable = allLoadedProducts.length;
  
  console.log(`üì¶ Total products loaded: ${allLoadedProducts.length}`);
  console.log('üì¶ Source breakdown:', sourceCounts);
  
  // Update FEED with all products
  FEED = allLoadedProducts;
  
  // Calculate total pages
  totalPages = Math.ceil(allLoadedProducts.length / itemsPerPage);
  currentPage = 1;
  
  console.log(`üì¶ Ready for pagination: ${totalPages} pages with ${allLoadedProducts.length} products`);
  
  // Render the first page
  render();
}

// Function to load a batch of products (100 at a time) with true lazy loading
async function loadAllProductsBatch(batchNumber) {
  console.log(`üì¶ Loading batch ${batchNumber} of products (100 at a time)`);
  
  const grid = document.getElementById('grid');
  grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">üîÑ Loading products batch ' + batchNumber + '...</div>';
  
  try {
    const productsPerBatch = 100;
    const startIndex = (batchNumber - 1) * productsPerBatch;
    const endIndex = startIndex + productsPerBatch;
    
    console.log(`üì¶ Batch ${batchNumber}: Need products ${startIndex + 1} to ${endIndex}`);
    
    // If this is the first batch, get total counts from all sources
    if (batchNumber === 1) {
      await getTotalProductCounts();
    }
    
    // Check if we need to load more data
    if (allLoadedProducts.length < endIndex) {
      console.log(`üì¶ Need to load more products. Currently have: ${allLoadedProducts.length}, need up to: ${endIndex}`);
      
      // Add timeout for the entire loading process
      const loadingPromise = loadMoreProductsFromSources(endIndex);
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Loading timeout - taking too long')), 30000) // 30 second total timeout
      );
      
      await Promise.race([loadingPromise, timeoutPromise]);
      console.log('üì¶ Loading completed');
    }
    
    console.log(`üì¶ Batch ${batchNumber}: Loaded ${allLoadedProducts.length} total products so far`);
    
    if (allLoadedProducts.length > 0) {
      // Update pagination based on total loaded products
      totalPages = Math.ceil(allLoadedProducts.length / itemsPerPage);
      
      // Get the correct slice for the current page
      const pageStartIndex = (currentPage - 1) * itemsPerPage;
      const pageEndIndex = pageStartIndex + itemsPerPage;
      const pageProducts = allLoadedProducts.slice(pageStartIndex, pageEndIndex);
      
      // Update FEED with current page products
      FEED = pageProducts;
      
      console.log(`üì¶ Loaded batch ${batchNumber}: ${allLoadedProducts.length} total products`);
      console.log(`üìÑ Showing page ${currentPage} of ${totalPages} (products ${pageStartIndex + 1}-${Math.min(pageEndIndex, allLoadedProducts.length)})`);
      console.log(`üìä Total products available: ${totalProductsAvailable}, Loaded so far: ${allLoadedProducts.length}`);
      
      // Small delay to ensure FEED is fully updated before rendering
      setTimeout(() => {
        console.log(`üì¶ Rendering page ${currentPage} with ${FEED.length} products in FEED`);
        render();
      }, 100);
      
      showRefreshNotification(`‚úÖ Loaded more products! Now showing page ${currentPage} of ${totalPages} (${allLoadedProducts.length}/${totalProductsAvailable} total)`, 'success');
    } else {
      grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">‚ùå No more products available.<br><br>You have reached the end of all available products.</div>';
      showRefreshNotification('‚úÖ Reached end of all available products', 'success');
    }
    
    } catch (error) {
    console.error('‚ùå Error loading batch:', error);
    
    // Show more helpful error message
    let errorMessage = error.message;
    if (error.message.includes('timeout')) {
      errorMessage = 'Loading timed out - some servers may be slow or unavailable';
    } else if (error.message.includes('fetch')) {
      errorMessage = 'Network error - check if servers are running';
    }
    
    grid.innerHTML = `
      <div style="text-align: center; padding: 40px; color: #c62828;">
        <h3>‚ùå Error loading batch ${batchNumber}</h3>
        <p>${errorMessage}</p>
        <p>Loaded so far: ${allLoadedProducts.length} products</p>
        <button onclick="loadAllProductsBatch(${batchNumber})" style="margin-top: 10px; padding: 8px 16px; background: var(--blue); color: white; border: none; border-radius: 4px; cursor: pointer;">
          Retry Loading
        </button>
      </div>
    `;
    showRefreshNotification('‚ùå Error loading batch: ' + errorMessage, 'error');
  }
}

// Function to get total product counts from all sources (optimized)
async function getTotalProductCounts() {
  console.log('üìä Getting total product counts from all sources...');
  
  totalProductsAvailable = 0;
  sourceCounts = {};
  
  // For now, we'll estimate based on typical counts to avoid slow loading
  // In a production system, you'd have dedicated count endpoints
  const estimatedCounts = {
    'HORECA OpenAI': 100,
    'HORECA Image OCR': 50,
    'Lotus WK34 HORECA': 75,
    'AWS Lotus Online': 200
  };
  
  // Use estimated counts for faster loading
  for (const [sourceName, count] of Object.entries(estimatedCounts)) {
    sourceCounts[sourceName] = count;
    totalProductsAvailable += count;
    console.log(`üìä ${sourceName}: ~${count} products (estimated)`);
  }
  
  console.log(`üìä Total products available across all sources: ~${totalProductsAvailable} (estimated)`);
  console.log('üìä Source breakdown:', sourceCounts);
}

// Global variables to track which sources have been loaded
let loadedSources = {
  'HORECA OpenAI': false,
  'HORECA Image OCR': false,
  'Lotus WK34 HORECA': false,
  'AWS Lotus Online': false
};

// Function to load more products from sources up to the required index (optimized)
async function loadMoreProductsFromSources(requiredIndex) {
  console.log(`üì¶ Loading more products up to index ${requiredIndex}...`);
  console.log(`üì¶ Currently loaded: ${allLoadedProducts.length}, Need: ${requiredIndex}`);
  
  const sources = [
    { name: 'HORECA OpenAI', url: 'http://localhost:5004/products', converter: convertHorecaOpenAIProduct },
    { name: 'HORECA Image OCR', url: 'http://localhost:5003/products', converter: convertHorecaImageOCRProduct },
    { name: 'Lotus WK34 HORECA', url: 'http://localhost:5005/products', converter: convertLotusWK34HorecaProduct }
  ];
  
  // Load from PostgreSQL sources (only if not already loaded)
  for (const source of sources) {
    if (allLoadedProducts.length >= requiredIndex) break;
    
    if (!loadedSources[source.name]) {
      try {
        console.log(`üîÑ Loading from ${source.name}...`);
        const startTime = Date.now();
        
        // Add timeout to prevent hanging
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout per source
        
        const response = await fetch(source.url, { 
          signal: controller.signal 
        });
        clearTimeout(timeoutId);
        
          if (response.ok) {
            const data = await response.json();
          if (data.success && data.products && data.products.length > 0) {
            const convertedProducts = data.products.map((product, index) => source.converter(product, allLoadedProducts.length + index));
            allLoadedProducts = allLoadedProducts.concat(convertedProducts);
            loadedSources[source.name] = true;
            
            const loadTime = Date.now() - startTime;
            console.log(`‚úÖ Loaded ${data.products.length} products from ${source.name} in ${loadTime}ms (Total: ${allLoadedProducts.length})`);
              } else {
            loadedSources[source.name] = true; // Mark as loaded even if no products
            console.log(`‚ÑπÔ∏è ${source.name}: No products found`);
          }
        } else {
          loadedSources[source.name] = true; // Mark as loaded even if failed
          console.log(`‚ÑπÔ∏è ${source.name}: Server responded with status ${response.status}`);
          }
        } catch (error) {
        loadedSources[source.name] = true; // Mark as loaded even if failed
        if (error.name === 'AbortError') {
          console.log(`‚è∞ ${source.name}: Request timed out after 8 seconds`);
        } else {
          console.log(`‚ÑπÔ∏è ${source.name} not available:`, error.message);
        }
      }
    } else {
      console.log(`‚ÑπÔ∏è ${source.name} already loaded, skipping`);
    }
  }
  
  // Load AWS Lotus Online products if still needed and not already loaded
  if (allLoadedProducts.length < requiredIndex && !loadedSources['AWS Lotus Online']) {
    try {
      console.log('üîÑ Loading AWS Lotus Online products...');
      const startTime = Date.now();
      
      // Add timeout for AWS loading
      const awsProducts = await Promise.race([
        loadLotusOnlineAWSProducts(),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('AWS loading timeout')), 12000) // 12 second timeout
        )
      ]);
      
      if (awsProducts && awsProducts.length > 0) {
        allLoadedProducts = allLoadedProducts.concat(awsProducts);
        loadedSources['AWS Lotus Online'] = true;
        
        const loadTime = Date.now() - startTime;
        console.log(`‚úÖ Loaded ${awsProducts.length} AWS Lotus Online products in ${loadTime}ms (Total: ${allLoadedProducts.length})`);
    } else {
        loadedSources['AWS Lotus Online'] = true;
        console.log('‚ÑπÔ∏è AWS Lotus Online: No products found');
    }
  } catch (error) {
      loadedSources['AWS Lotus Online'] = true;
      if (error.message.includes('timeout')) {
        console.log('‚è∞ AWS Lotus Online: Request timed out after 12 seconds');
      } else {
        console.log('‚ÑπÔ∏è AWS Lotus Online not available:', error.message);
      }
    }
  } else if (loadedSources['AWS Lotus Online']) {
    console.log('‚ÑπÔ∏è AWS Lotus Online already loaded, skipping');
  }
  
  console.log(`üì¶ Total products loaded: ${allLoadedProducts.length}`);
  console.log(`üì¶ Loaded sources:`, loadedSources);
  
  // If we still don't have enough products, show what we have
  if (allLoadedProducts.length < requiredIndex && allLoadedProducts.length > 0) {
    console.log(`‚ö†Ô∏è Only loaded ${allLoadedProducts.length} products, but needed ${requiredIndex}. Showing what we have.`);
  }
}

// Function to test a single Firecrawl API response
async function testSingleFirecrawlResponse() {
  console.log('üß™ testSingleFirecrawlResponse function called');
  const testUrl = prompt('Enter a Lotus URL to test:', 'https://www.lotuss.com.my/en/product/70708630');
  if (!testUrl) return;
  
  try {
    console.log(`üß™ Testing Firecrawl API for: ${testUrl}`);
    
    const scrapeUrl = 'https://api.firecrawl.dev/v2/scrape';
    const options = {
      method: 'POST',
      headers: {
        'Authorization': 'Bearer fc-e4eb2258dbe34769b9be4a2c6ff9c86f',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        "url": testUrl,
        "formats": ["markdown"],
        "onlyMainContent": true
      })
    };

    const response = await fetch(scrapeUrl, options);
    const data = await response.json();
    
    console.log(`üß™ Test response:`, { status: response.status, data });
    showFirecrawlResponse(testUrl, response.status, data);
    
  } catch (error) {
    console.error('‚ùå Test error:', error);
    showFirecrawlResponse(testUrl, 'ERROR', { error: error.message });
  }
}

// Convert Firecrawl Lotus product data to our format
function convertFirecrawlProduct(firecrawlProduct, index) {
  const price = parseFloat(firecrawlProduct.price) || 0;
  const originalPrice = parseFloat(firecrawlProduct.original_price) || 0;
  const cleanTitle = cleanProductName(firecrawlProduct.label || firecrawlProduct.title);
  
  // Use extracted image URL from og:image meta tag
  let imageUrl = "https://via.placeholder.com/240x240.png?text=No+Image";
  if (firecrawlProduct.image_url) {
    imageUrl = firecrawlProduct.image_url;
  }
  
  // Fix price display - show "View Details" when price is 0
  const displayPrice = price > 0 ? price : "View Details";
  const priceNumeric = price > 0 ? price : 0;
  
  return {
    id: firecrawlProduct.id || `firecrawl-${index}`,
    gtin: firecrawlProduct.gtin || `FIRECRAWL${index.toString().padStart(6, '0')}`,
    title: cleanTitle,
    original_title: firecrawlProduct.original_name || firecrawlProduct.title || "Unknown Product",
    image_link: imageUrl,
    brand: firecrawlProduct.brand || "Unknown",
    category_path: firecrawlProduct.category_path || "General",
    rating: firecrawlProduct.rating || (4.0 + Math.random() * 1.0),
    rating_count: firecrawlProduct.review_count || Math.floor(Math.random() * 500) + 50,
    aggregate: { 
      currency: "MYR", 
      lowPrice: priceNumeric, 
      highPrice: priceNumeric, 
      offerCount: 1 
    },
    offers: [
      { 
        source: "lotuss", 
        marketplace: "lotuss", 
        merchant: firecrawlProduct.merchant || "Lotus's", 
        price: displayPrice, 
        currency: "MYR", 
        url: firecrawlProduct.product_url || "#", 
        promo: price > 0 ? (originalPrice > price ? "Special Price" : "Everyday Low") : "Click to View Price",
        original_price: originalPrice > 0 ? originalPrice : null,
        size: firecrawlProduct.size || "",
        packaging: firecrawlProduct.packaging || ""
      }
    ],
    // Additional Firecrawl-specific data
    firecrawl_data: {
      product_id: firecrawlProduct.product_id || "",
      product_url: firecrawlProduct.product_url,
      source: firecrawlProduct.source || "lotuss.com.my",
      scraped_at: firecrawlProduct.scraped_at || "",
      url: firecrawlProduct.url || "",
      has_price: price > 0,
      needs_price_fetch: price === 0,
      image_source: firecrawlProduct.image_url ? "og_image_extracted" : "placeholder",
      original_data: firecrawlProduct // Store the complete original data
    }
  };
}

// Load Lotus's Live data from Weekly Savers URL
async function loadLotusLiveData() {
  try {
    console.log('üåê Loading Lotus\'s Live data from Weekly Savers...');
    console.log('üì° URL: https://www.lotuss.com.my/en/shop/weekly-savers?sort=relevance:DESC');
    showNotification('üåê Loading Firecrawl data from Lotus website...', 'info');
    
    // For now, we'll use a proxy approach since direct CORS requests to lotuss.com.my will be blocked
    // We'll try to use the existing Firecrawl infrastructure or create a simple proxy
    const proxyUrl = 'http://localhost:5001/scrape-lotus-weekly-savers';
    
    console.log(`üì° Making request to proxy: ${proxyUrl}`);
    const response = await fetch(proxyUrl);
    
    if (!response.ok) {
      console.log(`‚ùå Proxy request failed: ${response.status} ${response.statusText}`);
      // Fallback to local JSON file if proxy fails
      console.log('üîÑ Falling back to local JSON file...');
      return await loadProductsFromFile('lotus_firecrawl_shopping_products_scraped.json');
    }
    
    const data = await response.json();
    console.log(`üì¶ Live data received:`, data);
    console.log(`üìä Data type:`, typeof data);
    console.log(`üî¢ Data length:`, Array.isArray(data) ? data.length : 'Not an array');
    
    if (Array.isArray(data) && data.length > 0) {
      console.log(`üîç First item:`, data[0]);
      showNotification(`‚úÖ Successfully loaded ${data.length} products from Firecrawl!`, 'success');
      return data;
    } else {
      console.log('‚ö†Ô∏è No products found in live data, falling back to local file...');
      showNotification('‚ö†Ô∏è No live data found, loading from local file...', 'warning');
      return await loadProductsFromFile('lotus_firecrawl_shopping_products_scraped.json');
    }
  } catch (error) {
    console.error('‚ùå Error loading Lotus\'s Live data:', error);
    console.log('üîÑ Falling back to local JSON file...');
    showNotification('‚ùå Error loading live data, falling back to local file...', 'warning');
    return await loadProductsFromFile('lotus_firecrawl_shopping_products_scraped.json');
  }
}



// Load products from JSON file
async function loadProductsFromFile(filename) {
  try {
    console.log(`üåê Making API call to fetch: ${filename}`);
    console.log(`üì° Full URL: ${window.location.origin}/${filename}`);
    
    // Show notification for Firecrawl data loading
    if (filename.includes('firecrawl')) {
      showNotification('üìÇ Loading Firecrawl data from local file...', 'info');
    }
    
    const response = await fetch(filename);
    console.log(`üìä Response status: ${response.status} ${response.statusText}`);
    console.log(`üìã Response headers:`, Object.fromEntries(response.headers.entries()));
    
    if (!response.ok) {
      if (response.status === 404) {
        console.log(`File not found: ${filename} (this is normal if the file doesn't exist)`);
      } else {
        console.log(`HTTP error loading ${filename}: ${response.status}`);
      }
      return [];
    }
    const fileData = await response.json();
    console.log(`üì¶ Raw data received:`, fileData);
    console.log(`üìä Data type:`, typeof fileData);
    console.log(`üî¢ Data length:`, Array.isArray(fileData) ? fileData.length : 'Not an array');
    if (Array.isArray(fileData) && fileData.length > 0) {
      console.log(`üîç First item:`, fileData[0]);
      // Show success notification for Firecrawl data
      if (filename.includes('firecrawl')) {
        showNotification(`‚úÖ Successfully loaded ${fileData.length} Firecrawl products from file!`, 'success');
      }
    }
    return fileData;
  } catch (error) {
    if (error.message.includes('Unexpected token')) {
      console.log(`Invalid JSON in ${filename} (file may be corrupted or not a valid JSON file)`);
    } else {
      console.log(`Error loading ${filename}: ${error.message}`);
    }
    
    // Show error notification for Firecrawl data
    if (filename.includes('firecrawl')) {
      showNotification(`‚ùå Error loading Firecrawl data from ${filename}`, 'error');
    }
    
    return [];
  }
}

// Load all available product data
async function loadAllProducts() {
  if (isLoading) return;
  isLoading = true;
  
  const loadingElement = document.getElementById('grid');
  loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Loading products from all data sources...</div>';
  
  allProducts = [];
  
  // Load from static JSON files
  for (const source of DATA_SOURCES) {
    try {
      console.log(`Loading ${source.name}...`);
      let products;
      
      // Load from static JSON files or PostgreSQL
      if (source.file === 'postgresql_direct') {
        products = await loadPostgreSQLDataDirect();
      } else if (source.file === 'postgresql_all_horeca') {
        products = await loadAllHorecaProductsFromPostgreSQL();
      } else if (source.file === 'postgresql_horeca') {
        products = await loadHorecaProductsFromPostgreSQL();
      } else if (source.file === 'postgresql_horeca_openai') {
        products = await loadHorecaOpenAIProductsFromPostgreSQL();
      } else if (source.file === 'postgresql_lotus_wk34_horeca') {
        products = await loadLotusWK34HorecaProductsFromPostgreSQL();
      } else if (source.file === 'postgresql_horeca_image_ocr') {
        products = await loadHorecaImageOCRProductsFromPostgreSQL();
      } else if (source.file === 'lotus_online_aws') {
        products = await loadLotusOnlineAWSProducts();
      } else {
        products = await loadProductsFromFile(source.file);
      }
      
      if (products && products.length > 0) {
      // Set current data source for pagination
      currentDataSource = source.file;
      
      // Use appropriate converter based on data source
      let converter;
      if (source.name === "Lotus Live (Firecrawl)") {
        converter = convertFirecrawlProduct;
      } else if (source.file === 'postgresql_direct') {
        // For direct PostgreSQL loading, we don't need conversion as loadPostgreSQLDataDirect already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (source.file === 'postgresql_all_horeca') {
        // For All HORECA PostgreSQL loading, we don't need conversion as loadAllHorecaProductsFromPostgreSQL already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (source.file === 'postgresql_horeca') {
        // For HORECA PostgreSQL loading, we don't need conversion as loadHorecaProductsFromPostgreSQL already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (source.file === 'postgresql_horeca_openai') {
        // For HORECA OpenAI PostgreSQL loading, we don't need conversion as loadHorecaOpenAIProductsFromPostgreSQL already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (source.file === 'postgresql_lotus_wk34_horeca') {
        // For Lotus WK34 HORECA PostgreSQL loading, we don't need conversion as loadLotusWK34HorecaProductsFromPostgreSQL already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (source.file === 'postgresql_horeca_image_ocr') {
        // For HORECA Image OCR PostgreSQL loading, we don't need conversion as loadHorecaImageOCRProductsFromPostgreSQL already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (source.file === 'lotus_online_aws') {
        // For AWS Lotus Online loading, we don't need conversion as loadLotusOnlineAWSProducts already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else {
        converter = convertLotusProduct;
      }
      console.log(`üîß Using converter for ${source.name}:`, converter.name);
      const convertedProducts = products.map((product, index) => {
        const converted = converter(product, allProducts.length + index);
        if (index < 2) {
          console.log(`üîç Converted product ${index}:`, {
            original: product,
            converted: converted
          });
        }
        return converted;
      });
        allProducts = allProducts.concat(convertedProducts);
        console.log(`Loaded ${products.length} products from ${source.name}`);
      }
    } catch (error) {
      console.error(`Failed to load ${source.name}:`, error);
    }
  }
  
  // Load from HORECA API
  try {
    console.log('Loading HORECA pr`oducts from API...');
    const response = await fetch('tp://localhost:5002/products');
    if (response.ok) {
      const horecaResponseData = await response.json();
      const horecaProducts = horecaResponseData.products || [];
      
      if (horecaProducts.length > 0) {
        const convertedHorecaProducts = await Promise.all(
          horecaProducts.map((product, index) => convertHorecaProduct(product, allProducts.length + index))
        );
        allProducts = allProducts.concat(convertedHorecaProducts);
        console.log(`Loaded ${horecaProducts.length} products from HORECA API`);
      }
    } else {
      console.log('‚ÑπÔ∏è HORECA API returned error status:', response.status);
    }
  } catch (error) {
    console.log('HORECA API not available (this is normal if the server is not running)');
  }
  
  // Load from HORECA OpenAI API
  try {
    console.log('üîÑ Loading HORECA OpenAI products from API...');
    console.log('üåê Making API call to: http://localhost:5004/products (Enhanced Server with Database)');
    const response = await fetch('http://localhost:5004/products?v=' + Date.now());
    console.log('üì° Response status:', response.status, response.statusText);
    
    if (response.ok) {
      const horecaOpenAIResponseData = await response.json();
      console.log('üìä HORECA OpenAI response data:', horecaOpenAIResponseData);
      const horecaOpenAIProducts = horecaOpenAIResponseData.products || [];
      
      if (horecaOpenAIProducts.length > 0) {
        const convertedHorecaOpenAIProducts = horecaOpenAIProducts.map((product, index) => convertHorecaOpenAIProduct(product, allProducts.length + index));
        allProducts = allProducts.concat(convertedHorecaOpenAIProducts);
        
        // Show database source information
        if (horecaOpenAIResponseData.source === 'database') {
          console.log(`üóÑÔ∏è Retrieved ${horecaOpenAIProducts.length} HORECA products from API`);
          console.log(`üìä Database records: ${horecaOpenAIResponseData.records_from_database ? 'YES' : 'NO'}`);
        } else {
          console.log(`‚úÖ Loaded ${horecaOpenAIProducts.length} products from HORECA OpenAI API`);
        }
        console.log('üìã Sample HORECA OpenAI products:', convertedHorecaOpenAIProducts.slice(0, 3));
      } else {
        console.log('‚ö†Ô∏è No HORECA OpenAI products found in response');
      }
    } else {
      console.error('‚ùå Failed to load HORECA OpenAI products:', response.status, response.statusText);
    }
  } catch (error) {
    console.log('‚ÑπÔ∏è HORECA OpenAI API not available:', error.message);
    console.log('‚ÑπÔ∏è This is normal if the server is not running on localhost:5004');
  }
  
  // Load from Lotus API
  try {
    console.log('Loading Lotus products from API...');
    const response = await fetch('http://localhost:5000/search?q=&limit=50');
    if (response.ok) {
      const lotusResponseData = await response.json();
      const lotusProducts = lotusResponseData.products || [];
      
      if (lotusProducts.length > 0) {
        const convertedLotusProducts = lotusProducts.map((product, index) => convertLiveSearchResult(product, allProducts.length + index));
        allProducts = allProducts.concat(convertedLotusProducts);
        console.log(`Loaded ${lotusProducts.length} products from Lotus API`);
      }
    } else {
      console.error('Failed to load Lotus products:', response.status);
    }
  } catch (error) {
    console.log('Lotus API not available (this is normal if the server is not running)');
  }
  
  // Update FEED with loaded products
  FEED = allProducts;
  isLoading = false;
  
  // Re-render the grid
  render();
  
  console.log(`Total products loaded: ${FEED.length}`);
  console.log('Sample products:', allProducts.slice(0, 3).map(p => ({ title: p.title, category: p.category_path, source: p.offers?.[0]?.source })));
  
  // Render products normally after loading is complete
  setTimeout(() => {
    render();
  }, 1000);
}

// Search products by name
function searchProducts(query) {
  if (!query || query.trim() === '') {
    FEED = allProducts;
  } else {
    const searchTerm = query.toLowerCase();
    FEED = allProducts.filter(product => 
      product.title.toLowerCase().includes(searchTerm) ||
      product.brand.toLowerCase().includes(searchTerm) ||
      product.category_path.toLowerCase().includes(searchTerm)
    );
  }
  render();
}

// Convert live search result to our format
function convertLiveSearchResult(liveProduct, index) {
  const priceText = liveProduct.price || '';
  const priceMatch = priceText.match(/RM\s*([\d,]+\.?\d*)/);
  const price = priceMatch ? parseFloat(priceMatch[1].replace(',', '')) : 0;

  // Use offers from API if available, otherwise create default
  const offers = liveProduct.offers || [
    {
      source: "lotuss",
      marketplace: "lotuss",
      merchant: "Lotus's",
      price: price,
      currency: "MYR",
      availability: "in-stock",
      url: liveProduct.url || "#",
      promo: "Live Price"
    }
  ];

  return {
    id: `live-${index}`,
    gtin: `LIVE${index.toString().padStart(6, '0')}`,
    title: translateProductName(liveProduct.name) || "Unknown Product",
    original_title: liveProduct.name || "Unknown Product",
    image_link: liveProduct.image || "https://via.placeholder.com/240x240.png?text=No+Image",
    brand: liveProduct.category || "Lotus's",
    category_path: liveProduct.category || "General",
    rating: 4.0 + Math.random() * 1.0, // Simulated rating
    rating_count: Math.floor(Math.random() * 500) + 50,
    aggregate: { 
      currency: "MYR", 
      lowPrice: Math.min(...offers.map(o => o.price)), 
      highPrice: Math.max(...offers.map(o => o.price)), 
      offerCount: offers.length 
    },
    offers: offers,
    // Additional live search data
    live_data: {
      source_url: liveProduct.url || "",
      search_timestamp: liveProduct.search_timestamp || Date.now(),
      original_price_text: liveProduct.price || ""
    }
  };
}

// Convert live English search result to our format
function convertLiveEnglishSearchResult(liveProduct, index) {
  const priceText = liveProduct.price || '';
  const priceMatch = priceText.match(/RM\s*([\d,]+\.?\d*)/);
  const price = priceMatch ? parseFloat(priceMatch[1].replace(',', '')) : 0;

  // Use offers from API if available, otherwise create default
  const offers = liveProduct.offers || [
    {
      source: "lotuss",
      marketplace: "lotuss",
      merchant: "Lotus's",
      price: price,
      currency: "MYR",
      availability: "in-stock",
      url: liveProduct.url || "#",
      promo: "Live English Price"
    }
  ];

  return {
    id: `live-english-${index}`,
    gtin: `LIVEEN${index.toString().padStart(6, '0')}`,
    title: liveProduct.name || "Unknown Product", // Already in English from /en/ site
    original_title: liveProduct.name || "Unknown Product",
    image_link: liveProduct.image || "https://via.placeholder.com/240x240.png?text=No+Image",
    brand: liveProduct.category || "Lotus's",
    category_path: liveProduct.category || "General",
    rating: 4.0 + Math.random() * 1.0, // Simulated rating
    rating_count: Math.floor(Math.random() * 500) + 50,
    aggregate: { 
      currency: "MYR", 
      lowPrice: Math.min(...offers.map(o => o.price)), 
      highPrice: Math.max(...offers.map(o => o.price)), 
      offerCount: offers.length 
    },
    offers: offers,
    // Additional live English search data
    live_english_data: {
      source_url: liveProduct.url || "",
      search_timestamp: Date.now(),
      original_price_text: liveProduct.price || "",
      source: liveProduct.source || "lotuss.com.my/en"
    }
  };
}

// Search HORECA products
async function searchHorecaProducts(query) {
  if (!query || query.trim() === '') {
    alert('Please enter a search term');
    return;
  }
  
  const loadingElement = document.getElementById('grid');
  loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Searching HORECA products for "' + query + '"...</div>';
  
  try {
    const response = await fetch(`http://localhost:5002/search?q=${encodeURIComponent(query)}&limit=20`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const horecaSearchData = await response.json();
    
    if (horecaSearchData.success && horecaSearchData.products && horecaSearchData.products.length > 0) {
      const convertedProducts = await Promise.all(
        horecaSearchData.products.map((product, index) => convertHorecaProduct(product, index))
      );
      allProducts = convertedProducts;
      FEED = allProducts;
      console.log(`Found ${horecaSearchData.products.length} HORECA products for "${query}"`);
    } else {
      allProducts = [];
      FEED = [];
      loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No HORECA products found for "' + query + '"</div>';
      return;
    }
    
    render();
    
  } catch (error) {
    console.log('‚ÑπÔ∏è HORECA search API not available:', error.message);
    loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">HORECA search API not available. Using other data sources.</div>';
  }
}

// Search products live from Lotus website
async function searchLiveProducts(query) {
  if (!query || query.trim() === '') {
    alert('Please enter a search term');
    return;
  }
  
  const loadingElement = document.getElementById('grid');
  loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Searching live products from lotuss.com.my for "' + query + '"...</div>';
  
  try {
    // Try real-time scraper first
    let response = await fetch(`http://localhost:5009/search?q=${encodeURIComponent(query)}&limit=20`);
    let data = await response.json();
    
    if (!data.success || !data.products || data.products.length === 0) {
      // Fallback to mock API
      response = await fetch(`http://localhost:5000/search?q=${encodeURIComponent(query)}&limit=20`);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      data = await response.json();
    }
    
    if (data.products && data.products.length > 0) {
      const convertedProducts = data.products.map((product, index) => convertLiveSearchResult(product, index));
      allProducts = convertedProducts;
      FEED = allProducts;
      console.log(`Found ${data.products.length} live products for "${query}"`);
    } else {
      allProducts = [];
      FEED = [];
      loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No products found for "' + query + '" on lotuss.com.my</div>';
      return;
    }
    
    render();
    
  } catch (error) {
    console.error('Error searching live products:', error);
    loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #c62828;">Error searching live products. Make sure the search API is running on localhost:5000</div>';
  }
}

// Search products live from Lotus English website
async function searchLiveEnglishProducts(query) {
  if (!query || query.trim() === '') {
    alert('Please enter a search term');
    return;
  }

  const loadingElement = document.getElementById('grid');
  loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Searching live products from lotuss.com.my/en for "' + query + '"...</div>';

  try {
    const response = await fetch(`http://localhost:5003/search?q=${encodeURIComponent(query)}&limit=20`);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const englishSearchData = await response.json();

    if (englishSearchData.products && englishSearchData.products.length > 0) {
      const convertedProducts = englishSearchData.products.map((product, index) => convertLiveEnglishSearchResult(product, index));

      allProducts = convertedProducts;
      FEED = allProducts;
      console.log(`Found ${englishSearchData.products.length} live English products for "${query}"`);

    } else {
      allProducts = [];
      FEED = [];
      loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No products found for "' + query + '" on lotuss.com.my/en</div>';

      return;
    }

    render();

  } catch (error) {
    console.error('Error searching live English products:', error);
    loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #c62828;">Error searching live English products. Make sure the English search API is running on localhost:5003</div>';

  }
}

// Load HORECA data from external API
async function loadHorecaData() {
  if (isLoading) return;
  isLoading = true;
  
  const loadingElement = document.getElementById('grid');
  loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Loading HORECA WK34 products...</div>';
  
  try {
    const response = await fetch('http://localhost:5002/products');
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const horecaLoadData = await response.json();
    
    if (horecaLoadData.success && horecaLoadData.products && horecaLoadData.products.length > 0) {
      const convertedProducts = await Promise.all(
        horecaLoadData.products.map((product, index) => convertHorecaProduct(product, index))
      );
      allProducts = convertedProducts;
      FEED = allProducts;
      console.log(`Loaded ${horecaLoadData.products.length} HORECA products`);
    } else {
      allProducts = [];
      FEED = [];
      console.log('No HORECA products found');
    }
  } catch (error) {
    console.log('‚ÑπÔ∏è HORECA data API not available:', error.message);
    allProducts = [];
    FEED = [];
    loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">HORECA data API not available. Using other data sources.</div>';
  }
  
  isLoading = false;
  render();
}

// Convert HORECA product to our format
async function convertHorecaProduct(horecaProduct, index) {
  const price = parseFloat(horecaProduct.price.replace('RM ', '')) || 0;
  
  // Clean the product name by removing number prefixes (1., 2., etc.)
  const cleanProductName = (horecaProduct.name || "Unknown Product").replace(/^\d+\.\s*/, '').trim();
  
  // Translate the product name using TMAPI
  const translatedTitle = await translateProductName(cleanProductName);
  
  return {
    id: horecaProduct.id || `horeca-${index}`,
    gtin: `HORECA${index.toString().padStart(6, '0')}`,
    title: translatedTitle || "Unknown Product",
    original_title: cleanProductName,
    image_link: horecaProduct.image || "https://picsum.photos/240/240?random=" + index,
    brand: "HORECA WK34",
    category_path: horecaProduct.category || "HORECA Products",
    rating: 4.0 + Math.random() * 1.0, // Simulated rating
    rating_count: Math.floor(Math.random() * 500) + 50,
    aggregate: { 
      currency: "MYR", 
      lowPrice: price, 
      highPrice: price, 
      offerCount: horecaProduct.offers ? horecaProduct.offers.length : 1 
    },
    offers: horecaProduct.offers || [
      { 
        source: "horeca", 
        marketplace: "horeca",
        merchant: "HORECA WK34", 
        price: price, 
        currency: "MYR", 
        url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca", 
        promo: "HORECA Special"
      }
    ],
    // Add URL fields for display
    url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    product_url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    see_more_link: horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    // Additional HORECA-specific data
    horeca_data: horecaProduct.horeca_data || {}
  };
}

// Load HORECA OpenAI PDF data from external API
async function loadHorecaOpenAIData() {
  if (isLoading) return;
  isLoading = true;
  
  const loadingElement = document.getElementById('grid');
  loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">ü§ñ Processing HORECA WK34 PDF with OpenAI Vision API...</div>';
  
  try {
    console.log('üåê Making API call to: http://localhost:5004/products (Enhanced Server with Database)');
    const response = await fetch('http://localhost:5004/products');
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const horecaOpenAIData = await response.json();
    
    if (horecaOpenAIData.success && horecaOpenAIData.products && horecaOpenAIData.products.length > 0) {
      const convertedProducts = horecaOpenAIData.products.map((product, index) => convertHorecaOpenAIProduct(product, index));
      allProducts = convertedProducts;
      FEED = allProducts;
      
      // Show database source information
      if (horecaOpenAIData.source === 'database') {
        console.log(`üóÑÔ∏è Retrieved ${horecaOpenAIData.products.length} HORECA products from API`);
        console.log(`üìä Database records: ${horecaOpenAIData.records_from_database ? 'YES' : 'NO'}`);
      } else {
        console.log(`‚úÖ Loaded ${horecaOpenAIData.products.length} HORECA OpenAI products`);
      }
      console.log('üìä Sample products:', horecaOpenAIData.products.slice(0, 3));
    } else {
      allProducts = [];
      FEED = [];
      console.log('‚ùå No HORECA OpenAI products found');
      loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #c62828;">No products found in PDF or processing failed</div>';
    }
  } catch (error) {
    console.log('‚ÑπÔ∏è HORECA OpenAI data API not available:', error.message);
    allProducts = [];
    FEED = [];
    loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">HORECA OpenAI data API not available. Using other data sources.</div>';
  }
  
  isLoading = false;
  render();
}

// Convert HORECA OpenAI product to our format
function convertHorecaOpenAIProduct(horecaProduct, index) {
  const price = horecaProduct.price_numeric || 0;
  
  // Clean product names by removing number prefixes (1., 2., etc.)
  const cleanTitle = (horecaProduct.name_english || horecaProduct.name || "Unknown Product").replace(/^\d+\.\s*/, '').trim();
  const cleanOriginalTitle = (horecaProduct.name || "Unknown Product").replace(/^\d+\.\s*/, '').trim();
  
  return {
    id: horecaProduct.id || `horeca-openai-${index}`,
    gtin: `HORECA-OPENAI-${index.toString().padStart(6, '0')}`,
    title: cleanTitle,
    original_title: cleanOriginalTitle,
    image_link: horecaProduct.image || "https://picsum.photos/240/240?random=" + index,
    brand: "HORECA WK34 (OpenAI)",
    category_path: horecaProduct.category || "HORECA Products",
    rating: 4.0 + Math.random() * 1.0, // Simulated rating
    rating_count: Math.floor(Math.random() * 500) + 50,
    aggregate: { 
      currency: "MYR", 
      lowPrice: price, 
      highPrice: price, 
      offerCount: 1 
    },
    offers: [
      { 
        source: "horeca-openai", 
        marketplace: "horeca",
        merchant: "HORECA WK34 (OpenAI)", 
        price: price, 
        currency: "MYR", 
        url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca", 
        promo: "OpenAI PDF Processing"
      }
    ],
    // Add URL fields for display
    url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    product_url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    see_more_link: horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    // Additional HORECA OpenAI-specific data
    horeca_openai_data: {
      description: horecaProduct.description || '',
      discount: horecaProduct.discount || 'N/A',
      bulk_quantity: horecaProduct.bulk_quantity || 'N/A',
      bulk_price: horecaProduct.bulk_price || 'N/A',
      savings: horecaProduct.savings || 'N/A',
      source: horecaProduct.source || 'openai_pdf_processing'
    }
  };
}

// Convert HORECA Image OCR product to our format
function convertHorecaImageOCRProduct(horecaProduct, index) {
  const price = horecaProduct.price_numeric || 0;
  
  // Clean product names by removing number prefixes (1., 2., etc.)
  const cleanTitle = (horecaProduct.name_english || horecaProduct.name || "Unknown Product").replace(/^\d+\.\s*/, '').trim();
  const cleanOriginalTitle = (horecaProduct.name || "Unknown Product").replace(/^\d+\.\s*/, '').trim();
  
  return {
    id: horecaProduct.id || `horeca-image-ocr-${index}`,
    gtin: `HORECA-IMAGE-OCR-${index.toString().padStart(6, '0')}`,
    title: cleanTitle,
    original_title: cleanOriginalTitle,
    image_link: horecaProduct.image || "https://picsum.photos/240/240?random=" + index,
    brand: "HORECA Image OCR",
    category_path: horecaProduct.category || "HORECA Products",
    rating: 4.0 + Math.random() * 1.0, // Simulated rating
    rating_count: Math.floor(Math.random() * 500) + 50,
    aggregate: { 
      currency: "MYR", 
      lowPrice: price, 
      highPrice: price, 
      offerCount: 1 
    },
    offers: [
      { 
        source: "horeca-image-ocr", 
        marketplace: "horeca",
        merchant: "HORECA Image OCR", 
        price: price, 
        currency: "MYR", 
        url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca", 
        promo: "Image OCR Processing"
      }
    ],
    // Add URL fields for display
    url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    product_url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    see_more_link: horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    // Additional HORECA Image OCR-specific data
    horeca_image_ocr_data: {
      description: horecaProduct.description || '',
      discount: horecaProduct.discount || 'N/A',
      bulk_quantity: horecaProduct.bulk_quantity || 'N/A',
      bulk_price: horecaProduct.bulk_price || 'N/A',
      savings: horecaProduct.savings || 'N/A',
      source: horecaProduct.source || 'image_ocr_processing'
    }
  };
}

// Convert Lotus WK34 HORECA product to our format
function convertLotusWK34HorecaProduct(horecaProduct, index) {
  const price = horecaProduct.price_numeric || 0;
  
  // Clean product names by removing number prefixes (1., 2., etc.)
  const cleanTitle = (horecaProduct.name_english || horecaProduct.name || "Unknown Product").replace(/^\d+\.\s*/, '').trim();
  const cleanOriginalTitle = (horecaProduct.name || "Unknown Product").replace(/^\d+\.\s*/, '').trim();
  
  return {
    id: horecaProduct.id || `lotus-wk34-horeca-${index}`,
    gtin: `LOTUS-WK34-HORECA-${index.toString().padStart(6, '0')}`,
    title: cleanTitle,
    original_title: cleanOriginalTitle,
    image_link: horecaProduct.image || "https://picsum.photos/240/240?random=" + index,
    brand: "Lotus WK34 HORECA",
    category_path: horecaProduct.category || "Lotus WK34 HORECA Products",
    rating: 4.0 + Math.random() * 1.0, // Simulated rating
    rating_count: Math.floor(Math.random() * 500) + 50,
    aggregate: { 
      currency: "MYR", 
      lowPrice: price, 
      highPrice: price, 
      offerCount: 1 
    },
    offers: [
      { 
        source: "lotus-wk34-horeca", 
        marketplace: "lotus",
        merchant: "Lotus WK34 HORECA", 
        price: price, 
        currency: "MYR", 
        url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca", 
        promo: "WK34 HORECA Processing"
      }
    ],
    // Add URL fields for display
    url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    product_url: horecaProduct.url || horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    see_more_link: horecaProduct.see_more_link || "https://www.lotuss.com.my/en/category/horeca",
    // Additional Lotus WK34 HORECA-specific data
    lotus_wk34_horeca_data: {
      description: horecaProduct.description || '',
      discount: horecaProduct.discount || 'N/A',
      bulk_quantity: horecaProduct.bulk_quantity || 'N/A',
      bulk_price: horecaProduct.bulk_price || 'N/A',
      savings: horecaProduct.savings || 'N/A',
      source: horecaProduct.source || 'lotus_wk34_horeca_processing'
    }
  };
}

// Search HORECA OpenAI products
async function searchHorecaOpenAIProducts(query) {
  if (isLoading) return;
  isLoading = true;
  
  const loadingElement = document.getElementById('grid');
  loadingElement.innerHTML = `<div style="text-align: center; padding: 40px; color: #666;">üîç Searching HORECA OpenAI products for "${query}"...</div>`;
  
  try {
    console.log('üåê Making search API call to: http://localhost:5004/search (Enhanced Server with Database)');
    const response = await fetch(`http://localhost:5004/search?q=${encodeURIComponent(query)}&limit=50`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const horecaOpenAISearchData = await response.json();
    
    if (horecaOpenAISearchData.success && horecaOpenAISearchData.products && horecaOpenAISearchData.products.length > 0) {
      const convertedProducts = horecaOpenAISearchData.products.map((product, index) => convertHorecaOpenAIProduct(product, index));
      allProducts = convertedProducts;
      FEED = allProducts;
      console.log(`‚úÖ Found ${horecaOpenAISearchData.products.length} HORECA OpenAI products for "${query}"`);
    } else {
      allProducts = [];
      FEED = [];
      console.log(`‚ùå No HORECA OpenAI products found for "${query}"`);
      loadingElement.innerHTML = `<div style="text-align: center; padding: 40px; color: #c62828;">No products found for "${query}"</div>`;
    }
  } catch (error) {
    console.log('‚ÑπÔ∏è HORECA OpenAI search API not available:', error.message);
    allProducts = [];
    FEED = [];
    loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">HORECA OpenAI search API not available. Using other data sources.</div>';
  }
  
  isLoading = false;
  render();
}

// Load specific data source
async function loadSpecificDataSource(filename) {
  if (isLoading) return;
  isLoading = true;
  
  // Show notification for Firecrawl data source loading
  if (filename.includes('firecrawl')) {
    showNotification(`üìÇ Loading Firecrawl data source: ${filename}`, 'info');
  }
  
  const loadingElement = document.getElementById('grid');
  loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Loading products from ' + filename + '...</div>';
  
  try {
    let products;
    
    // Handle special case for All (Lotus only)
    if (filename === 'postgresql_direct') {
      console.log('üéØ Loading PostgreSQL data directly...');
      products = await loadPostgreSQLDataDirect();
    }
    // Handle special case for All HORECA products
    else if (filename === 'postgresql_all_horeca') {
      console.log('üõí Loading All HORECA products from PostgreSQL...');
      products = await loadAllHorecaProductsFromPostgreSQL();
    }
    // Handle special case for PostgreSQL HORECA products
    else if (filename === 'postgresql_horeca') {
      console.log('üõí Loading HORECA products from PostgreSQL...');
      products = await loadHorecaProductsFromPostgreSQL();
    }
    // Handle special case for WK34 HORECA JSON display
    else if (filename === 'wk34_horeca_json') {
      console.log('üìÑ Loading WK34 HORECA JSON data...');
      products = await loadWK34HorecaJSON();
    }
    // Handle special case for PostgreSQL HORECA OpenAI products
    else if (filename === 'postgresql_horeca_openai') {
      console.log('ü§ñ Loading HORECA OpenAI products from PostgreSQL...');
      products = await loadHorecaOpenAIProductsFromPostgreSQL();
    }
    // Handle special case for PostgreSQL Lotus WK34 HORECA products
    else if (filename === 'postgresql_lotus_wk34_horeca') {
      console.log('üõí Loading Lotus WK34 HORECA products from PostgreSQL...');
      products = await loadLotusWK34HorecaProductsFromPostgreSQL();
    }
    // Handle special case for PostgreSQL HORECA Image OCR products
    else if (filename === 'postgresql_horeca_image_ocr') {
      console.log('üì∑ Loading HORECA Image OCR products from PostgreSQL...');
      products = await loadHorecaImageOCRProductsFromPostgreSQL();
    }
    // Handle special case for AWS Lotus Online products
    else if (filename === 'lotus_online_aws') {
      console.log('‚òÅÔ∏è Loading Lotus Online products from AWS Lambda...');
      showRefreshNotification('‚òÅÔ∏è Loading AWS Lotus Online products from Lambda API...', 'loading');
      products = await loadLotusOnlineAWSProducts();
    }
    // Handle special case for Reusable Lotus URLs
    else if (filename === 'reusable_lotus_urls') {
      console.log('üîÑ Loading Reusable Lotus URLs...');
      products = await loadReusableLotusUrls();
    }
    // Handle special case for Lotus's Live data - load from live URL
    else if (filename === 'lotus_firecrawl_shopping_products_scraped.json') {
      console.log('üåê Loading Lotus\'s Live data from Weekly Savers URL...');
      products = await loadLotusLiveData();
    } else {
      products = await loadProductsFromFile(filename);
    }
    
    console.log(`üîç Products loaded in loadSpecificDataSource:`, products);
    console.log(`üîç Products length:`, products ? products.length : 'undefined');
    
    if (products && products.length > 0) {
      // Use appropriate converter based on filename
      let converter;
      if (filename.includes('firecrawl')) {
        converter = convertFirecrawlProduct;
      } else if (filename === 'postgresql_direct') {
        // For direct PostgreSQL loading, we don't need conversion as loadPostgreSQLDataDirect already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (filename === 'postgresql_all_horeca') {
        // For All HORECA PostgreSQL loading, we don't need conversion as loadAllHorecaProductsFromPostgreSQL already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (filename === 'postgresql_horeca') {
        // For HORECA PostgreSQL loading, we don't need conversion as loadHorecaProductsFromPostgreSQL already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (filename === 'wk34_horeca_json') {
        // For WK34 HORECA JSON display, we don't need conversion as loadWK34HorecaJSON already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (filename === 'postgresql_horeca_openai') {
        // For HORECA OpenAI PostgreSQL loading, we don't need conversion as loadHorecaOpenAIProductsFromPostgreSQL already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (filename === 'postgresql_lotus_wk34_horeca') {
        // For Lotus WK34 HORECA PostgreSQL loading, we don't need conversion as loadLotusWK34HorecaProductsFromPostgreSQL already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (filename === 'postgresql_horeca_image_ocr') {
        // For HORECA Image OCR PostgreSQL loading, we don't need conversion as loadHorecaImageOCRProductsFromPostgreSQL already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (filename === 'lotus_online_aws') {
        // For AWS Lotus Online loading, we don't need conversion as loadLotusOnlineAWSProducts already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else if (filename === 'reusable_lotus_urls') {
        // For reusable Lotus URLs, we don't need conversion as loadReusableLotusUrls already returns converted products
        converter = (product) => product; // Identity function - no conversion needed
      } else {
        converter = convertLotusProduct;
      }
      console.log(`üîß Using converter for ${filename}:`, converter.name);
      
      // Show notification for Firecrawl data conversion
      if (filename.includes('firecrawl')) {
        showNotification(`üîÑ Converting ${products.length} Firecrawl products to shopping format...`, 'info');
      }
      // Show notification for All loading
      else if (filename === 'postgresql_direct') {
        showRefreshNotification(`‚úÖ Loaded ${products.length} products from all sources!`, 'success');
      }
      // Show notification for All HORECA PostgreSQL loading
      else if (filename === 'postgresql_all_horeca') {
        showRefreshNotification(`‚úÖ Loaded ${products.length} All HORECA products!`, 'success');
      }
      // Show notification for HORECA PostgreSQL loading
      else if (filename === 'postgresql_horeca') {
        showRefreshNotification(`‚úÖ Loaded ${products.length} HORECA WK34 products!`, 'success');
      }
      // Show notification for WK34 HORECA JSON loading
      else if (filename === 'wk34_horeca_json') {
        showRefreshNotification(`üìÑ Loaded ${products.length} WK34 HORECA JSON products!`, 'success');
      }
      // Show notification for HORECA OpenAI PostgreSQL loading
      else if (filename === 'postgresql_horeca_openai') {
        showRefreshNotification(`‚úÖ Loaded ${products.length} HORECA OpenAI products!`, 'success');
      }
      // Show notification for Lotus WK34 HORECA PostgreSQL loading
      else if (filename === 'postgresql_lotus_wk34_horeca') {
        showRefreshNotification(`‚úÖ Loaded ${products.length} Lotus WK34 HORECA products!`, 'success');
      }
      // Show notification for HORECA Image OCR PostgreSQL loading
      else if (filename === 'postgresql_horeca_image_ocr') {
        showRefreshNotification(`‚úÖ Loaded ${products.length} HORECA Image OCR products!`, 'success');
      }
      // Show notification for AWS Lotus Online loading
      else if (filename === 'lotus_online_aws') {
        showRefreshNotification(`‚úÖ Loaded ${products.length} Lotus Online (AWS) products and wrote to PostgreSQL database!`, 'success');
      }
      // Show notification for Reusable Lotus URLs loading
      else if (filename === 'reusable_lotus_urls') {
        showNotification(`üîÑ Loaded ${products.length} reusable Lotus URLs from database!`, 'success');
      }
      
      const convertedProducts = products.map((product, index) => {
        const converted = converter(product, index);
        return converted;
      });
      allProducts = convertedProducts;
      FEED = allProducts;
      console.log(`Loaded ${products.length} products from ${filename}`);
      
      
      // Show success notification for Firecrawl data conversion
      if (filename.includes('firecrawl')) {
        showNotification(`‚úÖ Successfully converted ${convertedProducts.length} Firecrawl products!`, 'success');
        
      }
      
      // Show popup for Firecrawl data (inside the try block where products is accessible)
      if (filename.includes('firecrawl')) {
        console.log('üî• FORCING FIRECRAWL POPUP TO SHOW');
        console.log('About to call showFirecrawlDataPopup with:', products);
        showFirecrawlDataPopup(products);
        console.log('showFirecrawlDataPopup called');
        
        // Also update the Firecrawl data tab
        updateFirecrawlDataTab(products);
        
        // Automatically fetch prices for products with price = 0
        console.log('üîÑ Setting up auto-fetch for zero prices in 2 seconds...');
        setTimeout(() => {
          console.log('üîÑ Auto-fetch timer triggered, calling autoFetchZeroPrices...');
          autoFetchZeroPrices(convertedProducts);
        }, 2000); // Wait 2 seconds after loading to start fetching
      }
    } else {
      allProducts = [];
      FEED = [];
      console.log(`No products found in ${filename}`);
    }
  } catch (error) {
    console.error(`Failed to load ${filename}:`, error);
    allProducts = [];
    FEED = [];
  }
  
  isLoading = false;
  
  // Show completion notification for Firecrawl data
  if (filename.includes('firecrawl') && FEED.length > 0) {
    showNotification(`üéâ Firecrawl data loading complete! ${FEED.length} products ready for display.`, 'success');
  }
  
  render();
}

// Function to show Firecrawl data in a popup
function showFirecrawlDataPopup(products) {
  try {
    console.log('=== FIRECRAWL DATA POPUP ===');
    console.log('Number of products:', products ? products.length : 'undefined');
    console.log('Raw Firecrawl data:', products);
    if (products && products.length > 0) {
      console.log('First product:', products[0]);
    }
    console.log('===========================');
    
    // Create a simple alert first to test
    alert(`Firecrawl Data Loaded!\n\nProducts: ${products ? products.length : 0}\n\nFirst product: ${products && products.length > 0 ? products[0].title : 'None'}\n\nCheck console for full data.`);
    
    const popup = document.createElement('div');
  popup.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80%;
    height: 80%;
    background: white;
    border: 2px solid #4285f4;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    z-index: 10000;
    overflow: auto;
    padding: 20px;
    font-family: monospace;
    font-size: 12px;
  `;
  
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Close';
  closeBtn.style.cssText = `
    position: absolute;
    top: 10px;
    right: 10px;
    padding: 8px 16px;
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  `;
  closeBtn.onclick = () => document.body.removeChild(popup);
  
  const title = document.createElement('h3');
  title.textContent = `Firecrawl Data (${products.length} products)`;
  title.style.marginTop = '0';
  
  const content = document.createElement('pre');
  content.textContent = JSON.stringify(products, null, 2);
  content.style.cssText = `
    background: #f8f9fa;
    padding: 15px;
    border-radius: 4px;
    overflow: auto;
    max-height: calc(100% - 100px);
  `;
  
  popup.appendChild(closeBtn);
  popup.appendChild(title);
  popup.appendChild(content);
  document.body.appendChild(popup);
  
  console.log('‚úÖ Firecrawl data popup created and added to DOM');
  } catch (error) {
    console.error('‚ùå Error creating Firecrawl data popup:', error);
  }
}

// Function to fetch live price from Lotus product URL
async function fetchLivePrice(productUrl) {
  try {
    console.log(`üåê Fetching live price from: ${productUrl}`);
    
    // Use CORS proxy to bypass CORS restrictions
    const corsProxy = 'https://api.allorigins.win/raw?url=';
    const proxyUrl = corsProxy + encodeURIComponent(productUrl);
    
    console.log(`üîó Using CORS proxy: ${proxyUrl}`);
    
    const response = await fetch(proxyUrl, {
      method: 'GET',
      headers: {
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const html = await response.text();
    console.log(`üìÑ HTML received, length: ${html.length}`);
    
    // Debug: Log a sample of the HTML to see the structure
    const htmlSample = html.substring(0, 1000);
    console.log(`üîç HTML sample:`, htmlSample);
    
    // Debug: Look for any "RM" text in the HTML
    const rmMatches = html.match(/RM/gi);
    console.log(`üîç Found ${rmMatches ? rmMatches.length : 0} "RM" text occurrences in HTML`);
    
    // Debug: Look for any span tags
    const spanMatches = html.match(/<span[^>]*>/gi);
    console.log(`üîç Found ${spanMatches ? spanMatches.length : 0} span tags in HTML`);
    
    // Debug: Look for any price-related text
    const priceTextMatches = html.match(/\d+\.?\d*/gi);
    console.log(`üîç Found ${priceTextMatches ? priceTextMatches.length : 0} number patterns in HTML`);
    
    // Debug: Show a larger sample of HTML to see more structure
    const largerSample = html.substring(0, 3000);
    console.log(`üîç Larger HTML sample:`, largerSample);
    
    // Use robust, class-agnostic price extraction by anchoring on "RM" text
    console.log(`üîç Using robust price extraction method...`);
    
    // Find all "RM" spans in the HTML and extract prices from their parent containers
    const rmSpanMatches = [...html.matchAll(/<span[^>]*>RM<\/span>/gi)];
    console.log(`üîç Found ${rmSpanMatches.length} "RM" spans in HTML`);
    
    for (const match of rmSpanMatches) {
      const rmSpanHtml = match[0];
      const matchIndex = match.index;
      
      // Get the parent container content by looking for the closing tag after the RM span
      const afterRmSpan = html.substring(matchIndex + rmSpanHtml.length);
      
      // Look for the complete price pattern: RM + number + optional /unit
      const priceMatch = afterRmSpan.match(/^([^<]*?)(?:<|$)/);
      if (priceMatch) {
        const rawPriceText = priceMatch[1].replace(/\u00A0/g, ' ').trim();
        console.log(`üîç Raw price text after RM: "${rawPriceText}"`);
        
        // Parse: currency, amount, optional "/unit"
        const pricePattern = /^([A-Z]{1,4})\s*([\d.,]+)\s*(?:\/\s*([A-Za-z0-9.\-% ]+))?$/;
        const parsed = rawPriceText.match(pricePattern);
        
        if (parsed) {
          const amount = parseFloat(parsed[2].replace(/,/g, ''));
          console.log(`üí∞ Found robust price: ${parsed[1]} ${amount} ${parsed[3] || ''}`);
          return amount;
        }
      }
    }
    
    // Fallback: Look for any price-like patterns in the HTML
    console.log(`üîç Trying fallback price patterns...`);
    
    // Parse price from HTML - look for common price patterns
    const pricePatterns = [
      // Nested MuiBox structure from inspect element
      /<div[^>]*class="[^"]*MuiBox-root[^"]*"[^>]*>[\s]*<div[^>]*class="[^"]*MuiBox-root[^"]*"[^>]*>[\s]*<div[^>]*class="[^"]*MuiBox-root[^"]*"[^>]*>[\s]*<div[^>]*class="[^"]*MuiBox-root[^"]*"[^>]*>[\s]*<span[^>]*>RM<\/span>([\d,]+\.?\d*)/i,
      // Lotus-specific Material-UI patterns (from your exact example)
      /<span[^>]*class="[^"]*jss557[^"]*"[^>]*>RM<\/span>([\d,]+\.?\d*)/i,
      /<div[^>]*class="[^"]*MuiBox-root[^"]*"[^>]*>[\s]*<span[^>]*>RM<\/span>([\d,]+\.?\d*)/i,
      /<span[^>]*>RM<\/span>([\d,]+\.?\d*)/i,
      /MuiBox-root[^>]*>[\s]*<span[^>]*>RM<\/span>([\d,]+\.?\d*)/i,
      // Lotus-specific patterns
      /class="[^"]*price[^"]*"[^>]*>[\s]*RM\s*([\d,]+\.?\d*)/i,
      /data-price="([\d,]+\.?\d*)"/i,
      /"price":\s*"([\d,]+\.?\d*)"/i,
      /"currentPrice":\s*"([\d,]+\.?\d*)"/i,
      /"sellingPrice":\s*"([\d,]+\.?\d*)"/i,
      // General patterns
      /price[^>]*>[\s]*RM\s*([\d,]+\.?\d*)/i,
      /RM\s*([\d,]+\.?\d*)/i,
      /MYR\s*([\d,]+\.?\d*)/i,
      /price[^>]*>[\s]*\$?\s*([\d,]+\.?\d*)/i,
      // Look for any number that could be a price
      /[\d,]+\.?\d*\s*(?:RM|MYR|\$)/i,
      // Fallback: Look for any decimal numbers that could be prices
      /(\d{1,3}(?:,\d{3})*\.\d{2})/g,
      /(\d+\.\d{2})/g
    ];
    
    for (const pattern of pricePatterns) {
      const match = html.match(pattern);
      if (match) {
        const price = parseFloat(match[1].replace(/,/g, ''));
        console.log(`üí∞ Found price: RM ${price}`);
        return price;
      }
    }
    
    console.log(`‚ùå No price found in HTML`);
    return null;
    
  } catch (error) {
    console.error(`‚ùå Error fetching live price:`, error);
    return null;
  }
}

// Function to fetch and update price for a specific product
async function fetchAndUpdatePrice(productId, productUrl) {
  try {
    console.log(`üîÑ Fetching live price for product ${productId} from: ${productUrl}`);
    
    // Find the product in allProducts
    const product = allProducts.find(p => p.id === productId);
    if (!product) {
      console.log(`‚ùå Product ${productId} not found`);
      return;
    }
    
    // Show loading indicator
    const productElement = document.querySelector(`[data-product-id="${productId}"]`);
    if (productElement) {
      const priceElement = productElement.querySelector('.price');
      if (priceElement) {
        priceElement.innerHTML = '<span style="color: #ff6b35;">üîÑ Loading...</span>';
      }
    }
    
    // Fetch live price
    const livePrice = await fetchLivePrice(productUrl);
    
    if (livePrice && livePrice > 0) {
      // Update the product data
      if (product.offers && product.offers.length > 0) {
        product.offers[0].price = livePrice;
        product.offers[0].original_price = product.offers[0].original_price || livePrice;
      }
      
      // Update aggregate prices
      product.aggregate.lowPrice = livePrice;
      product.aggregate.highPrice = livePrice;
      
      console.log(`‚úÖ Updated ${product.title}: RM ${livePrice}`);
      
      // Re-render the grid to show updated price
      render();
      
      // Show success message
      if (productElement) {
        const priceElement = productElement.querySelector('.price');
        if (priceElement) {
          priceElement.innerHTML = money(livePrice, 'MYR') + ' <span style="color: #28a745; font-size: 0.8em;">‚úì</span>';
          setTimeout(() => {
            priceElement.innerHTML = money(livePrice, 'MYR');
          }, 2000);
        }
      }
    } else {
      console.log(`‚ùå Could not fetch price for ${product.title}`);
      
      // Show error message
      if (productElement) {
        const priceElement = productElement.querySelector('.price');
        if (priceElement) {
          priceElement.innerHTML = '<span style="color: #dc3545;">‚ùå Price unavailable</span>';
          setTimeout(() => {
            priceElement.innerHTML = money(product.offers[0].price || 0, 'MYR');
          }, 3000);
        }
      }
    }
    
  } catch (error) {
    console.error(`‚ùå Error updating price for product ${productId}:`, error);
  }
}

// Function to automatically fetch prices for products with price = 0
async function autoFetchZeroPrices(products) {
  console.log(`üîÑ Auto-fetching prices for products with price = 0...`);
  
  const zeroPriceProducts = products.filter(p => 
    p.offers && p.offers.length > 0 && 
    p.offers[0].price === 0 && 
    p.offers[0].url && 
    p.offers[0].url !== '#'
  );
  
  console.log(`Found ${zeroPriceProducts.length} products with price = 0 to update`);
  
  if (zeroPriceProducts.length === 0) {
    console.log(`‚úÖ No products with price = 0 found`);
    return;
  }
  
  // Show status message
  const statusElement = document.getElementById('firecrawlDataStatus');
  if (statusElement) {
    statusElement.textContent = `üîÑ Auto-fetching prices for ${zeroPriceProducts.length} products...`;
  }
  
  let updatedCount = 0;
  
  for (const product of zeroPriceProducts) {
    try {
      console.log(`üîÑ Auto-fetching price for: ${product.title}`);
      
      const offer = product.offers[0];
      const livePrice = await fetchLivePrice(offer.url);
      
      if (livePrice && livePrice > 0) {
        // Update the offer price
        offer.price = livePrice;
        offer.original_price = offer.original_price || livePrice;
        
        // Update the aggregate price
        product.aggregate.lowPrice = livePrice;
        product.aggregate.highPrice = livePrice;
        
        updatedCount++;
        console.log(`‚úÖ Auto-updated ${product.title}: RM ${livePrice}`);
        
        // Update status
        if (statusElement) {
          statusElement.textContent = `‚úÖ Updated ${updatedCount}/${zeroPriceProducts.length} products`;
        }
        
        // Re-render the grid to show updated price
        render();
        
      } else {
        console.log(`‚ùå Could not auto-fetch price for ${product.title}`);
      }
      
      // Add a delay to avoid overwhelming the server
      await new Promise(resolve => setTimeout(resolve, 1500));
      
    } catch (error) {
      console.error(`‚ùå Error auto-fetching price for ${product.title}:`, error);
    }
  }
  
  // Final status update
  if (statusElement) {
    statusElement.textContent = `‚úÖ Auto-fetch complete: ${updatedCount}/${zeroPriceProducts.length} prices updated`;
  }
  
  console.log(`‚úÖ Auto-fetch complete: ${updatedCount}/${zeroPriceProducts.length} prices updated`);
}

// Function to update all Firecrawl products with live prices
async function updateFirecrawlProductsWithLivePrices() {
  console.log(`üîÑ Updating Firecrawl products with live prices...`);
  
  const firecrawlProducts = allProducts.filter(p => p.id && p.id.includes('lotus-'));
  console.log(`Found ${firecrawlProducts.length} Firecrawl products to update`);
  
  for (const product of firecrawlProducts) {
    if (product.offers && product.offers.length > 0) {
      const offer = product.offers[0];
      if (offer.url && offer.url !== '#') {
        console.log(`Updating price for: ${product.title}`);
        const livePrice = await fetchLivePrice(offer.url);
        
        if (livePrice && livePrice > 0) {
          // Update the offer price
          offer.price = livePrice;
          offer.original_price = offer.original_price || livePrice;
          
          // Update the aggregate price
          product.aggregate.lowPrice = livePrice;
          product.aggregate.highPrice = livePrice;
          
          console.log(`‚úÖ Updated ${product.title}: RM ${livePrice}`);
        } else {
          console.log(`‚ùå Could not fetch price for ${product.title}`);
        }
        
        // Add a small delay to avoid overwhelming the server
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }
  
  // Re-render the grid with updated prices
  render();
  console.log(`‚úÖ Live price update complete`);
}

// Function to automatically fetch price using Firecrawl when product has price = 0
async function autoFetchPriceWithFirecrawl(product) {
  console.log(`üî• Firecrawl: Auto-fetching price for zero-price product: ${product.title}`);
  
  // Get the product URL
  let productUrl = null;
  if (product.firecrawl_data && product.firecrawl_data.product_url) {
    productUrl = product.firecrawl_data.product_url;
  } else if (product.offers && product.offers.length > 0 && product.offers[0].url) {
    productUrl = product.offers[0].url;
  } else if (product.id && product.id.startsWith('lotus-')) {
    const productId = product.id.replace('lotus-', '');
    productUrl = `https://www.lotuss.com.my/en/product/${productId}`;
  }
  
  if (productUrl) {
    console.log(`üîó Firecrawl: Using product URL: ${productUrl}`);
    try {
      // Call our Python Firecrawl script via a simple API endpoint
      const response = await fetch('http://localhost:5000/api/firecrawl-scrape', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ url: productUrl })
      });
      
      if (response.ok) {
        const scrapedData = await response.json();
        console.log(`‚úÖ Firecrawl: Successfully scraped data for ${product.title}:`, scrapedData);
        
        // Update the product with fresh data
        if (scrapedData.price && scrapedData.price !== 'Price not found') {
          const priceMatch = scrapedData.price.match(/RM\s*([\d,]+\.?\d*)/);
          if (priceMatch) {
            const newPrice = parseFloat(priceMatch[1].replace(',', ''));
            
            // Update the product's price
            if (product.offers && product.offers.length > 0) {
              product.offers[0].price = newPrice;
            }
            
            // Update the display
            const priceElement = document.querySelector(`[data-product-id="${product.id}"] .price`);
            if (priceElement) {
              priceElement.textContent = `RM ${newPrice.toFixed(2)}`;
              priceElement.style.color = '#28a745'; // Green color to indicate updated
            }
            
            console.log(`‚úÖ Firecrawl: Updated price for ${product.title} to RM ${newPrice}`);
          }
        }
        
        // Also update other fields if available
        if (scrapedData.brand && scrapedData.brand !== 'Unknown') {
          product.brand = scrapedData.brand;
        }
        if (scrapedData.category && scrapedData.category !== 'Unknown') {
          product.category_path = scrapedData.category;
        }
        if (scrapedData.image_url) {
          product.image_url = scrapedData.image_url;
        }
        
      } else {
        if (response.status === 501) {
          console.log(`‚ö†Ô∏è Firecrawl: API endpoint not available (501) - Firecrawl server may not be running on port 5000`);
        } else if (response.status === 404) {
          console.log(`‚ö†Ô∏è Firecrawl: API endpoint not found (404) - Check if Firecrawl server is running`);
        } else {
          console.log(`‚ùå Firecrawl: Failed to scrape ${productUrl}: ${response.status} ${response.statusText}`);
        }
        // Continue processing even if Firecrawl fails
        console.log(`üîÑ Continuing with existing product data for ${product.title}`);
      }
    } catch (error) {
      if (error.name === 'TypeError' && error.message.includes('fetch')) {
        console.log(`‚ö†Ô∏è Firecrawl: Network error - Firecrawl server may not be running on port 5000`);
      } else {
        console.log(`‚ùå Firecrawl: Error scraping ${productUrl}:`, error);
      }
      // Continue processing even if Firecrawl fails
      console.log(`üîÑ Continuing with existing product data for ${product.title}`);
    }
  } else {
    console.log(`‚ö†Ô∏è Firecrawl: No product URL found for ${product.title}`);
  }
}

// Function to automatically fetch price when product has price = 0 (legacy method)
async function autoFetchPriceIfZero(product) {
  // Check if product has price = 0 and has a product_url
  if (product.offers && product.offers.length > 0) {
    const offer = product.offers[0];
    if (offer.price === 0) {
      // Try to get URL from different sources
      let productUrl = null;
      
      // First try the offer URL
      if (offer.url && offer.url !== '#') {
        productUrl = offer.url;
      }
      // If not available, try to get from raw Firecrawl data
      else if (product.firecrawl_data && product.firecrawl_data.product_url) {
        productUrl = product.firecrawl_data.product_url;
      }
      // If still not available, construct URL from product ID
      else if (product.id && product.id.includes('lotus-')) {
        const productId = product.id.replace('lotus-', '');
        productUrl = `https://www.lotuss.com.my/en/product/${productId}`;
      }
      
      if (productUrl) {
        console.log(`üîÑ Auto-fetching price for zero-price product: ${product.title}`);
        console.log(`üîó Using product URL: ${productUrl}`);
        
        try {
          const livePrice = await fetchLivePrice(productUrl);
          
          // Also fetch the HTML content to display inline
          await loadHTMLContentInline(product.id, productUrl);
          
          if (livePrice && livePrice > 0) {
            // Update the offer price
            offer.price = livePrice;
            offer.original_price = offer.original_price || livePrice;
            
            // Update the aggregate price
            product.aggregate.lowPrice = livePrice;
            product.aggregate.highPrice = livePrice;
            
            console.log(`‚úÖ Auto-updated zero-price product ${product.title}: RM ${livePrice}`);
            
            // Re-render the grid to show updated price
            render();
            
            return true; // Successfully updated
          } else {
            console.log(`‚ùå Could not fetch price for zero-price product: ${product.title}`);
          }
        } catch (error) {
          console.error(`‚ùå Error fetching price for zero-price product ${product.title}:`, error);
        }
      } else {
        console.log(`‚ùå No product URL available for zero-price product: ${product.title}`);
      }
    }
  }
  return false; // No update needed or failed
}

// Test function to debug price fetching
async function testFetchPrice(productId) {
  console.log(`üß™ TEST: Fetching price for product ${productId}`);
  
  const product = allProducts.find(p => p.id === productId);
  if (!product) {
    console.log(`‚ùå Product ${productId} not found`);
    return;
  }
  
  console.log(`üß™ Product found:`, product);
  console.log(`üß™ Product offers:`, product.offers);
  console.log(`üß™ Firecrawl data:`, product.firecrawl_data);
  
  // Try different URL sources
  let testUrl = null;
  
  if (product.offers && product.offers[0] && product.offers[0].url && product.offers[0].url !== '#') {
    testUrl = product.offers[0].url;
    console.log(`üß™ Using offer URL: ${testUrl}`);
  } else if (product.firecrawl_data && product.firecrawl_data.product_url) {
    testUrl = product.firecrawl_data.product_url;
    console.log(`üß™ Using firecrawl product_url: ${testUrl}`);
  } else if (product.id && product.id.includes('lotus-')) {
    const productId = product.id.replace('lotus-', '');
    testUrl = `https://www.lotuss.com.my/en/product/${productId}`;
    console.log(`üß™ Constructed URL: ${testUrl}`);
  }
  
  if (testUrl) {
    console.log(`üß™ Testing price fetch from: ${testUrl}`);
    try {
      const price = await fetchLivePrice(testUrl);
      console.log(`üß™ TEST RESULT: Price = ${price}`);
      
      if (price && price > 0) {
        alert(`‚úÖ TEST SUCCESS: Found price RM ${price} for ${product.title}`);
      } else {
        alert(`‚ùå TEST FAILED: Could not fetch price for ${product.title}`);
      }
    } catch (error) {
      console.error(`üß™ TEST ERROR:`, error);
      alert(`‚ùå TEST ERROR: ${error.message}`);
    }
  } else {
    console.log(`‚ùå No URL available for testing`);
    alert(`‚ùå No URL available for testing`);
  }
}

// Function to load HTML content inline for zero-price products
async function loadHTMLContentInline(productId, productUrl) {
  console.log(`üìÑ Loading HTML content inline for product: ${productId}`);
  
  try {
    const corsProxy = 'https://api.allorigins.win/raw?url=';
    const proxyUrl = corsProxy + encodeURIComponent(productUrl);
    
    const response = await fetch(proxyUrl, {
      method: 'GET',
      headers: {
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const html = await response.text();
    console.log(`üìÑ HTML received for inline display, length: ${html.length}`);
    
    // Find the inline container for this product
    const container = document.getElementById('html-content-' + productId);
    if (container) {
      // Extract key content from the HTML with improved patterns
      console.log('üîç Extracting content from HTML...');
      
      // Try multiple patterns for title
      const titleMatch = html.match(/<h1[^>]*class="[^"]*jss60[^"]*"[^>]*>([^<]+)<\/h1>/i) || 
                        html.match(/<h1[^>]*>([^<]+)<\/h1>/i) ||
                        html.match(/<title[^>]*>([^<]+)<\/title>/i);
      
      // Try multiple patterns for price - including JavaScript variables
      const priceMatch = html.match(/<span[^>]*class="[^"]*jss595[^"]*"[^>]*>RM<\/span>([\d,]+\.?\d*)/i) ||
                        html.match(/<span[^>]*>RM<\/span>([\d,]+\.?\d*)/i) ||
                        html.match(/RM\s*([\d,]+\.?\d*)/i) ||
                        html.match(/productPrice["\s]*:["\s]*([\d,]+\.?\d*)/i) ||
                        html.match(/value["\s]*:["\s]*([\d,]+\.?\d*)/i) ||
                        html.match(/price["\s]*:["\s]*([\d,]+\.?\d*)/i);
      
      // Debug: Log the HTML sample to see what we're working with
      console.log('üîç HTML sample for price extraction:', html.substring(0, 2000));
      
      // Try multiple patterns for brand - including JavaScript variables
      const brandMatch = html.match(/<h2[^>]*class="[^"]*jss64[^"]*"[^>]*>Brand:\s*([^<]+)<\/h2>/i) ||
                        html.match(/Brand:\s*([^<\n]+)/i) ||
                        html.match(/<h2[^>]*>Brand:\s*([^<]+)<\/h2>/i) ||
                        html.match(/<a[^>]*href="[^"]*brand[^"]*"[^>]*>Brand:\s*([^<]+)<\/a>/i) ||
                        html.match(/productName["\s]*:["\s]*["']([^"']+)["']/i) ||
                        html.match(/brand["\s]*:["\s]*["']([^"']+)["']/i);
      
      // Debug: Log brand extraction
      console.log('üîç Brand match result:', brandMatch);
      
      // Try multiple patterns for category - including JavaScript variables
      const categoryMatch = html.match(/<h2[^>]*class="[^"]*jss64[^"]*"[^>]*>Category:\s*([^<]+)<\/h2>/i) ||
                           html.match(/Category:\s*([^<\n]+)/i) ||
                           html.match(/<h2[^>]*>Category:\s*([^<]+)<\/h2>/i) ||
                           html.match(/<a[^>]*href="[^"]*category[^"]*"[^>]*>Category:\s*([^<]+)<\/a>/i) ||
                           html.match(/productCategory["\s]*:["\s]*["']([^"']+)["']/i) ||
                           html.match(/category["\s]*:["\s]*["']([^"']+)["']/i);
      
      // Debug: Log category extraction
      console.log('üîç Category match result:', categoryMatch);
      
      // Try multiple patterns for image
      const imageMatch = html.match(/<img[^>]*id="current-product-image"[^>]*src="([^"]*)"[^>]*>/i) ||
                        html.match(/<img[^>]*src="([^"]*)"[^>]*alt="[^"]*"[^>]*>/i);
      
      // Try multiple patterns for description - avoid JavaScript code
      const descriptionMatch = html.match(/<div[^>]*class="[^"]*sc-eoHXOn[^"]*"[^>]*>([^<]+(?:<br[^>]*>)*[^<]*)<\/div>/i) ||
                              html.match(/<div[^>]*class="[^"]*jss706[^"]*"[^>]*>([^<]+(?:<br[^>]*>)*[^<]*)<\/div>/i) ||
                              html.match(/<div[^>]*class="[^"]*jss705[^"]*"[^>]*>([^<]+(?:<br[^>]*>)*[^<]*)<\/div>/i) ||
                              html.match(/<div[^>]*class="[^"]*jss704[^"]*"[^>]*>([^<]+(?:<br[^>]*>)*[^<]*)<\/div>/i) ||
                              html.match(/<div[^>]*class="[^"]*sc-eoHXOn[^"]*[^>]*>([^<]+(?:<br[^>]*>)*[^<]*)<\/div>/i);
      
      // Clean up description to remove JavaScript code
      let cleanDescription = descriptionMatch ? descriptionMatch[1].replace(/<br[^>]*>/g, '\n').trim() : 'Description not found';
      if (cleanDescription.includes('_satellite') || cleanDescription.includes('fbq') || cleanDescription.includes('function')) {
        cleanDescription = 'Description not found (JavaScript content detected)';
      }
      
      const title = titleMatch ? titleMatch[1].trim() : 'Product Title';
      const price = priceMatch ? 'RM ' + priceMatch[1] : 'Price not found';
      const brand = brandMatch ? brandMatch[1].trim() : 'Brand not found';
      const category = categoryMatch ? categoryMatch[1].trim() : 'Category not found';
      const imageUrl = imageMatch ? imageMatch[1] : null;
      const description = cleanDescription;
      
      console.log('üîç Extraction results:', { title, price, brand, category, imageUrl: !!imageUrl, description: description.substring(0, 50) + '...' });
      
      // Check if we got any useful data
      const hasUsefulData = title !== 'Product Title' || price !== 'Price not found' || brand !== 'Brand not found';
      
      if (hasUsefulData) {
        container.innerHTML = `
          <div style="color: #28a745; margin-bottom: 10px; font-weight: bold;">‚úÖ Page Content Extracted (${html.length} chars)</div>
          <div style="color: #666; margin-bottom: 10px; font-size: 9px;">Source: ${productUrl}</div>
          <div style="background: white; padding: 15px; border-radius: 5px; border: 1px solid #e0e0e0;">
            ${imageUrl ? `<img src="${imageUrl}" style="max-width: 100%; height: auto; margin-bottom: 10px; border-radius: 3px;" alt="${title}">` : ''}
            <h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">${title}</h3>
            <div style="margin-bottom: 8px;">
              <strong style="color: #ff6b35; font-size: 18px;">${price}</strong>
            </div>
            <div style="margin-bottom: 5px; font-size: 12px; color: #666;">
              <strong>Brand:</strong> ${brand}
            </div>
            <div style="margin-bottom: 5px; font-size: 12px; color: #666;">
              <strong>Category:</strong> ${category}
            </div>
            <div style="margin-top: 10px; font-size: 11px; color: #555; line-height: 1.4; max-height: 100px; overflow-y: auto;">
              <strong>Description:</strong><br>
              ${description}
            </div>
          </div>
        `;
      } else {
        // Show raw HTML sample if extraction failed
        const htmlSample = html.substring(0, 1500);
        container.innerHTML = `
          <div style="color: #ff6b35; margin-bottom: 10px; font-weight: bold;">‚ö†Ô∏è Content Extraction Failed - Showing Raw HTML (${html.length} chars)</div>
          <div style="color: #666; margin-bottom: 10px; font-size: 9px;">Source: ${productUrl}</div>
          <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; border: 1px solid #ddd; font-family: monospace; font-size: 10px; line-height: 1.2; max-height: 200px; overflow-y: auto; white-space: pre-wrap;">
${htmlSample}${html.length > 1500 ? '...' : ''}
          </div>
        `;
      }
      console.log(`‚úÖ HTML content extracted and displayed for product: ${productId}`);
    } else {
      console.log(`‚ùå Inline container not found for product: ${productId}`);
    }
    
  } catch (error) {
    console.error(`‚ùå Error loading HTML content inline for product ${productId}:`, error);
    
    // Show error in the container
    const container = document.getElementById('html-content-' + productId);
    if (container) {
      container.innerHTML = `
        <div style="color: #dc3545; margin-bottom: 5px; font-weight: bold;">‚ùå Error loading HTML</div>
        <div style="color: #666; font-size: 9px;">${error.message}</div>
      `;
    }
  }
}

// Function to scrape TOBLERONE product specifically
async function scrapeTobleroneProduct() {
  console.log(`üç´ Scraping TOBLERONE product specifically...`);
  
  const tobleroneUrl = 'https://www.lotuss.com.my/en/product/504564';
  
  try {
    console.log(`üåê Fetching TOBLERONE HTML from: ${tobleroneUrl}`);
    const corsProxy = 'https://api.allorigins.win/raw?url=';
    const proxyUrl = corsProxy + encodeURIComponent(tobleroneUrl);
    
    const response = await fetch(proxyUrl, {
      method: 'GET',
      headers: {
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const html = await response.text();
    console.log(`üìÑ TOBLERONE HTML received, length: ${html.length}`);
    
    // Look for the specific price structure you provided
    const pricePatterns = [
      // Your specific structure: <span class="jss595">RM</span>17.95<span class="jss598">/Each</span>
      /<span[^>]*class="[^"]*jss595[^"]*"[^>]*>RM<\/span>([\d,]+\.?\d*)<span[^>]*class="[^"]*jss598[^"]*"[^>]*>\/Each<\/span>/i,
      // More flexible patterns for the same structure
      /<span[^>]*class="[^"]*jss595[^"]*"[^>]*>RM<\/span>([\d,]+\.?\d*)/i,
      /<span[^>]*>RM<\/span>([\d,]+\.?\d*)/i,
      // General price patterns
      /RM\s*([\d,]+\.?\d*)/i
    ];
    
    let foundPrice = null;
    for (const pattern of pricePatterns) {
      const match = html.match(pattern);
      if (match) {
        foundPrice = parseFloat(match[1].replace(/,/g, ''));
        console.log(`üí∞ Found TOBLERONE price with pattern: RM ${foundPrice}`);
        break;
      }
    }
    
    // Create popup to show the scraping results
    const popupContent = `
      <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; height: 70%; background: white; border: 2px solid #ff6b35; border-radius: 10px; z-index: 10000; box-shadow: 0 4px 20px rgba(0,0,0,0.3); display: flex; flex-direction: column;">
        <div style="background: #ff6b35; color: white; padding: 15px; border-radius: 8px 8px 0 0; flex-shrink: 0;">
          <h3 style="margin: 0; display: inline-block;">üç´ TOBLERONE Product Scraping Results</h3>
          <button onclick="this.closest('div').parentElement.remove()" style="float: right; padding: 8px 16px; background: white; color: #ff6b35; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">Close</button>
          <p style="margin: 5px 0 0 0; font-size: 12px;">
            <strong>URL:</strong> <a href="${tobleroneUrl}" target="_blank" style="color: white;">${tobleroneUrl}</a> | 
            <strong>HTML Length:</strong> ${html.length} characters | 
            <strong>Price Found:</strong> ${foundPrice ? 'RM ' + foundPrice : 'Not found'}
          </p>
        </div>
        <div style="flex: 1; overflow: auto; padding: 20px; font-family: monospace; font-size: 11px; line-height: 1.3; white-space: pre-wrap; background: #f8f9fa;">
          <h4>üîç Price Extraction Results:</h4>
          ${foundPrice ? 
            `<div style="background: #d4edda; padding: 10px; border-radius: 5px; margin: 10px 0;">
              ‚úÖ SUCCESS: Found price RM ${foundPrice}
            </div>` : 
            `<div style="background: #f8d7da; padding: 10px; border-radius: 5px; margin: 10px 0;">
              ‚ùå FAILED: No price found in HTML
            </div>`
          }
          
          <h4>üìÑ HTML Sample (first 3000 chars):</h4>
          <div style="background: #e9ecef; padding: 10px; border-radius: 5px; margin: 10px 0;">
${html.substring(0, 3000)}
          </div>
          
          <h4>üîç Price-Related HTML Sections:</h4>
          <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
            ${html.match(/<span[^>]*>RM<\/span>[\d,]+\.?\d*[^<]*/gi) ? 
              html.match(/<span[^>]*>RM<\/span>[\d,]+\.?\d*[^<]*/gi).map(match => `<div>${match}</div>`).join('') :
              'No RM price patterns found'
            }
          </div>
        </div>
      </div>
      <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999;" onclick="this.remove(); this.nextElementSibling.remove();"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', popupContent);
    
    return foundPrice;
    
  } catch (error) {
    console.error('‚ùå Error scraping TOBLERONE product:', error);
    alert(`Error scraping TOBLERONE product: ${error.message}`);
    return null;
  }
}

// Function to show the full product page HTML for zero-price products
async function showProductPageHTML(productId) {
  console.log(`üìÑ Showing product page HTML for: ${productId}`);
  
  const product = allProducts.find(p => p.id === productId);
  if (!product) {
    alert(`Product not found: ${productId}`);
    return;
  }
  
  // Get the product URL
  let productUrl = null;
  if (product.offers && product.offers.length > 0 && product.offers[0].url && product.offers[0].url !== '#') {
    productUrl = product.offers[0].url;
  } else if (product.firecrawl_data && product.firecrawl_data.product_url) {
    productUrl = product.firecrawl_data.product_url;
  } else if (product.id && product.id.includes('lotus-')) {
    const productId = product.id.replace('lotus-', '');
    productUrl = `https://www.lotuss.com.my/en/product/${productId}`;
  }
  
  if (!productUrl) {
    alert(`No URL found for product ${productId}`);
    return;
  }
  
  try {
    console.log(`üåê Fetching full HTML from: ${productUrl}`);
    const corsProxy = 'https://api.allorigins.win/raw?url=';
    const proxyUrl = corsProxy + encodeURIComponent(productUrl);
    
    const response = await fetch(proxyUrl, {
      method: 'GET',
      headers: {
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const html = await response.text();
    console.log(`üìÑ HTML received, length: ${html.length}`);
    
    // Create a smaller overlay with HTML content
    const popupContent = `
      <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; height: 80%; background: white; border: 2px solid #ff6b35; border-radius: 10px; z-index: 10000; box-shadow: 0 4px 20px rgba(0,0,0,0.3); display: flex; flex-direction: column;">
        <div style="background: #ff6b35; color: white; padding: 15px; border-radius: 8px 8px 0 0; flex-shrink: 0;">
          <h3 style="margin: 0; display: inline-block;">üìÑ Product Page HTML - ${product.title}</h3>
          <button onclick="this.closest('div').parentElement.remove()" style="float: right; padding: 8px 16px; background: white; color: #ff6b35; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">Close</button>
          <p style="margin: 5px 0 0 0; font-size: 12px;">
            <strong>URL:</strong> <a href="${productUrl}" target="_blank" style="color: white;">${productUrl}</a> | 
            <strong>HTML Length:</strong> ${html.length} characters
          </p>
        </div>
        <div style="flex: 1; overflow: auto; padding: 20px; font-family: monospace; font-size: 11px; line-height: 1.3; white-space: pre-wrap; background: #f8f9fa;">
${html}
        </div>
      </div>
      <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999;" onclick="this.remove(); this.nextElementSibling.remove();"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', popupContent);
    
  } catch (error) {
    console.error('‚ùå Error fetching product page HTML:', error);
    alert(`Error fetching product page HTML: ${error.message}`);
  }
}

// Debug function to show price HTML structure in popup
async function showPriceDebugPopup(productId) {
  console.log(`üí∞ DEBUG: Button clicked! Showing price debug popup for product ${productId}`);
  alert(`üí∞ DEBUG: Button clicked for product ${productId}`);
  
  const product = allProducts.find(p => p.id === productId);
  if (!product) {
    alert(`Product not found: ${productId}`);
    return;
  }
  
  // Get the product URL
  let productUrl = null;
  if (product.offers && product.offers.length > 0 && product.offers[0].url && product.offers[0].url !== '#') {
    productUrl = product.offers[0].url;
  } else if (product.firecrawl_data && product.firecrawl_data.product_url) {
    productUrl = product.firecrawl_data.product_url;
  } else if (product.id && product.id.includes('lotus-')) {
    const productId = product.id.replace('lotus-', '');
    productUrl = `https://www.lotuss.com.my/en/product/${productId}`;
  }
  
  if (!productUrl) {
    alert(`No URL found for product ${productId}`);
    return;
  }
  
  try {
    console.log(`üåê Fetching HTML from: ${productUrl}`);
    const corsProxy = 'https://api.allorigins.win/raw?url=';
    const proxyUrl = corsProxy + encodeURIComponent(productUrl);
    
    const response = await fetch(proxyUrl, {
      method: 'GET',
      headers: {
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const html = await response.text();
    console.log(`üìÑ HTML received, length: ${html.length}`);
    
    // Use robust, class-agnostic price extraction for debug popup
    let foundPrices = [];
    
    // Find all "RM" spans and extract prices
    const rmSpanMatches = [...html.matchAll(/<span[^>]*>RM<\/span>/gi)];
    console.log(`üîç Debug: Found ${rmSpanMatches.length} "RM" spans in HTML`);
    
    for (const match of rmSpanMatches) {
      const rmSpanHtml = match[0];
      const matchIndex = match.index;
      
      // Get the parent container content
      const afterRmSpan = html.substring(matchIndex + rmSpanHtml.length);
      const priceMatch = afterRmSpan.match(/^([^<]*?)(?:<|$)/);
      
      if (priceMatch) {
        const rawPriceText = priceMatch[1].replace(/\u00A0/g, ' ').trim();
        const pricePattern = /^([A-Z]{1,4})\s*([\d.,]+)\s*(?:\/\s*([A-Za-z0-9.\-% ]+))?$/;
        const parsed = rawPriceText.match(pricePattern);
        
        if (parsed) {
          const amount = parseFloat(parsed[2].replace(/,/g, ''));
          foundPrices.push({
            method: 'Robust RM-based extraction',
            rawText: rawPriceText,
            currency: parsed[1],
            amount: amount,
            unit: parsed[3] || null,
            fullMatch: rmSpanHtml + rawPriceText
          });
        }
      }
    }
    
    // Also try legacy patterns for comparison
    const legacyPatterns = [
      /<div[^>]*class="[^"]*MuiBox-root[^"]*"[^>]*>[\s]*<span[^>]*>RM<\/span>([\d,]+\.?\d*)/gi,
      /<span[^>]*>RM<\/span>([\d,]+\.?\d*)/gi,
      /RM\s*([\d,]+\.?\d*)/gi
    ];
    
    for (const pattern of legacyPatterns) {
      const matches = [...html.matchAll(pattern)];
      matches.forEach(match => {
        foundPrices.push({
          method: 'Legacy pattern',
          pattern: pattern.toString(),
          match: match[0],
          price: match[1]
        });
      });
    }
    
    // Create popup content
    const popupContent = `
      <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 2px solid #ff6b35; border-radius: 10px; padding: 20px; max-width: 80%; max-height: 80%; overflow: auto; z-index: 10000; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
        <h3 style="margin: 0 0 15px 0; color: #ff6b35;">üí∞ Price Debug - ${product.title}</h3>
        <p><strong>Product ID:</strong> ${productId}</p>
        <p><strong>URL:</strong> <a href="${productUrl}" target="_blank">${productUrl}</a></p>
        <p><strong>Current Price in Data:</strong> RM ${product.offers[0].price}</p>
        
        <h4>üîç Found Price Patterns:</h4>
        ${foundPrices.length > 0 ? 
          foundPrices.map(p => `<div style="background: #f0f8ff; padding: 10px; margin: 5px 0; border-radius: 5px; font-family: monospace; font-size: 12px;">
            <strong>Method:</strong> ${p.method}<br>
            ${p.rawText ? `<strong>Raw Text:</strong> "${p.rawText}"<br>` : ''}
            ${p.currency ? `<strong>Currency:</strong> ${p.currency}<br>` : ''}
            ${p.amount ? `<strong>Amount:</strong> ${p.amount}<br>` : ''}
            ${p.unit ? `<strong>Unit:</strong> ${p.unit}<br>` : ''}
            ${p.pattern ? `<strong>Pattern:</strong> ${p.pattern}<br>` : ''}
            ${p.match ? `<strong>Match:</strong> ${p.match}<br>` : ''}
            ${p.price ? `<strong>Price:</strong> RM ${p.price}<br>` : ''}
            ${p.fullMatch ? `<strong>Full Match:</strong> ${p.fullMatch}<br>` : ''}
          </div>`).join('') :
          '<p style="color: red;">‚ùå No price patterns found in HTML</p>'
        }
        
        <h4>üìÑ HTML Sample (first 2000 chars):</h4>
        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 10px; white-space: pre-wrap; max-height: 300px; overflow: auto;">${html.substring(0, 2000)}</div>
        
        <div style="text-align: center; margin-top: 15px;">
          <button onclick="this.parentElement.parentElement.remove()" style="padding: 8px 16px; background: #ff6b35; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>
        </div>
      </div>
      <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999;" onclick="this.remove(); this.nextElementSibling.remove();"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', popupContent);
    
  } catch (error) {
    console.error('‚ùå Error fetching price debug info:', error);
    alert(`Error fetching price debug info: ${error.message}`);
  }
}

// Function to update the Firecrawl data tab
function updateFirecrawlDataTab(products) {
  const container = document.getElementById('firecrawlDataContainer');
  const status = document.getElementById('firecrawlDataStatus');
  
  if (!container) return;
  
  if (products && products.length > 0) {
    status.textContent = `‚úÖ Loaded ${products.length} products`;
    
    const html = `
      <div style="background: white; border: 1px solid #ddd; border-radius: 8px; padding: 20px;">
        <h3 style="margin: 0 0 15px 0; color: #ff6b35;">üî• Raw Firecrawl Data (${products.length} products)</h3>
        <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; overflow: auto; max-height: 600px; font-family: monospace; font-size: 12px; white-space: pre-wrap;">${JSON.stringify(products, null, 2)}</div>
      </div>
    `;
    container.innerHTML = html;
  } else {
    status.textContent = '‚ùå No data loaded';
    container.innerHTML = `
      <div style="text-align: center; padding: 40px; color: #666;">
        <div style="font-size: 18px; margin-bottom: 10px;">‚ùå No Firecrawl Data</div>
        <div style="font-size: 14px; color: #888;">No products were loaded from the Firecrawl data source</div>
      </div>
    `;
  }
}

// Tab switching functionality
function switchTab(tabName) {
  console.log('üîÑ Switching to tab:', tabName);
  
  // Hide all tab contents
  document.querySelectorAll('.tab-content').forEach(content => {
    content.classList.remove('active');
  });
  
  // Remove active class from all tabs
  document.querySelectorAll('.tab').forEach(tab => {
    tab.classList.remove('active');
  });
  
  // Show selected tab content
  const tabContent = document.getElementById(tabName + '-tab');
  console.log('üîç Looking for tab content element with ID:', tabName + '-tab');
  console.log('Tab content element found:', tabContent);
  if (tabContent) {
    tabContent.classList.add('active');
    console.log('‚úÖ Tab content activated:', tabContent.id);
  } else {
    console.error('‚ùå Tab content not found:', tabName + '-tab');
    // List all available tab content elements
    const allTabContents = document.querySelectorAll('.tab-content');
    console.log('Available tab content elements:');
    allTabContents.forEach(content => {
      console.log('  -', content.id);
    });
  }
  
  // Add active class to selected tab
  const tabButton = document.querySelector(`[data-tab="${tabName}"]`);
  console.log('Tab button element:', tabButton);
  if (tabButton) {
    tabButton.classList.add('active');
    console.log('Tab button activated');
  } else {
    console.error('Tab button not found:', `[data-tab="${tabName}"]`);
  }
  
  // Show/hide appropriate content sections
  if (tabName === 'search') {
    document.getElementById('grid').style.display = 'grid';
    document.getElementById('category-content').style.display = 'none';
  } else if (tabName === 'browse') {
    document.getElementById('grid').style.display = 'none';
    document.getElementById('category-content').style.display = 'block';
  } else if (tabName === 'live-categories') {
    document.getElementById('grid').style.display = 'none';
    document.getElementById('category-content').style.display = 'none';
  }
}

// Load live categories from Lotus website
async function loadLiveCategories() {
  console.log('loadLiveCategories function called');
  const container = document.getElementById('liveCategoriesContainer');
  const status = document.getElementById('liveCategoriesStatus');
  
  console.log('Container:', container);
  console.log('Status:', status);
  
  try {
    // Show loading state
    container.innerHTML = `
      <div style="text-align: center; padding: 40px; color: #666;">
        <div style="font-size: 18px; margin-bottom: 10px;">üîÑ Loading live categories...</div>
        <div style="font-size: 14px; color: #888;">Fetching real-time data from https://www.lotuss.com.my/en</div>
        <div style="margin-top: 20px;">
          <div style="display: inline-block; width: 20px; height: 20px; border: 2px solid #f3f3f3; border-top: 2px solid #28a745; border-radius: 50%; animation: spin 1s linear infinite;"></div>
        </div>
      </div>
    `;
    status.textContent = 'Loading...';
    
    // Fetch live categories with retry logic and fallback
    console.log('Making API call to localhost:5009/categories');
    let response;
    let retryCount = 0;
    const maxRetries = 2;
    
    while (retryCount < maxRetries) {
      try {
        response = await fetch('http://localhost:5009/categories', {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json'
          },
          mode: 'cors'
        });
        console.log('Response received:', response);
        break;
      } catch (error) {
        retryCount++;
        console.log(`Attempt ${retryCount} failed:`, error.message);
        if (retryCount < maxRetries) {
          console.log(`Retrying in 1 second... (${retryCount}/${maxRetries})`);
          await new Promise(resolve => setTimeout(resolve, 1000));
        } else {
          // Try fallback to simple scraper
          console.log('Trying fallback to simple scraper...');
          try {
            response = await fetch('http://localhost:5010/categories', {
              method: 'GET',
              headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
              },
              mode: 'cors'
            });
            console.log('Fallback response received:', response);
            break;
          } catch (fallbackError) {
            console.log('Fallback also failed:', fallbackError.message);
            throw error; // Throw original error
          }
        }
      }
    }
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const categoryData = await response.json();
    console.log('Data received:', categoryData);
    
    if (categoryData.success && categoryData.categories && categoryData.categories.length > 0) {
      // Display live categories
      let html = `
        <div style="background: #d4edda; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
          <h4 style="margin: 0 0 10px 0; color: #155724;">‚úÖ Live Categories Loaded Successfully!</h4>
          <p style="margin: 0; font-size: 14px; color: #155724;">
            Found <strong>${categoryData.categories.length}</strong> real categories from Lotus website
          </p>
          <p style="margin: 5px 0 0 0; font-size: 12px; color: #6c757d;">
            Source: ${categoryData.source} | Last updated: ${new Date().toLocaleTimeString()}
          </p>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
      `;
      
      categoryData.categories.forEach((category, index) => {
        const categoryType = category.type || 'unknown';
        const typeColor = categoryType === 'real_category' ? '#28a745' : (categoryType === 'nav_category' ? '#17a2b8' : '#6c757d');
        
        const hasSubcategories = category.has_subcategories || false;
        const isRealCategory = category.type === 'real_category';
        
        html += `
          <div class="live-category-card" style="border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; background: white; transition: all 0.3s ease;" 
               onmouseover="this.style.borderColor='#28a745'; this.style.boxShadow='0 2px 8px rgba(40,167,69,0.2)'"
               onmouseout="this.style.borderColor='#e0e0e0'; this.style.boxShadow='none'">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
              <h5 style="margin: 0; color: #333; font-size: 16px; line-height: 1.3;">${category.name}</h5>
              <span style="background: ${typeColor}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 10px; text-transform: uppercase;">
                ${categoryType.replace('_', ' ')}
              </span>
            </div>
            <p style="margin: 0; font-size: 12px; color: #666; word-break: break-all;">
              <strong>üîó URL:</strong> <a href="${category.url}" target="_blank" style="color: #4285f4; text-decoration: none;">${category.url}</a>
            </p>
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #f0f0f0;">
              ${isRealCategory ? `
                <div style="margin-bottom: 8px;">
                  <span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: bold;">üåê REAL DATA</span>
                </div>
              ` : ''}
              ${hasSubcategories ? `
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                  <button onclick="loadSubcategories('${category.name}')" style="padding: 6px 12px; border: 1px solid #17a2b8; border-radius: 4px; background: #17a2b8; color: white; cursor: pointer; font-size: 11px; font-weight: bold;">
                    üìÅ Browse Subcategories
                  </button>
                  <button onclick="searchLiveCategoryProducts('${category.name}')" style="padding: 6px 12px; border: 1px solid #28a745; border-radius: 4px; background: #28a745; color: white; cursor: pointer; font-size: 11px; font-weight: bold;">
                    üîç Search Real Products
                  </button>
                </div>
              ` : `
                <button onclick="searchLiveCategoryProducts('${category.name}')" style="padding: 8px 16px; border: 1px solid #28a745; border-radius: 4px; background: #28a745; color: white; cursor: pointer; font-size: 12px; font-weight: bold; width: 100%;">
                  üîç Search Real Products in this Category
                </button>
              `}
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
      status.textContent = `‚úÖ Loaded ${data.categories.length} live categories`;
      
    } else {
      throw new Error('No categories found in response');
    }
    
  } catch (error) {
    console.error('Error loading live categories:', error);
    console.log('Trying fallback to hierarchical scraper...');
    
    // Try multiple fallbacks
    const fallbackUrls = [
      { url: 'http://localhost:5010/categories', name: 'Simple Scraper' },
      { url: 'http://localhost:5008/categories', name: 'Hierarchical Scraper' }
    ];
    
    for (const fallback of fallbackUrls) {
      try {
        console.log(`Trying fallback to ${fallback.name}...`);
        const fallbackResponse = await fetch(fallback.url);
        if (fallbackResponse.ok) {
          const fallbackData = await fallbackResponse.json();
          if (fallbackData.success && fallbackData.categories && fallbackData.categories.length > 0) {
            console.log(`Fallback successful, using ${fallback.name} data`);
            // Use the same display logic but with fallback data
            let html = `
              <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #856404;">‚ö†Ô∏è Using Fallback Categories</h4>
                <p style="margin: 0; font-size: 14px; color: #856404;">
                  Real-time scraper unavailable, showing <strong>${fallbackData.categories.length}</strong> categories from ${fallback.name}
                </p>
                <p style="margin: 5px 0 0 0; font-size: 12px; color: #6c757d;">
                  Source: ${fallbackData.source || fallback.name} | Last updated: ${new Date().toLocaleTimeString()}
                </p>
              </div>
              
              <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
            `;
            
            fallbackData.categories.forEach((category, index) => {
              html += `
                <div style="border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; background: white;">
                  <div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">${category.name}</div>
                  <div style="font-size: 12px; color: #6c757d; margin-bottom: 10px;">${category.type || 'predefined_category'}</div>
                  <div style="display: flex; gap: 8px; margin-top: 10px;">
                    <button onclick="loadSubcategories('${category.name}')" style="padding: 6px 12px; border: 1px solid #17a2b8; border-radius: 4px; background: #17a2b8; color: white; cursor: pointer; font-size: 11px; font-weight: bold;">
                      üìÅ Browse Subcategories
                    </button>
                    <button onclick="searchLiveCategoryProducts('${category.name}')" style="padding: 6px 12px; border: 1px solid #28a745; border-radius: 4px; background: #28a745; color: white; cursor: pointer; font-size: 11px; font-weight: bold;">
                      üîç Search Products
                    </button>
                  </div>
                </div>
              `;
            });
            
            html += '</div>';
            container.innerHTML = html;
            status.textContent = `‚ö†Ô∏è Using fallback: ${fallbackData.categories.length} categories`;
            return;
          }
        }
      } catch (fallbackError) {
        console.error(`${fallback.name} fallback failed:`, fallbackError);
      }
    }
    
    // If all fallbacks fail, show error
    container.innerHTML = `
      <div style="text-align: center; padding: 40px; color: #dc3545;">
        <div style="font-size: 18px; margin-bottom: 10px;">‚ùå Failed to Load Live Categories</div>
        <div style="font-size: 14px; color: #666; margin-bottom: 20px;">${error.message}</div>
        <div style="font-size: 12px; color: #888;">
          All scrapers are unavailable. Please check if any of these are running:<br>
          ‚Ä¢ Real-Time Scraper (localhost:5009)<br>
          ‚Ä¢ Simple Scraper (localhost:5010)<br>
          ‚Ä¢ Hierarchical Scraper (localhost:5008)
        </div>
      </div>
    `;
    status.textContent = '‚ùå Failed to load';
  }
}

// Search products in a live category
async function searchLiveCategoryProducts(categoryName) {
  // Switch to search tab
  switchTab('search');
  
  // Set the search input
  const searchInput = document.getElementById('q');
  searchInput.value = categoryName;
  
  // Trigger search
  searchProducts(categoryName);
}

// Refresh live categories
function refreshLiveCategories() {
  loadLiveCategories();
}

// New function to load subcategories
async function loadSubcategories(categoryName) {
  const container = document.getElementById('liveCategoriesContainer');
  const status = document.getElementById('liveCategoriesStatus');
  
  try {
    status.textContent = 'Loading subcategories...';
    container.innerHTML = `
      <div style="text-align: center; padding: 20px;">
        <div class="spinner"></div>
        <div style="margin-top: 10px;">Loading subcategories for ${categoryName}...</div>
      </div>
    `;
    
    // Try real-time scraper first, then fallback to hierarchical scraper
    let response = await fetch(`http://localhost:5009/categories/${encodeURIComponent(categoryName)}`);
    let subcategoryResponseData = await response.json();
    
    if (!subcategoryResponseData.success || !subcategoryResponseData.subcategories || subcategoryResponseData.subcategories.length === 0) {
      // Fallback to hierarchical scraper
      response = await fetch(`http://localhost:5008/categories/${encodeURIComponent(categoryName)}`);
      subcategoryResponseData = await response.json();
    }
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    if (subcategoryResponseData.success && subcategoryResponseData.subcategories && subcategoryResponseData.subcategories.length > 0) {
      let html = `
        <div style="margin-bottom: 20px;">
          <button onclick="loadLiveCategories()" style="padding: 6px 12px; border: 1px solid var(--muted); border-radius: 6px; background: var(--muted); color: white; cursor: pointer; margin-bottom: 15px;">‚Üê Back to Main Categories</button>
          <h4 style="margin: 0 0 15px 0; color: #155724;">üìÅ Subcategories in: ${categoryName}</h4>
          <p style="color: #666; font-size: 14px; margin-bottom: 20px;">Found <strong>${subcategoryResponseData.subcategories.length}</strong> subcategories</p>
        </div>
        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
      `;
      
      subcategoryResponseData.subcategories.forEach(category => {
        html += `
          <div class="live-category-card" style="border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; background: white; cursor: pointer; transition: all 0.2s;" onclick="searchLiveCategoryProducts('${category.name}')">
            <div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">${category.name}</div>
            <div style="font-size: 12px; color: #7f8c8d; margin-bottom: 10px;">${category.type}</div>
            <div style="font-size: 11px; color: #95a5a6; word-break: break-all;">üîó URL: <a href="${category.url}" target="_blank" style="color: #4285f4; text-decoration: none;">${category.url}</a></div>
            <div style="margin-top: 10px; font-size: 12px; color: #27ae60;">Click to search products in this subcategory</div>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
      status.textContent = `‚úÖ Loaded ${data.subcategories.length} subcategories`;
    } else {
      container.innerHTML = `
        <div style="text-align: center; padding: 40px; color: #e74c3c;">
          <div style="font-size: 18px; margin-bottom: 10px;">üìÅ No Subcategories Found</div>
          <div style="font-size: 14px; color: #666; margin-bottom: 20px;">This category doesn't have subcategories</div>
          <button onclick="loadLiveCategories()" style="padding: 8px 16px; border: 1px solid var(--blue); border-radius: 6px; background: var(--blue); color: white; cursor: pointer;">‚Üê Back to Main Categories</button>
        </div>
      `;
      status.textContent = '‚ö†Ô∏è No subcategories found';
    }
    
  } catch (error) {
    console.error('Error loading subcategories:', error);
    container.innerHTML = `
      <div style="text-align: center; padding: 40px; color: #dc3545;">
        <div style="font-size: 18px; margin-bottom: 10px;">‚ùå Failed to Load Subcategories</div>
        <div style="font-size: 14px; color: #666; margin-bottom: 20px;">${error.message}</div>
        <button onclick="loadLiveCategories()" style="padding: 8px 16px; border: 1px solid var(--blue); border-radius: 6px; background: var(--blue); color: white; cursor: pointer;">‚Üê Back to Main Categories</button>
      </div>
    `;
    status.textContent = '‚ùå Failed to load subcategories';
  }
}

// Category browsing functionality with tree structure
async function loadCategories() {
  if (isLoading) return;
  isLoading = true;
  
  const categoryTree = document.getElementById('category-tree');
  categoryTree.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Loading Lotus categories...</div>';
  
        try {
          // Use real categories extracted from actual product data
          const realCategories = [
            { name: "Canned Food", url: "https://www.lotuss.com.my/en/category/canned-food", type: "extracted_category" },
            { name: "Confectionery", url: "https://www.lotuss.com.my/en/category/confectionery", type: "extracted_category" },
            { name: "Dairy", url: "https://www.lotuss.com.my/en/category/dairy", type: "extracted_category" },
            { name: "Grains", url: "https://www.lotuss.com.my/en/category/grains", type: "extracted_category" },
            { name: "HORECA", url: "https://www.lotuss.com.my/en/category/horeca", type: "extracted_category" },
            { name: "Food & Beverages", url: "https://www.lotuss.com.my/en/category/food-and-beverages", type: "common_category" },
            { name: "Fresh Produce", url: "https://www.lotuss.com.my/en/category/fresh-produce", type: "common_category" },
            { name: "Meat & Seafood", url: "https://www.lotuss.com.my/en/category/meat-and-seafood", type: "common_category" },
            { name: "Dairy & Eggs", url: "https://www.lotuss.com.my/en/category/dairy-and-eggs", type: "common_category" },
            { name: "Bakery", url: "https://www.lotuss.com.my/en/category/bakery", type: "common_category" },
            { name: "Frozen Foods", url: "https://www.lotuss.com.my/en/category/frozen-foods", type: "common_category" },
            { name: "Pantry", url: "https://www.lotuss.com.my/en/category/pantry", type: "common_category" },
            { name: "Snacks & Confectionery", url: "https://www.lotuss.com.my/en/category/snacks-and-confectionery", type: "common_category" },
            { name: "Beverages", url: "https://www.lotuss.com.my/en/category/beverages", type: "common_category" },
            { name: "Health & Beauty", url: "https://www.lotuss.com.my/en/category/health-and-beauty", type: "common_category" },
            { name: "Household", url: "https://www.lotuss.com.my/en/category/household", type: "common_category" },
            { name: "Baby Care", url: "https://www.lotuss.com.my/en/category/baby-care", type: "common_category" },
            { name: "Pet Care", url: "https://www.lotuss.com.my/en/category/pet-care", type: "common_category" },
            { name: "Pharmacy", url: "https://www.lotuss.com.my/en/category/pharmacy", type: "common_category" },
            { name: "Electronics", url: "https://www.lotuss.com.my/en/category/electronics", type: "common_category" },
            { name: "Home & Garden", url: "https://www.lotuss.com.my/en/category/home-and-garden", type: "common_category" },
            { name: "Personal Care", url: "https://www.lotuss.com.my/en/category/personal-care", type: "common_category" },
            { name: "Cleaning", url: "https://www.lotuss.com.my/en/category/cleaning", type: "common_category" },
            { name: "Laundry", url: "https://www.lotuss.com.my/en/category/laundry", type: "common_category" },
            { name: "Kitchen", url: "https://www.lotuss.com.my/en/category/kitchen", type: "common_category" }
          ];
    
    // Render real categories
    renderRealCategories(realCategories);
    console.log(`Loaded ${realCategories.length} real Lotus categories (${realCategories.filter(c => c.type === 'extracted_category').length} from product data)`);
    
  } catch (error) {
    console.error('Error loading categories:', error);
    // Final fallback to hardcoded categories
    const categoryTreeData = createCategoryTree();
    renderCategoryTree(categoryTreeData);
    console.log('Error occurred, using hardcoded categories');
  }
  
  isLoading = false;
}

// Render real categories from Lotus website
function renderRealCategories(categories) {
  const categoryTree = document.getElementById('category-tree');
  
  if (!categories || categories.length === 0) {
    categoryTree.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No categories available</div>';
    return;
  }
  
  let html = '<div class="real-categories">';
  html += '<h3 style="margin-bottom: 20px; color: #333;">Select a Category to Search</h3>';
  
  categories.forEach((category, index) => {
    const typeLabel = category.type === 'extracted_category' ? 'Real Data' : 'Common';
    const typeColor = category.type === 'extracted_category' ? '#4CAF50' : '#2196F3';
    
    html += `
      <div class="real-category-item" onclick="selectRealCategory('${category.name}', '${category.url}')">
        <div class="category-info">
          <span class="category-name">${category.name}</span>
          <span class="category-type" style="background-color: ${typeColor}; color: white;">${typeLabel}</span>
        </div>
        <div class="category-arrow">‚Üí</div>
      </div>
    `;
  });
  
  html += '</div>';
  categoryTree.innerHTML = html;
}

// Select a real category and show products directly
function selectRealCategory(categoryName, categoryUrl) {
  // Store selected category
  selectedCategory = {
    name: categoryName,
    url: categoryUrl,
    type: 'real'
  };
  
  // Show category products interface
  const categoryTree = document.getElementById('category-tree');
  categoryTree.innerHTML = `
    <div class="category-products-interface">
      <div class="selected-category-header">
        <button onclick="backToRealCategories()" class="back-button">‚Üê Back to Categories</button>
        <h3>Products in: ${categoryName}</h3>
        <p class="category-url">${categoryUrl}</p>
      </div>
      
      <div id="categoryProductsDisplay" class="category-products-display">
        <div style="text-align: center; padding: 40px; color: #666;">Loading products for ${categoryName}...</div>
      </div>
    </div>
  `;
  
  // Load and display products for this category
  loadCategoryProducts(categoryName);
}

// Load products for the selected category from the Lotus website in real-time
async function loadCategoryProducts(categoryName) {
  if (!selectedCategory) {
    console.error('No category selected');
    return;
  }
  
  const resultsDiv = document.getElementById('categoryProductsDisplay');
  
  try {
    // Show loading message
    resultsDiv.innerHTML = `<div style="text-align: center; padding: 40px; color: #666;">
      <div style="font-size: 18px; margin-bottom: 10px;">üîÑ Loading products from Lotus website...</div>
      <div style="font-size: 14px; color: #888;">Searching for "${categoryName}" products on lotuss.com.my</div>
    </div>`;
    
    console.log(`Loading real-time products for category: "${categoryName}"`);
    
    // Map category names to search terms for better results
    const categorySearchTerms = {
      'food & beverages': 'food',
      'meat & seafood': 'meat chicken fish',
      'dairy & eggs': 'dairy milk cheese',
      'fresh produce': 'fresh vegetables fruits',
      'bakery': 'bread cake pastry',
      'frozen foods': 'frozen',
      'pantry': 'rice noodles sauce',
      'snacks & confectionery': 'snacks chocolate',
      'beverages': 'drinks juice water',
      'health & beauty': 'health beauty',
      'household': 'cleaning detergent',
      'baby care': 'baby',
      'pet care': 'pet',
      'pharmacy': 'medicine',
      'electronics': 'electronic',
      'home & garden': 'home garden',
      'personal care': 'personal care',
      'cleaning': 'cleaning',
      'laundry': 'laundry',
      'kitchen': 'kitchen'
    };
    
    // Get search terms for this category
    const searchTerms = categorySearchTerms[categoryName.toLowerCase()] || categoryName;
    
    // Try to get products from Lotus Live Scraper first
    let products = [];
    let source = 'Lotus Live Scraper';
    
    try {
      console.log(`Trying Lotus Live Scraper for: ${searchTerms}`);
      const response = await fetch(`http://localhost:5004/search?q=${encodeURIComponent(searchTerms)}&limit=20`);
      
      if (response.ok) {
        const liveData = await response.json();
        if (liveData.products && liveData.products.length > 0) {
          products = liveData.products.map((product, index) => convertLiveEnglishSearchResult(product, index));
          console.log(`‚úÖ Found ${products.length} products from Lotus Live Scraper`);
        }
      }
    } catch (error) {
      console.log('Lotus Live Scraper not available, trying Lotus English API...');
    }
    
    // If no products from Live Scraper, try Lotus English API
    if (products.length === 0) {
      try {
        console.log(`Trying Lotus English API for: ${searchTerms}`);
        const response = await fetch(`http://localhost:5003/search?q=${encodeURIComponent(searchTerms)}&limit=20`);
        
        if (response.ok) {
          const englishData = await response.json();
          if (englishData.products && englishData.products.length > 0) {
            products = englishData.products.map((product, index) => convertLiveEnglishSearchResult(product, index));
            source = 'Lotus English API';
            console.log(`‚úÖ Found ${products.length} products from Lotus English API`);
          }
        }
      } catch (error) {
        console.log('Lotus English API not available, trying regular Lotus API...');
      }
    }
    
    // If no products from English API, try regular Lotus API
    if (products.length === 0) {
      try {
        console.log(`Trying regular Lotus API for: ${searchTerms}`);
        const response = await fetch(`http://localhost:5000/search?q=${encodeURIComponent(searchTerms)}&limit=20`);
        
        if (response.ok) {
          const lotusData = await response.json();
          if (lotusData.products && lotusData.products.length > 0) {
            products = lotusData.products.map((product, index) => convertLiveSearchResult(product, index));
            source = 'Lotus API';
            console.log(`‚úÖ Found ${products.length} products from Lotus API`);
          }
        }
      } catch (error) {
        console.log('Lotus API not available, trying HORECA API...');
      }
    }
    
    // If still no products, try HORECA API as fallback
    if (products.length === 0) {
      try {
        console.log(`Trying HORECA API for: ${searchTerms}`);
        const response = await fetch(`http://localhost:5002/search?q=${encodeURIComponent(searchTerms)}&limit=20`);
        
        if (response.ok) {
          const horecaData = await response.json();
          if (horecaData.products && horecaData.products.length > 0) {
            products = await Promise.all(
              horecaData.products.map((product, index) => convertHorecaProduct(product, index))
            );
            source = 'HORECA API';
            console.log(`‚úÖ Found ${products.length} products from HORECA API`);
          }
        }
      } catch (error) {
        console.log('HORECA API not available');
      }
    }
    
    // Display results
    if (products.length > 0) {
      let html = `<h4>Found ${products.length} products in "${categoryName}"</h4>`;
      html += `<p style="color: #666; font-size: 14px; margin-bottom: 20px;">üì° Live data from ${source}</p>`;
      html += '<div class="category-products-grid">';
      
      products.forEach(product => {
        html += `
          <div class="category-product-card" onclick="viewProductFromCategory('${product.id}')">
            <div class="product-info">
              <h5 class="product-title">${product.title}</h5>
              <p class="product-price">${product.aggregate.currency} ${product.aggregate.lowPrice.toFixed(2)}</p>
              <p class="product-category">${product.category_path || categoryName}</p>
              <p class="product-source" style="font-size: 12px; color: #888;">Source: ${source}</p>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      resultsDiv.innerHTML = html;
      
      // Store products for viewing
      window.categoryProducts = products;
      
    } else {
      // No products found from any source
      let html = `<div style="text-align: center; padding: 40px; color: #666;">
        <div style="font-size: 18px; margin-bottom: 10px;">‚ùå No products found</div>
        <div style="font-size: 14px; color: #888; margin-bottom: 20px;">
          No products found for "${categoryName}" on any available data source.
        </div>
        <div style="font-size: 12px; color: #aaa;">
          Tried: Lotus English API, Lotus API, HORECA API
        </div>
      </div>`;
      
      resultsDiv.innerHTML = html;
    }
    
  } catch (error) {
    console.error('Error loading category products:', error);
    resultsDiv.innerHTML = `<div style="text-align: center; padding: 20px; color: #c62828;">
      <div style="font-size: 16px; margin-bottom: 10px;">‚ùå Error loading products</div>
      <div style="font-size: 14px; color: #888;">${error.message}</div>
      <div style="font-size: 12px; color: #aaa; margin-top: 10px;">
        Make sure the Lotus APIs are running on localhost:5000 and localhost:5003
      </div>
    </div>`;
  }
}

// Find products that belong to a specific category
function findProductsInCategory(categoryName) {
  if (!allProducts || allProducts.length === 0) {
    return [];
  }
  
  const categoryKeywords = categoryName.toLowerCase().split(/[\s&]+/);
  
  // Enhanced category mapping with specific keywords including HORECA products
  const categoryMappings = {
    'food': ['food', 'makanan', 'chicken', 'beef', 'pork', 'lamb', 'mutton', 'ayam', 'daging', 'kambing', 'meat', 'protein', 'fish', 'ikan', 'salmon', 'tuna', 'prawn', 'shrimp', 'udang', 'crab', 'ketam', 'squid', 'sotong', 'seafood', 'marine', 'milk', 'susu', 'cheese', 'keju', 'yogurt', 'butter', 'mentega', 'cream', 'dairy', 'egg', 'telur', 'eggs', 'fresh', 'segar', 'vegetable', 'sayur', 'fruit', 'buah', 'produce', 'bread', 'roti', 'cake', 'kek', 'pastry', 'biscuit', 'biskut', 'bakery', 'rice', 'nasi', 'grain', 'bijirin', 'canned', 'tin', 'sauce', 'sos', 'oil', 'minyak', 'snack', 'snek', 'chips', 'crisp', 'chocolate', 'coklat', 'candy', 'gula-gula', 'noodles', 'mee', 'mi', 'instant', 'soup', 'sup', 'krimer', 'creamer', 'tepung', 'flour', 'gula', 'sugar', 'spaghetti', 'spageti'],
    'beverages': ['beverages', 'beverage', 'drink', 'minuman', 'juice', 'jus', 'water', 'air', 'tea', 'teh', 'coffee', 'kopi', 'soda', 'krimer', 'creamer', 'nescafe', 'red bull', 'spritzer'],
    'meat': ['chicken', 'beef', 'pork', 'lamb', 'mutton', 'ayam', 'daging', 'kambing', 'meat', 'protein', 'paha', 'dada', 'thigh', 'breast', 'shoulder', 'neck', 'bone', 'cubes', 'kerbau', 'buffalo', 'nugget', 'hot dog', 'burger'],
    'seafood': ['fish', 'ikan', 'salmon', 'tuna', 'prawn', 'shrimp', 'udang', 'crab', 'ketam', 'squid', 'sotong', 'seafood', 'marine', 'dory', 'siakap', 'sea bass', 'cencaru', 'sardin', 'kembong', 'patin', 'kerang', 'clams', 'ring', 'skin', 'frozen', 'beku', 'kepingan'],
    'dairy': ['milk', 'susu', 'cheese', 'keju', 'yogurt', 'butter', 'mentega', 'cream', 'dairy', 'dutch lady', 'magnolia', 'ais krim', 'ice cream', 'tepung', 'powder'],
    'eggs': ['egg', 'telur', 'eggs'],
    'fresh': ['fresh', 'segar', 'vegetable', 'sayur', 'fruit', 'buah', 'produce', 'brokoli', 'broccoli', 'ubi', 'potato', 'kentang', 'bawang', 'onion', 'putih', 'merah', 'garlic', 'tomato', 'cili', 'chili', 'halia', 'ginger', 'kobis', 'cabbage', 'lobak', 'carrot', 'timun', 'cucumber', 'cendawan', 'mushroom', 'enoki', 'taugeh', 'bean sprout'],
    'bakery': ['bread', 'roti', 'cake', 'kek', 'pastry', 'biscuit', 'biskut', 'bakery', 'bun', 'burger bun', 'sesame', 'hot dog', 'biji'],
    'frozen': ['frozen', 'beku', 'ice', 'ais', 'sejuk', 'cold'],
    'pantry': ['rice', 'nasi', 'grain', 'bijirin', 'canned', 'tin', 'sauce', 'sos', 'oil', 'minyak', 'noodles', 'mee', 'mi', 'instant', 'soup', 'sup', 'spaghetti', 'spageti', 'kimball', 'maggi', 'indomie', 'numee', 'vit', 'pek'],
    'snacks': ['snack', 'snek', 'chips', 'crisp', 'chocolate', 'coklat', 'candy', 'gula-gula', 'biskut', 'biscuit', 'jacob', 'hwa tai', 'naxnat', 'krim kaker', 'weetameal'],
    'health': ['health', 'kesihatan', 'vitamin', 'supplement', 'medicine', 'ubat', 'tena', 'lampin', 'diaper'],
    'beauty': ['beauty', 'kecantikan', 'cosmetic', 'kosmetik', 'skincare', 'makeup', 'tisu', 'tissue', 'facial'],
    'household': ['household', 'rumah', 'cleaning', 'pembersihan', 'detergent', 'detergen', 'glo', 'daia', 'top', 'pencuci', 'pakaian', 'laundry', 'sponge', 'tisu', 'toilet'],
    'baby': ['baby', 'bayi', 'infant', 'kanak-kanak', 'diaper', 'lampin', 'tena'],
    'pet': ['pet', 'haiwan', 'dog', 'anjing', 'cat', 'kucing', 'food', 'makanan'],
    'pharmacy': ['pharmacy', 'farmasi', 'medical', 'perubatan', 'health', 'kesihatan'],
    'electronics': ['electronic', 'elektronik', 'phone', 'telefon', 'computer', 'komputer'],
    'home': ['home', 'rumah', 'garden', 'taman', 'furniture', 'perabot', 'container', 'lunch box', 'bag', 'wok', 'pinggan', 'mangkuk', 'plate', 'bowl'],
    'personal': ['personal', 'peribadi', 'care', 'penjagaan', 'hygiene', 'kebersihan'],
    'cleaning': ['cleaning', 'pembersihan', 'detergent', 'detergen', 'soap', 'sabun', 'glo', 'daia', 'top', 'pencuci', 'pinggan', 'mangkuk', 'sponge'],
    'laundry': ['laundry', 'dobi', 'washing', 'basuh', 'fabric', 'kain', 'pencuci', 'pakaian', 'serbuk', 'powder', 'lemon', 'lavender'],
    'kitchen': ['kitchen', 'dapur', 'cookware', 'peralatan', 'utensil', 'perkakas', 'wok', 'gendang', 'pinggan', 'mangkuk', 'container', 'bag']
  };
  
  return allProducts.filter(product => {
    const productCategory = (product.category_path || '').toLowerCase();
    const productTitle = (product.title || '').toLowerCase();
    const productBrand = (product.brand || '').toLowerCase();
    const productText = `${productCategory} ${productTitle} ${productBrand}`.toLowerCase();
    
    // Check direct keyword matches
    const directMatch = categoryKeywords.some(keyword => 
      keyword.length > 2 && (
        productCategory.includes(keyword) ||
        productTitle.includes(keyword) ||
        productBrand.includes(keyword)
      )
    );
    
    if (directMatch) return true;
    
    // Check enhanced category mappings
    for (const [categoryKey, keywords] of Object.entries(categoryMappings)) {
      if (categoryKeywords.includes(categoryKey)) {
        const hasKeyword = keywords.some(keyword => 
          productText.includes(keyword)
        );
        if (hasKeyword) return true;
      }
    }
    
    return false;
  });
}

// Go back to real categories list
function backToRealCategories() {
  selectedCategory = null;
  categoryProducts = [];
  window.categoryProducts = null;
  loadCategories(); // Reload categories
}

// View product details from category
function viewProductFromCategory(productId) {
  // Switch to search tab and highlight the product
  switchTab('search');
  
  // Find and highlight the product
  const product = window.categoryProducts ? window.categoryProducts.find(p => p.id === productId) : null;
  if (product) {
    // Add to main feed and highlight
    allProducts = [product];
    FEED = allProducts;
    render();
    
    // Scroll to product
    setTimeout(() => {
      const productElement = document.querySelector(`[data-product-id="${productId}"]`);
      if (productElement) {
        productElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        productElement.style.border = '2px solid #4285f4';
        setTimeout(() => {
          productElement.style.border = '';
        }, 3000);
      }
    }, 100);
  }
}

function createCategoryTree() {
  // Define the hierarchical category structure
  const categoryStructure = {
    "Food & Beverages": {
      "Meat & Poultry": {
        "Chicken": [],
        "Beef": [],
        "Lamb": [],
        "Seafood": []
      },
      "Dairy & Eggs": {
        "Milk": [],
        "Cheese": [],
        "Butter": [],
        "Eggs": []
      },
      "Fruits & Vegetables": {
        "Fresh Vegetables": [],
        "Fresh Fruits": [],
        "Frozen Vegetables": [],
        "Frozen Fruits": []
      },
      "Pantry Staples": {
        "Rice & Grains": [],
        "Cooking Oil": [],
        "Spices & Seasonings": [],
        "Sauces & Condiments": []
      },
      "Beverages": {
        "Soft Drinks": [],
        "Juices": [],
        "Coffee & Tea": [],
        "Water": []
      },
      "Frozen Foods": {
        "Frozen Meals": [],
        "Frozen Snacks": [],
        "Ice Cream": []
      },
      "Canned & Preserved": {
        "Canned Vegetables": [],
        "Canned Fruits": [],
        "Canned Meat": [],
        "Canned Fish": []
      }
    },
    "Cleaning & Supplies": {
      "Kitchen Supplies": [],
      "Cleaning Products": [],
      "Paper Products": [],
      "Disposable Items": []
    },
    "Equipment & Tools": {
      "Kitchen Equipment": [],
      "Storage Containers": [],
      "Utensils": []
    }
  };
  
  // Map products to categories
  const categoryMapping = mapProductsToCategories();
  
  // Build the tree with product counts
  function buildTree(node, path = []) {
    const result = {};
    
    for (const [key, value] of Object.entries(node)) {
      const currentPath = [...path, key];
      const fullPath = currentPath.join(' > ');
      
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        // It's a subcategory
        result[key] = buildTree(value, currentPath);
      } else {
        // It's a leaf category
        const productCount = categoryMapping[fullPath] ? categoryMapping[fullPath].length : 0;
        result[key] = {
          _isLeaf: true,
          _path: fullPath,
          _count: productCount,
          _products: categoryMapping[fullPath] || []
        };
      }
    }
    
    return result;
  }
  
  return buildTree(categoryStructure);
}

function mapProductsToCategories() {
  const categoryMapping = {};
  
  allProducts.forEach(product => {
    const categoryPath = mapProductToCategory(product);
    
    if (!categoryMapping[categoryPath]) {
      categoryMapping[categoryPath] = [];
    }
    categoryMapping[categoryPath].push(product);
  });
  
  return categoryMapping;
}

function mapProductToCategory(product) {
  const name = (product.title || '').toLowerCase();
  const category = (product.category_path || '').toLowerCase();
  const brand = (product.brand || '').toLowerCase();
  
  // Meat & Poultry
  if (name.includes('ayam') || name.includes('chicken') || name.includes('daging') || name.includes('beef') || name.includes('lamb') || name.includes('kambing') || name.includes('mutton')) {
    if (name.includes('ayam') || name.includes('chicken')) {
      return "Food & Beverages > Meat & Poultry > Chicken";
    } else if (name.includes('daging') || name.includes('beef') || name.includes('kerbau')) {
      return "Food & Beverages > Meat & Poultry > Beef";
    } else if (name.includes('kambing') || name.includes('mutton') || name.includes('lamb')) {
      return "Food & Beverages > Meat & Poultry > Lamb";
    } else {
      return "Food & Beverages > Meat & Poultry";
    }
  }
  
  // Seafood
  if (name.includes('ikan') || name.includes('fish') || name.includes('siakap') || name.includes('dory') || name.includes('sotong') || name.includes('kerang') || name.includes('seafood')) {
    return "Food & Beverages > Meat & Poultry > Seafood";
  }
  
  // Dairy
  if (name.includes('susu') || name.includes('milk') || name.includes('cheese') || name.includes('butter') || name.includes('telur') || name.includes('egg')) {
    if (name.includes('susu') || name.includes('milk')) {
      return "Food & Beverages > Dairy & Eggs > Milk";
    } else if (name.includes('cheese')) {
      return "Food & Beverages > Dairy & Eggs > Cheese";
    } else if (name.includes('butter')) {
      return "Food & Beverages > Dairy & Eggs > Butter";
    } else if (name.includes('telur') || name.includes('egg')) {
      return "Food & Beverages > Dairy & Eggs > Eggs";
    } else {
      return "Food & Beverages > Dairy & Eggs";
    }
  }
  
  // Vegetables
  if (name.includes('bawang') || name.includes('onion') || name.includes('kentang') || name.includes('potato') || name.includes('brokoli') || name.includes('broccoli') || name.includes('halia') || name.includes('ginger')) {
    if (name.includes('beku') || name.includes('frozen')) {
      return "Food & Beverages > Fruits & Vegetables > Frozen Vegetables";
    } else {
      return "Food & Beverages > Fruits & Vegetables > Fresh Vegetables";
    }
  }
  
  // Fruits
  if (name.includes('buah') || name.includes('fruit') || name.includes('apple') || name.includes('orange') || name.includes('banana')) {
    if (name.includes('beku') || name.includes('frozen')) {
      return "Food & Beverages > Fruits & Vegetables > Frozen Fruits";
    } else {
      return "Food & Beverages > Fruits & Vegetables > Fresh Fruits";
    }
  }
  
  // Rice & Grains
  if (name.includes('beras') || name.includes('rice') || name.includes('grain') || name.includes('nasi')) {
    return "Food & Beverages > Pantry Staples > Rice & Grains";
  }
  
  // Cooking Oil
  if (name.includes('minyak') || name.includes('oil') || name.includes('cooking')) {
    return "Food & Beverages > Pantry Staples > Cooking Oil";
  }
  
  // Spices & Seasonings
  if (name.includes('garam') || name.includes('salt') || name.includes('sugar') || name.includes('gula') || name.includes('spice') || name.includes('seasoning') || name.includes('perasa')) {
    return "Food & Beverages > Pantry Staples > Spices & Seasonings";
  }
  
  // Sauces & Condiments
  if (name.includes('sos') || name.includes('sauce') || name.includes('kicap') || name.includes('soy') || name.includes('condiment')) {
    return "Food & Beverages > Pantry Staples > Sauces & Condiments";
  }
  
  // Beverages
  if (name.includes('minuman') || name.includes('drink') || name.includes('juice') || name.includes('coffee') || name.includes('tea') || name.includes('air') || name.includes('water')) {
    if (name.includes('soft') || name.includes('cola') || name.includes('sprite')) {
      return "Food & Beverages > Beverages > Soft Drinks";
    } else if (name.includes('juice') || name.includes('jus')) {
      return "Food & Beverages > Beverages > Juices";
    } else if (name.includes('coffee') || name.includes('kopi') || name.includes('tea') || name.includes('teh')) {
      return "Food & Beverages > Beverages > Coffee & Tea";
    } else if (name.includes('air') || name.includes('water')) {
      return "Food & Beverages > Beverages > Water";
    } else {
      return "Food & Beverages > Beverages";
    }
  }
  
  // Frozen Foods
  if (name.includes('beku') || name.includes('frozen') || name.includes('ice')) {
    if (name.includes('meal') || name.includes('makanan')) {
      return "Food & Beverages > Frozen Foods > Frozen Meals";
    } else if (name.includes('snack') || name.includes('snek')) {
      return "Food & Beverages > Frozen Foods > Frozen Snacks";
    } else if (name.includes('ice cream') || name.includes('ais krim')) {
      return "Food & Beverages > Frozen Foods > Ice Cream";
    } else {
      return "Food & Beverages > Frozen Foods";
    }
  }
  
  // Canned & Preserved
  if (name.includes('tin') || name.includes('canned') || name.includes('preserved')) {
    if (name.includes('vegetable') || name.includes('sayur')) {
      return "Food & Beverages > Canned & Preserved > Canned Vegetables";
    } else if (name.includes('fruit') || name.includes('buah')) {
      return "Food & Beverages > Canned & Preserved > Canned Fruits";
    } else if (name.includes('meat') || name.includes('daging')) {
      return "Food & Beverages > Canned & Preserved > Canned Meat";
    } else if (name.includes('fish') || name.includes('ikan')) {
      return "Food & Beverages > Canned & Preserved > Canned Fish";
    } else {
      return "Food & Beverages > Canned & Preserved";
    }
  }
  
  // Cleaning & Supplies
  if (name.includes('cleaning') || name.includes('pembersih') || name.includes('soap') || name.includes('sabun') || name.includes('detergent')) {
    return "Cleaning & Supplies > Cleaning Products";
  }
  
  // Paper Products
  if (name.includes('paper') || name.includes('kertas') || name.includes('tissue') || name.includes('napkin')) {
    return "Cleaning & Supplies > Paper Products";
  }
  
  // Default category
  return "Food & Beverages > Pantry Staples > Spices & Seasonings";
}

function renderCategoryTree(treeData, level = 0) {
  const categoryTree = document.getElementById('category-tree');
  
  function renderNode(node, nodeName, currentLevel) {
    const isLeaf = node._isLeaf;
    const hasChildren = !isLeaf && Object.keys(node).length > 0;
    const productCount = isLeaf ? node._count : 0;
    
    let html = '';
    
    if (isLeaf) {
      // Leaf category - show products
      html += `
        <div class="category-item category-level-${currentLevel}" data-category-path="${node._path}" onclick="selectCategory('${node._path}')">
          <div class="category-name">${nodeName}</div>
          <div class="category-count">${productCount}</div>
        </div>
      `;
    } else {
      // Parent category - show with toggle
      html += `
        <div class="category-node" data-level="${currentLevel}">
          <div class="category-item category-level-${currentLevel}" onclick="toggleCategory('${nodeName}', ${currentLevel})">
            <div class="category-toggle">‚ñ∂</div>
            <div class="category-name">${nodeName}</div>
            <div class="category-count">${getTotalProductCount(node)}</div>
          </div>
          <div class="category-children" id="children-${nodeName}-${currentLevel}" style="display: none;">
      `;
      
      // Render children
      for (const [childName, childNode] of Object.entries(node)) {
        html += renderNode(childNode, childName, currentLevel + 1);
      }
      
      html += `
          </div>
        </div>
      `;
    }
    
    return html;
  }
  
  let fullHtml = '';
  for (const [nodeName, nodeData] of Object.entries(treeData)) {
    fullHtml += renderNode(nodeData, nodeName, level);
  }
  
  categoryTree.innerHTML = fullHtml;
}

function getTotalProductCount(node) {
  if (node._isLeaf) {
    return node._count || 0;
  }
  
  let total = 0;
  for (const child of Object.values(node)) {
    total += getTotalProductCount(child);
  }
  return total;
}

function toggleCategory(categoryName, level) {
  const childrenId = `children-${categoryName}-${level}`;
  const childrenElement = document.getElementById(childrenId);
  const toggleElement = childrenElement.previousElementSibling.querySelector('.category-toggle');
  
  if (childrenElement.style.display === 'none') {
    childrenElement.style.display = 'block';
    toggleElement.classList.add('expanded');
    toggleElement.textContent = '‚ñº';
  } else {
    childrenElement.style.display = 'none';
    toggleElement.classList.remove('expanded');
    toggleElement.textContent = '‚ñ∂';
  }
}

async function selectCategory(categoryPath) {
  selectedCategory = categoryPath;
  
  // Get products for this category from the tree structure
  const categoryMapping = mapProductsToCategories();
  categoryProducts = categoryMapping[categoryPath] || [];
  
  // Show products container
  document.getElementById('categories-container').style.display = 'none';
  document.getElementById('products-container').style.display = 'block';
  document.getElementById('backToCategories').style.display = 'inline-block';
  
  // Update title
  document.getElementById('category-title').textContent = `Products in ${categoryPath} (${categoryProducts.length} items)`;
  
  // Render products
  await renderCategoryProducts();
}

async function renderCategoryProducts() {
  const productsContainer = document.getElementById('products-in-category');
  const showOriginal = document.getElementById('showOriginalNames').checked;
  
  if (categoryProducts.length === 0) {
    productsContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No products found in this category</div>';
    return;
  }
  
  const html = await Promise.all(categoryProducts.map(async product => {
    let displayTitle = showOriginal && product.original_title ? product.original_title : (product.label || product.title);
    let subtitle = showOriginal && product.original_title ? (product.label || product.title) : (product.original_title || '');
    
    // Remove number prefixes from both displayTitle and subtitle
    if (displayTitle) {
      displayTitle = displayTitle.replace(/^\d+\.\s*/, '').trim();
    }
    if (subtitle) {
      subtitle = subtitle.replace(/^\d+\.\s*/, '').trim();
    }
    
    // Apply English translation to product names
    if (displayTitle && !showOriginal) {
      displayTitle = await translateProductName(displayTitle);
    }
    if (subtitle && !showOriginal) {
      subtitle = await translateProductName(subtitle);
    }
    
    return `
      <div class="product-card" onclick="viewProductDetails('${product.id}')">
        <div class="product-title" style="display: flex; align-items: center; gap: 12px;">
          ${(() => {
            // For HORECA products, ensure we always have an image
            const isHorecaProduct = product.brand && (product.brand.includes('HORECA') || product.source === 'horeca' || product.source === 'horeca-openai' || product.source === 'horeca-image-ocr');
            let imageUrl = product.image_link;
            
            if (isHorecaProduct && (!imageUrl || imageUrl === 'https://via.placeholder.com/240x240.png?text=No+Image')) {
              imageUrl = `https://picsum.photos/240/240?random=${product.id || Math.random()}`;
            }
            
            if (imageUrl && imageUrl !== 'https://via.placeholder.com/240x240.png?text=No+Image') {
              return `<div style="display: flex; flex-direction: column; align-items: center;">
                <img src="${imageUrl}" alt="${displayTitle}" style="width: 105px; height: 105px; object-fit: cover; border-radius: 6px; border: 1px solid #e0e0e0; cursor: pointer;" onerror="this.style.display='none'" onclick="window.open('${imageUrl}', '_blank')">
                ${isHorecaProduct ? '<div style="margin-top: 2px; font-size: 8px; color: #6f42c1; font-weight: bold;">HORECA</div>' : ''}
                ${product.product_url && product.product_url !== '#' ? 
                  `<div style="margin-top: 3px; font-size: 10px; color: #4285f4;"><a href="${product.product_url}" target="_blank" rel="noopener" style="color: #4285f4; text-decoration: none;">üîó</a></div>` :
                  product.url && product.url !== '#' ?
                  `<div style="margin-top: 3px; font-size: 10px; color: #4285f4;"><a href="${product.url}" target="_blank" rel="noopener" style="color: #4285f4; text-decoration: none;">üîó</a></div>` :
                  ''
                }
              </div>`;
            } else {
              return isHorecaProduct ? 
                `<div style="display: flex; flex-direction: column; align-items: center;">
                  <div style="width: 105px; height: 105px; background: #f5f5f5; border: 2px dashed #ccc; border-radius: 6px; display: flex; align-items: center; justify-content: center; color: #999; font-size: 10px; text-align: center;">No Image<br/>Available</div>
                  <div style="margin-top: 2px; font-size: 8px; color: #6f42c1; font-weight: bold;">HORECA</div>
                </div>` : '';
            }
          })()}
          <span>${displayTitle}</span>
        </div>
        ${subtitle && subtitle !== displayTitle ? `<div class="product-subtitle" style="font-size: 11px; color: var(--muted); margin-bottom: 4px;">${subtitle}</div>` : ''}
        <div class="product-price">RM ${product.offers[0].price.toFixed(2)}</div>
        <div class="product-merchant">${product.offers[0].merchant}</div>
      </div>
    `;
  }));
  
  const htmlString = html.join('');
  
  productsContainer.innerHTML = htmlString;
}

function backToCategories() {
  selectedCategory = null;
  categoryProducts = [];
  
  // Show categories container
  document.getElementById('categories-container').style.display = 'block';
  document.getElementById('products-container').style.display = 'none';
  document.getElementById('backToCategories').style.display = 'none';
}

function viewProductDetails(productId) {
  // Switch to search tab and highlight the product
  switchTab('search');
  
  // Find and scroll to the product
  const productElement = document.querySelector(`[data-product-id="${productId}"]`);
  if (productElement) {
    productElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    productElement.style.border = '2px solid var(--blue)';
    productElement.style.background = '#f0f8ff';
    
    // Remove highlight after 3 seconds
    setTimeout(() => {
      productElement.style.border = '';
      productElement.style.background = '';
    }, 3000);
  }
}

// Search categories
function searchCategories(query) {
  if (!query || query.trim() === '') {
    // Reload the full category tree
    loadCategories();
    return;
  }
  
  const categoryTree = document.getElementById('category-tree');
  const searchTerm = query.toLowerCase();
  
  // Get all category paths that match the search
  const categoryMapping = mapProductsToCategories();
  const matchingCategories = Object.keys(categoryMapping).filter(path =>
    path.toLowerCase().includes(searchTerm)
  );
  
  if (matchingCategories.length === 0) {
    categoryTree.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No categories found matching your search</div>';
    return;
  }
  
  // Create a simplified tree showing only matching categories
  let html = '<div style="margin-bottom: 20px; color: var(--muted);">Search results for: "' + query + '"</div>';
  
  matchingCategories.forEach(categoryPath => {
    const products = categoryMapping[categoryPath];
    const pathParts = categoryPath.split(' > ');
    const categoryName = pathParts[pathParts.length - 1];
    const level = pathParts.length - 1;
    
    html += `
      <div class="category-item category-level-${level}" data-category-path="${categoryPath}" onclick="selectCategory('${categoryPath}')">
        <div class="category-name">${categoryPath}</div>
        <div class="category-count">${products.length}</div>
      </div>
    `;
  });
  
  categoryTree.innerHTML = html;
}

// Function to update record counter
function updateRecordCounter() {
  const firecrawlCount = FEED.filter(p => p.source === 'Lotus Firecrawl').length;
  const recordCounter = document.getElementById('recordCounter');
  const recordCountText = document.getElementById('recordCountText');
  const saveToPostgresBtn = document.getElementById('saveToPostgres');
  
  if (firecrawlCount > 0) {
    recordCounter.style.display = 'block';
    recordCountText.textContent = `üì¶ ${firecrawlCount} Lotus records fetched`;
    
    // Show notification when save button becomes available
    if (saveToPostgresBtn.style.display === 'none' || saveToPostgresBtn.style.display === '') {
      showNotification(`üíæ ${firecrawlCount} Firecrawl products ready to save to Grocery table!`, 'info');
    }
    
    saveToPostgresBtn.style.display = 'inline-block';
  } else {
    recordCounter.style.display = 'none';
    saveToPostgresBtn.style.display = 'none';
  }
}





// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM Content Loaded - Starting initialization');
  
  // Initialize marketplace selection on page load
  updateMarketplaceSelection();
  
  function showRefreshNotification(message, type = 'info') {
    const notificationArea = document.getElementById('refreshNotification');
    const messageDiv = document.getElementById('refreshStatusMessage');
    
    if (notificationArea && messageDiv) {
      messageDiv.textContent = message;
      messageDiv.style.backgroundColor = type === 'success' ? '#d4edda' : 
                                        type === 'error' ? '#f8d7da' : 
                                        type === 'warning' ? '#fff3cd' : '#d1ecf1';
      messageDiv.style.color = type === 'success' ? '#155724' : 
                               type === 'error' ? '#721c24' : 
                               type === 'warning' ? '#856404' : '#0c5460';
      notificationArea.style.display = 'block';
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        notificationArea.style.display = 'none';
      }, 5000);
    }
  }
  
  async function processAllRemainingUrls() {
    if (isProcessing) {
      showNotification('‚ö†Ô∏è Processing already in progress. Please wait.', 'warning');
      return;
    }
    
    isProcessing = true;
    showNotification('üöÄ Starting to process all remaining URLs...', 'info');
    
    try {
      // This function would process all remaining URLs
      // Implementation depends on your specific requirements
      showNotification('‚úÖ All URLs processed successfully!', 'success');
    } catch (error) {
      console.error('Error processing URLs:', error);
      showNotification('‚ùå Error processing URLs: ' + error.message, 'error');
    } finally {
      isProcessing = false;
    }
  }
  
  // Get the data source select element
  const dataSourceSelect = document.getElementById('dataSource');
  
  // Add a small delay to ensure DOM is fully ready
  setTimeout(() => {
    // Initialize marketplace selection state
    updateMarketplaceSelection();
    updateSelectedProductsCount();
    
    // Automatically fetch Lotus URLs when page loads
    console.log('üîÑ Auto-fetching Lotus URLs...');
    fetchLotusUrls();
    
    // Load the default selected data source instead of all products
    const selectedFile = dataSourceSelect.value;
    console.log('Selected file from dropdown:', selectedFile);
    console.log('Dropdown element:', dataSourceSelect);
    console.log('All options:', Array.from(dataSourceSelect.options).map(opt => ({value: opt.value, text: opt.text, selected: opt.selected})));
    
    if (selectedFile === 'all') {
      console.log('Loading all products...');
      console.log('Current allProducts length:', allProducts.length);
      if (allProducts.length === 0) {
        console.log('‚ö†Ô∏è No products in allProducts array, loading All products instead...');
        loadSpecificDataSource('postgresql_direct');
      } else {
        loadAllProducts();
      }
    } else if (selectedFile === 'horeca-openai') {
      console.log('Loading HORECA OpenAI PDF data...');
      loadHorecaOpenAIData();
    } else if (selectedFile === 'lotus_scraper') {
      console.log('Loading Lotus scraper products...');
      loadLotusScraperProducts().then(products => {
        if (products && products.length > 0) {
          FEED = products;
          allProducts = products;
          currentPage = 1;
          totalPages = Math.ceil(products.length / itemsPerPage);
          render();
          console.log(`‚úÖ Loaded ${products.length} Lotus scraper products`);
        } else {
          FEED = [];
          allProducts = [];
          render();
          console.log('‚ÑπÔ∏è No Lotus scraper products found. Start scraping to see products.');
        }
      }).catch(error => {
        console.error('‚ùå Error loading Lotus scraper products:', error);
      });
    } else if (selectedFile === 'flask_app_localhost') {
      console.log('Loading Flask app products from localhost:5000...');
      loadFlaskAppProductsPaginated(1, 10000).then(result => {
        if (result && result.products && result.products.length > 0) {
          FEED = result.products;
          allProducts = result.products;
          currentPage = result.page || 1;
          totalPages = result.total_pages || Math.ceil(result.total / 10000);
          
          // Store Flask app pagination metadata
          window.flaskAppPagination = {
            total: result.total,
            page: result.page,
            limit: result.limit,
            total_pages: result.total_pages,
            has_more: result.has_more
          };
          
          render();
          console.log(`‚úÖ Loaded ${result.products.length} products from Flask app (Page ${result.page} of ${result.total_pages}, Total: ${result.total})`);
        } else {
          FEED = [];
          allProducts = [];
          render();
          console.log('‚ÑπÔ∏è No products found from Flask app.');
        }
      }).catch(error => {
        console.error('‚ùå Error loading Flask app products:', error);
      });
    } else {
      console.log('Loading specific data source:', selectedFile);
      loadSpecificDataSource(selectedFile);
    }
  }, 100);
  
  // Add event listeners for data source controls
  const refreshButton = document.getElementById('refreshData');
  
  dataSourceSelect.addEventListener('change', function() {
    const selectedFile = this.value;
    if (selectedFile === 'all') {
      loadAllProducts();
    } else if (selectedFile === 'show_all_products') {
      // Load all products with lazy loading (100 at a time)
      showAllProducts();
    } else if (selectedFile === 'live') {
      // Switch to live search mode
      const searchInput = document.getElementById('q');
      searchInput.placeholder = 'Search live products on lotuss.com.my...';
      searchInput.value = '';
      FEED = [];
      allProducts = [];
      render();
    } else if (selectedFile === 'live-english') {
      // Switch to live English search mode
      const searchInput = document.getElementById('q');
      searchInput.placeholder = 'Search live products on lotuss.com.my/en...';
      searchInput.value = '';
      FEED = [];
      allProducts = [];
      render();
    } else if (selectedFile === 'horeca-openai') {
      // Load HORECA data from OpenAI PDF processing API
      loadHorecaOpenAIData();
    } else if (selectedFile === 'firecrawl') {
      // Firecrawl data is already loaded in memory, just render it
      render();
    } else if (selectedFile === 'lotus_scraper') {
      // Load Lotus scraper products
      console.log('üîÑ Loading Lotus scraper products...');
      loadLotusScraperProducts().then(products => {
        if (products && products.length > 0) {
          FEED = products;
          allProducts = products;
          currentPage = 1;
          totalPages = Math.ceil(products.length / itemsPerPage);
          render();
          showRefreshNotification(`‚úÖ Loaded ${products.length} Lotus scraper products!`, 'success');
        } else {
          FEED = [];
          allProducts = [];
          render();
          showRefreshNotification('‚ÑπÔ∏è No Lotus scraper products found. Start scraping to see products.', 'info');
        }
      }).catch(error => {
        console.error('‚ùå Error loading Lotus scraper products:', error);
        showRefreshNotification('‚ùå Error loading Lotus scraper products: ' + error.message, 'error');
      });
    } else if (selectedFile === 'flask_app_localhost') {
      // Load Flask app products from localhost:5000 with pagination
      console.log('üåê Loading Flask app products from localhost:5000...');
      loadFlaskAppProductsPaginated(1, 10000).then(result => {
        if (result && result.products && result.products.length > 0) {
          FEED = result.products;
          allProducts = result.products; // For compatibility with existing code
          currentPage = result.page || 1;
          totalPages = result.total_pages || Math.ceil(result.total / 10000);
          
          // Store Flask app pagination metadata
          window.flaskAppPagination = {
            total: result.total,
            page: result.page,
            limit: result.limit,
            total_pages: result.total_pages,
            has_more: result.has_more
          };
          
          
          render();
          showNotification(`‚úÖ Loaded ${result.products.length} products from Flask app (Page ${result.page} of ${result.total_pages}, Total: ${result.total})!`, 'success');
        } else {
          FEED = [];
          allProducts = [];
          render();
          showNotification('‚ÑπÔ∏è No products found from Flask app.', 'info');
        }
      }).catch(error => {
        console.error('‚ùå Error loading Flask app products:', error);
        showNotification('‚ùå Error loading Flask app products: ' + error.message, 'error');
      });
    } else {
      loadSpecificDataSource(selectedFile);
    }
  });
  
  refreshButton.addEventListener('click', function() {
    const selectedFile = dataSourceSelect.value;
    
    // Show loading notification
    showRefreshNotification('üîÑ Refreshing data...', 'loading');
    
    if (selectedFile === 'all') {
      loadAllProducts();
    } else if (selectedFile === 'show_all_products') {
      // Load all products with lazy loading (100 at a time)
      showAllProducts();
    } else if (selectedFile === 'live') {
      const searchInput = document.getElementById('q');
      if (searchInput.value.trim()) {
        searchLiveProducts(searchInput.value);
      } else {
        showRefreshNotification('‚ùå Please enter a search term for live search', 'error');
        return;
      }
    } else if (selectedFile === 'live-english') {
      const searchInput = document.getElementById('q');
      if (searchInput.value.trim()) {
        searchLiveEnglishProducts(searchInput.value);
      } else {
        showRefreshNotification('‚ùå Please enter a search term for live English search', 'error');
        return;
      }
    } else if (selectedFile === 'horeca-openai') {
      loadHorecaOpenAIData();
    } else if (selectedFile === 'lotus_scraper') {
      // Refresh Lotus scraper products
      console.log('üîÑ Refreshing Lotus scraper products...');
      loadLotusScraperProducts().then(products => {
        if (products && products.length > 0) {
          FEED = products;
          allProducts = products;
          currentPage = 1;
          totalPages = Math.ceil(products.length / itemsPerPage);
          render();
          showRefreshNotification(`‚úÖ Refreshed ${products.length} Lotus scraper products!`, 'success');
        } else {
          FEED = [];
          allProducts = [];
          render();
          showRefreshNotification('‚ÑπÔ∏è No Lotus scraper products found. Start scraping to see products.', 'info');
        }
      }).catch(error => {
        console.error('‚ùå Error refreshing Lotus scraper products:', error);
        showRefreshNotification('‚ùå Error refreshing Lotus scraper products: ' + error.message, 'error');
      });
    } else if (selectedFile === 'flask_app_localhost') {
      // Refresh Flask app products with pagination
      console.log('üåê Refreshing Flask app products from localhost:5000...');
      const currentPageToLoad = (window.flaskAppPagination && window.flaskAppPagination.page) || 1;
      const currentLimit = (window.flaskAppPagination && window.flaskAppPagination.limit) || 10000;
      
      loadFlaskAppProductsPaginated(currentPageToLoad, currentLimit).then(result => {
        if (result && result.products && result.products.length > 0) {
          FEED = result.products;
          allProducts = result.products;
          currentPage = result.page || 1;
          totalPages = result.total_pages || Math.ceil(result.total / currentLimit);
          
          // Update Flask app pagination metadata
          window.flaskAppPagination = {
            total: result.total,
            page: result.page,
            limit: result.limit,
            total_pages: result.total_pages,
            has_more: result.has_more
          };
          
          render();
          showNotification(`‚úÖ Refreshed ${result.products.length} products from Flask app (Page ${result.page} of ${result.total_pages}, Total: ${result.total})!`, 'success');
        } else {
          FEED = [];
          allProducts = [];
          render();
          showNotification('‚ÑπÔ∏è No products found from Flask app.', 'info');
        }
      }).catch(error => {
        console.error('‚ùå Error refreshing Flask app products:', error);
        showNotification('‚ùå Error refreshing Flask app products: ' + error.message, 'error');
      });
    } else {
      loadSpecificDataSource(selectedFile);
    }
  });
  
  // Add event listener for Save Lotus's All Products button
  const testAWSWriteBtn = document.getElementById('testAWSWriteBtn');
  testAWSWriteBtn.addEventListener('click', async function() {
    console.log('üíæ Save Lotus\'s All Products button clicked');
    showRefreshNotification('üíæ Loading and saving all AWS Lotus Online products to PostgreSQL...', 'loading');
    
    try {
      // Load AWS products first
      console.log('üì° Loading AWS Lotus Online products...');
      const products = await loadLotusOnlineAWSProducts();
      
      if (products && products.length > 0) {
        console.log(`‚úÖ Loaded ${products.length} AWS products for saving`);
        
        // Now save to PostgreSQL
        console.log('üíæ Starting database save process...');
        const saveSuccess = await saveAWSProductsToPostgreSQL(products);
        
        if (saveSuccess) {
          showRefreshNotification(`‚úÖ Successfully saved ${products.length} AWS Lotus Online products to PostgreSQL database!`, 'success');
        } else {
          showRefreshNotification(`‚ö†Ô∏è Failed to save ${products.length} AWS Lotus Online products to PostgreSQL database`, 'warning');
        }
      } else {
        console.log('‚ùå No products loaded for saving');
        showRefreshNotification('‚ùå Failed to load AWS Lotus Online products', 'error');
      }
    } catch (error) {
      console.error('‚ùå Save error:', error);
      showRefreshNotification(`‚ùå Save failed: ${error.message}`, 'error');
    }
  });
  
  // Add event listeners for product checkboxes
  document.addEventListener('change', function(e) {
    if (e.target.classList.contains('product-checkbox')) {
      const tile = e.target.closest('.tile');
      if (e.target.checked) {
        tile.classList.add('selected');
      } else {
        tile.classList.remove('selected');
      }
      
      // Update compare button visibility and state
      updateCompareButtonState();
    }
  });

  // Initialize price history tracking when page loads
  console.log('üöÄ Initializing price history tracking...');
  if (window.priceHistoryTracker) {
    console.log('‚úÖ Price history tracker found, initializing...');
    window.priceHistoryTracker.initialize();
    
    // Add history buttons to existing product tiles
    setTimeout(() => {
      console.log('üîç Looking for product tiles to add history buttons...');
      const productTiles = document.querySelectorAll('.tile');
      console.log(`üì¶ Found ${productTiles.length} product tiles`);
      
      productTiles.forEach((tile, index) => {
        const titleElement = tile.querySelector('h3.title, .title, h3');
        if (titleElement) {
          const productName = titleElement.textContent.trim();
          console.log(`üîç Tile ${index + 1}: "${productName}"`);
          if (productName && productName !== 'Unknown Product') {
            addPriceHistoryButton(tile, productName);
          }
        } else {
          console.log(`‚ö†Ô∏è Tile ${index + 1}: No title element found`);
        }
      });
    }, 1000);
  } else {
    console.error('‚ùå Price history tracker not found!');
  }
  
  // Add event listeners for compare prices buttons
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('compare-prices-btn')) {
      const productId = e.target.dataset.productId;
      const productName = e.target.dataset.productName;
      compareSingleProduct(productId, productName);
    }
  });
  
  // Add event listeners for tab switching with a delay to ensure DOM is ready
  setTimeout(() => {
    console.log('Adding tab event listeners...');
    const tabs = document.querySelectorAll('.tab');
    console.log('Found tabs:', tabs.length);
    tabs.forEach((tab, index) => {
      console.log(`Tab ${index}:`, tab.textContent, 'data-tab:', tab.dataset.tab);
      tab.addEventListener('click', function() {
        console.log('Tab clicked:', this.textContent, 'data-tab:', this.dataset.tab);
        const tabName = this.dataset.tab;
        console.log('Calling switchTab with:', tabName);
        switchTab(tabName);
      });
    });
    
    // Also add a specific check for the Firecrawl data tab
    const firecrawlTab = document.querySelector('[data-tab="firecrawl-data"]');
    if (firecrawlTab) {
      console.log('‚úÖ Firecrawl data tab found:', firecrawlTab);
    } else {
      console.log('‚ùå Firecrawl data tab not found');
    }
  }, 200);
  
  
  
  
  
  
  
  // Add event listener for search tab original names toggle
  document.getElementById('showOriginalNamesSearch').addEventListener('change', function() {
    render();
  });
  
  // Add event listener for Compare Selected Products button
  const compareButton = document.getElementById('compareSelectedProducts');
  if (compareButton) {
    compareButton.addEventListener('click', compareSelectedProducts);
  }
  
  // Add event listener for Fetch Lotus URLs button
  const fetchLotusUrlsButton = document.getElementById('fetchLotusUrls');
  if (fetchLotusUrlsButton) {
    fetchLotusUrlsButton.addEventListener('click', fetchLotusUrls);
  }
  
  // Add event listener for Test Reusable URLs button
  const testReusableUrlsButton = document.getElementById('testReusableUrls');
  if (testReusableUrlsButton) {
    testReusableUrlsButton.addEventListener('click', async function() {
      console.log('üß™ Testing Reusable URLs loading...');
      try {
        const products = await loadReusableLotusUrls();
        console.log('üß™ Test result:', products);
        if (products && products.length > 0) {
          allProducts = products;
          FEED = allProducts;
          render();
          showNotification(`üß™ Test successful! Loaded ${products.length} reusable URLs`, 'success');
        } else {
          showNotification('üß™ Test failed: No products returned', 'error');
        }
      } catch (error) {
        console.error('üß™ Test error:', error);
        showNotification(`üß™ Test error: ${error.message}`, 'error');
      }
    });
  }
  
  // Add event listener for Lotus URL selector dropdown
  const lotusUrlSelector = document.getElementById('lotusUrlSelector');
  if (lotusUrlSelector) {
    lotusUrlSelector.addEventListener('change', function() {
      const selectedUrl = this.value;
      if (selectedUrl) {
        fetchUrlDetails(selectedUrl);
      }
    });
  }
  
  // Add event listener for Fetch All Products button
  const fetchAllProductsButton = document.getElementById('fetchAllProducts');
  if (fetchAllProductsButton) {
    fetchAllProductsButton.addEventListener('click', fetchAllProducts);
  }
  
  // Add event listener for Process Batch 100 button
  const processBatch100Button = document.getElementById('processBatch100');
  if (processBatch100Button) {
    processBatch100Button.addEventListener('click', () => processBatchOfUrls(100));
  }
  
  // Add event listener for Process All Records button
  const processAllRecordsButton = document.getElementById('processAllRecords');
  if (processAllRecordsButton) {
    processAllRecordsButton.addEventListener('click', processAllRemainingUrls);
  }
  
  // Add event listener for Test Firecrawl Response button
  const testFirecrawlButton = document.getElementById('testFirecrawlResponse');
  if (testFirecrawlButton) {
    testFirecrawlButton.addEventListener('click', testSingleFirecrawlResponse);
  }
  
  // Show All Products is now integrated into the dropdown - no separate button needed
  
  // Add event listener for stop processing button
  const stopProcessingButton = document.getElementById('stopProcessing');
  if (stopProcessingButton) {
    stopProcessingButton.addEventListener('click', () => {
      isProcessing = false;
      showNotification('‚èπÔ∏è Processing stopped by user', 'warning');
      updateDatabaseProgress(currentBatchProgress, totalUrlsToProcess, totalStored, totalSkipped, totalErrors, 'error');
    });
  }
  
  // Add event listener for clear products button
  const clearProductsButton = document.getElementById('clearProducts');
  if (clearProductsButton) {
    clearProductsButton.addEventListener('click', function() {
      console.log('üóëÔ∏è Clear Products button clicked!');
      // Clear the products array
      allProducts = [];
      FEED = [];
      // Clear the grid
      const grid = document.getElementById('grid');
      if (grid) {
        grid.innerHTML = '';
      }
      // Show notification
      showNotification('üóëÔ∏è All products cleared!', 'success');
    });
  }
});
</script>

<!-- ===== Renderer (Google Shopping‚Äìstyle semantics & interactions) ===== -->
<script>
const grid = document.getElementById('grid');
const chips = [...document.querySelectorAll('.chip')];
const q = document.getElementById('q');
let FEED = []; // Global feed variable
let allProducts = []; // Global products variable

// Pagination variables
let currentPage = 1;
const itemsPerPage = 20; // Show 20 products per page
let totalPages = 1;
let filteredItems = [];
let totalRecordsInDatabase = 0; // Total records in database
let currentDataSource = null; // Track current data source for pagination

// Define render function early to avoid reference errors
async function render(){
  console.log('üîç Render function called:');
  console.log('  - FEED length:', FEED.length);
  console.log('  - sourceOn:', sourceOn);
  console.log('  - marketplaceOn:', marketplaceOn);
  console.log('  - Search query:', q.value);
  
  // Update timestamp when rendering
  updateTimestamp();
  
  filteredItems = FEED.filter(p=>passesFilters(p));
  console.log('  - Items after filtering:', filteredItems.length);
  
  // DEBUG: Show filtering details in popup (only if not using special filters)
  const specialPriceFilter = document.getElementById('specialPriceFilter');
  const discountFilter = document.getElementById('discountFilter');
  const isUsingSpecialFilters = (specialPriceFilter && specialPriceFilter.checked) || (discountFilter && discountFilter.checked);
  
  if (FEED.length > 0 && filteredItems.length === 0 && !isUsingSpecialFilters) {
    const debugData = {
      totalProducts: FEED.length,
      filteredProducts: filteredItems.length,
      firstProduct: FEED[0],
      sourceOn: sourceOn,
      marketplaceOn: marketplaceOn,
      searchQuery: q.value
    };
    
    // Create debug popup for filtering
    const debugPopup = document.createElement('div');
    debugPopup.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border: 2px solid #ff6b6b;
      border-radius: 8px;
      padding: 20px;
      max-width: 80%;
      max-height: 80%;
      overflow: auto;
      z-index: 10000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    `;
    
    debugPopup.innerHTML = `
      <h3>üö® DEBUG: Filtering Issue</h3>
      <p><strong>Total Products:</strong> ${debugData.totalProducts}</p>
      <p><strong>Filtered Products:</strong> ${debugData.filteredProducts}</p>
      <p><strong>Search Query:</strong> "${debugData.searchQuery}"</p>
      <h4>Filter States:</h4>
      <pre style="background: #f5f5f5; padding: 10px; border-radius: 4px; overflow: auto; max-height: 150px;">${JSON.stringify({
        sourceOn: debugData.sourceOn,
        marketplaceOn: debugData.marketplaceOn
      }, null, 2)}</pre>
      <h4>First Product:</h4>
      <pre style="background: #f5f5f5; padding: 10px; border-radius: 4px; overflow: auto; max-height: 200px;">${JSON.stringify(debugData.firstProduct, null, 2)}</pre>
      <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 8px 16px; background: #ff6b6b; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
    `;
    
    document.body.appendChild(debugPopup);
  }
  
  // If we're in lazy loading or complete loading mode and have products but they're all filtered out, show them anyway
  if ((currentDataSource === 'all_products_lazy' || currentDataSource === 'all_products_complete') && FEED.length > 0 && filteredItems.length === 0) {
    console.log('‚ö†Ô∏è All products filtered out in loading mode, showing all products');
    filteredItems = FEED;
  }
  
  // Debug: Show first few products and their filter status
  if (FEED.length > 0) {
    console.log('üîç Debug - First 3 products filter status:');
    FEED.slice(0, 3).forEach((product, index) => {
      const passes = passesFilters(product);
      console.log(`  Product ${index + 1}: "${product.title}" - ${passes ? 'PASS' : 'FAIL'}`);
      if (product.offers && product.offers.length > 0) {
        console.log(`    - Source: ${product.offers[0].source}, Marketplace: ${product.offers[0].marketplace}`);
        console.log(`    - Price: ${product.offers[0].price}, Range: ${priceRange[0]}-${priceRange[1]}`);
        console.log(`    - Marketplace enabled: ${marketplaceOn[product.offers[0].marketplace]}`);
      }
    });
  }
  
  // Calculate pagination
  if ((currentDataSource === 'all_products_lazy' || currentDataSource === 'all_products_complete') && allLoadedProducts.length > 0) {
    // For lazy loading or complete loading, use all loaded products to calculate total pages
    totalPages = Math.ceil(allLoadedProducts.length / itemsPerPage);
    console.log(`üìÑ Using allLoadedProducts for pagination: ${allLoadedProducts.length} products = ${totalPages} pages`);
  } else {
    // For other data sources, use filtered items
    totalPages = Math.ceil(filteredItems.length / itemsPerPage);
  }
  currentPage = Math.min(currentPage, totalPages); // Ensure current page is valid
  
  console.log('üìÑ Pagination calculated:', {
    filteredItemsLength: filteredItems.length,
    itemsPerPage,
    totalPages,
    currentPage,
    currentDataSource
  });
  
  // Show all items instead of paginated items
  const itemsToShow = filteredItems; // Show all filtered items
  
  console.log(`üìÑ Showing all ${itemsToShow.length} products (pagination controls available)`);
  
  // Render all products
  if (itemsToShow.length > 0) {
    console.log(`üìÑ Rendering all ${itemsToShow.length} products`);
    const productTiles = await Promise.all(itemsToShow.map(productTile));
    grid.innerHTML = productTiles.join("");
  } else if (filteredItems.length === 0 && FEED.length === 0) {
    // No products loaded at all - show message to load data
    grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;"><h3>No products loaded</h3><p>Please select a data source from the dropdown and click "Refresh Data" to load products.</p></div>';
  } else {
    // Products loaded but filtered out
    grid.innerHTML = '<p>No results. Adjust filters.</p>';
  }
  
  // Render pagination controls
  console.log('üìÑ About to render pagination...');
  renderPagination();
  console.log('üìÑ Pagination rendered');
  
  // Auto-fetch prices for products with price = 0
  setTimeout(() => {
    const zeroPriceProducts = itemsForPage.filter(p =>
      p.offers && p.offers.length > 0 &&
      p.offers[0].price === 0 &&
      p.offers[0].url &&
      p.offers[0].url !== '#'
    );
    
    if (zeroPriceProducts.length > 0) {
      console.log(`üîÑ Found ${zeroPriceProducts.length} products with price = 0, auto-fetching prices...`);
      zeroPriceProducts.forEach((product, index) => {
        setTimeout(() => {
          autoFetchPriceWithFirecrawl(product);
        }, index * 2000); // Stagger requests by 2 seconds each
      });
    }
  }, 1000); // Wait 1 second after render
}

// Fetch paginated data from database
async function fetchPaginatedData(page = 1, limit = 20, dataSource = null) {
  try {
    console.log(`üìÑ Fetching page ${page} with limit ${limit} for data source: ${dataSource}`);
    
    let url = '';
    let params = new URLSearchParams({
      page: page.toString(),
      limit: limit.toString()
    });
    
    // Determine the correct API endpoint based on data source
    if (dataSource === 'postgresql_direct') {
      url = `http://localhost:5005/get-products?${params}`;
    } else if (dataSource === 'postgresql_all_horeca') {
      // For All HORECA, we need to fetch from multiple sources and combine
      return await fetchAllHorecaPaginatedData(page, limit);
    } else if (dataSource === 'postgresql_horeca') {
      url = `http://localhost:5004/products?${params}`;
    } else if (dataSource === 'postgresql_horeca_openai') {
      url = `http://localhost:5004/products?${params}`;
    } else if (dataSource === 'postgresql_lotus_wk34_horeca') {
      url = `http://localhost:5002/products?${params}`;
    } else if (dataSource === 'postgresql_horeca_image_ocr') {
      url = `http://localhost:5003/products?${params}`;
    } else if (dataSource === 'lotus_online_aws') {
      // For AWS Lotus Online, we need to implement pagination in the Lambda response
      return await fetchAWSLotusPaginatedData(page, limit);
    } else {
      // For other sources, use the current session data
      return {
        products: filteredItems.slice((page - 1) * limit, page * limit),
        total: filteredItems.length,
        page: page,
        limit: limit
      };
    }
    
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Handle different response formats
    let products = [];
    let total = 0;
    
    if (data.products) {
      products = data.products;
      total = data.total || data.products.length;
    } else if (Array.isArray(data)) {
      products = data;
      total = data.length;
    } else if (data.data && data.data.products) {
      products = data.data.products;
      total = data.data.total || data.data.products.length;
    }
    
    console.log(`‚úÖ Fetched ${products.length} products (page ${page}/${Math.ceil(total / limit)})`);
    
    return {
      products: products,
      total: total,
      page: page,
      limit: limit
    };
    
  } catch (error) {
    console.error('‚ùå Error fetching paginated data:', error);
    return {
      products: [],
      total: 0,
      page: page,
      limit: limit
    };
  }
}

// Fetch All HORECA paginated data (combines multiple sources)
async function fetchAllHorecaPaginatedData(page = 1, limit = 20) {
  try {
    console.log(`üìÑ Fetching All HORECA page ${page} with limit ${limit}`);
    
    // For simplicity, we'll fetch from the main HORECA source and paginate
    // In a more sophisticated implementation, you'd combine all sources
    const response = await fetch(`http://localhost:5004/products?page=${page}&limit=${limit}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    
    const data = await response.json();
    
    return {
      products: data.products || data.data?.products || [],
      total: data.total || data.data?.total || 0,
      page: page,
      limit: limit
    };
    
  } catch (error) {
    console.error('‚ùå Error fetching All HORECA paginated data:', error);
    return {
      products: [],
      total: 0,
      page: page,
      limit: limit
    };
  }
}

// Fetch AWS Lotus Online paginated data
async function fetchAWSLotusPaginatedData(page = 1, limit = 20) {
  try {
    console.log(`üìÑ Fetching AWS Lotus Online page ${page} with limit ${limit}`);
    
    // For AWS Lambda, we'll fetch all data and paginate client-side
    // In a production system, you'd implement server-side pagination
    const awsLambdaUrl = 'https://tmjzouwtwcerwulahtdbpwjbcq0xefso.lambda-url.ap-southeast-1.on.aws/';
    const response = await fetch(awsLambdaUrl);
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    
    const data = await response.json();
    const allProducts = data.products || [];
    
    // Client-side pagination
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedProducts = allProducts.slice(startIndex, endIndex);
    
    // Convert to our format
    const convertedProducts = paginatedProducts.map((product, index) => {
      const salePrice = parseFloat(product.sale_price.replace('RM', '').trim()) || 0;
      const originalPrice = parseFloat(product.original_price.replace('RM', '').trim()) || 0;
      
      let productName = product.name || 'Unknown Product';
      let brand = 'Lotus Online';
      if (productName && productName.trim() !== '') {
        const firstWord = productName.split(' ')[0];
        if (firstWord && firstWord.length > 1) {
          brand = firstWord;
        }
      }
      
      return {
        id: `aws-lotus-online-${product.uid}`,
        title: productName,
        original_title: productName,
        brand: brand,
        category_path: 'Lotus Online Products',
        price: salePrice,
        original_price: originalPrice,
        image_link: product.image || "https://via.placeholder.com/240x240.png?text=No+Image",
        url: `https://www.lotuss.com.my/en/product/${product.uid}`,
        see_more_link: `https://www.lotuss.com.my/en/product/${product.uid}`,
        product_url: `https://www.lotuss.com.my/en/product/${product.uid}`,
        image_url: product.image,
        offers: [{
          source: 'lotus-online-aws',
          marketplace: 'lotus-online-aws',
          merchant: "Lotus Online",
          price: salePrice,
          currency: 'MYR',
          availability: 'in_stock',
          condition: 'new',
          shipping: 'standard'
        }],
        aggregate: {
          currency: 'MYR',
          lowPrice: salePrice,
          highPrice: originalPrice,
          offerCount: 1
        }
      };
    });
    
    return {
      products: convertedProducts,
      total: allProducts.length,
      page: page,
      limit: limit
    };
    
  } catch (error) {
    console.error('‚ùå Error fetching AWS Lotus paginated data:', error);
    return {
      products: [],
      total: 0,
      page: page,
      limit: limit
    };
  }
}

// Pagination functions
function renderPagination() {
  const paginationContainer = document.getElementById('pagination');
  if (!paginationContainer) {
    console.log('‚ùå Pagination container not found');
    return;
  }
  
  console.log('üîç renderPagination called:', {
    totalPages,
    currentPage,
    currentDataSource,
    allLoadedProductsLength: allLoadedProducts.length,
    totalProductsAvailable,
    filteredItemsLength: filteredItems.length
  });
  
  // Always show pagination for lazy loading or complete loading if we have products
  if ((currentDataSource === 'all_products_lazy' || currentDataSource === 'all_products_complete') && allLoadedProducts.length > 0) {
    // Calculate how many pages we can show with current data
    const currentDataPages = Math.ceil(allLoadedProducts.length / itemsPerPage);
    
    // If we have enough products for multiple pages, show normal pagination
    if (currentDataPages > 1) {
      console.log('üìÑ Showing normal pagination for loading mode (multiple pages available)');
      // Continue to normal pagination rendering below
    }
    // If we only have 1 page but more products are available (only for lazy loading)
    else if (currentDataSource === 'all_products_lazy' && allLoadedProducts.length < totalProductsAvailable) {
      paginationContainer.innerHTML = `
        <div class="pagination">
          <button onclick="loadNextBatch()" class="pagination-btn" style="background: var(--blue); color: white; border-color: var(--blue);">
            Load More Products (${allLoadedProducts.length}/${totalProductsAvailable})
          </button>
          <button onclick="showPaginationForCurrentData()" class="pagination-btn" style="background: var(--green); color: white; border-color: var(--green); margin-left: 10px;">
            Show Pagination (${currentDataPages} pages)
          </button>
          <span class="pagination-info">Showing ${allLoadedProducts.length} of ${totalProductsAvailable} total products</span>
        </div>
      `;
      console.log('üìÑ Showing Load More button');
      return;
    }
    // If we have 1 page and no more products, show simple info
    else {
      paginationContainer.innerHTML = `
        <div class="pagination">
          <span class="pagination-info">Showing all ${allLoadedProducts.length} products</span>
        </div>
      `;
      console.log('üìÑ Showing simple info for lazy loading');
      return;
    }
  }
  
  // Always show pagination controls (even for single page)
  if (totalPages <= 1 && currentDataSource !== 'all_products_lazy') {
    paginationContainer.innerHTML = `
      <div class="pagination">
        <span class="pagination-info">Showing all ${filteredItems.length} products</span>
      </div>
    `;
    console.log('üìÑ Showing pagination info for single page');
    return;
  }
  
  let paginationHTML = '<div class="pagination">';
  
  // Previous button
  if (currentPage > 1) {
    paginationHTML += `<button onclick="goToPage(${currentPage - 1})" class="pagination-btn">‚Äπ Previous</button>`;
  } else {
    paginationHTML += `<button disabled class="pagination-btn disabled">‚Äπ Previous</button>`;
  }
  
  // For lazy loading, use the actual loaded products to calculate pages
  let actualTotalPages = totalPages;
  if (currentDataSource === 'all_products_lazy' && allLoadedProducts.length > 0) {
    actualTotalPages = Math.ceil(allLoadedProducts.length / itemsPerPage);
    console.log(`üìÑ Using actual total pages for lazy loading: ${actualTotalPages} (from ${allLoadedProducts.length} products)`);
  }
  
  // Page numbers - Show more pages (increased from 5 to 50 for better navigation) - CACHE BUST v2
  const maxVisiblePages = 50;
  console.log('üîç Pagination: maxVisiblePages set to', maxVisiblePages, 'totalPages:', actualTotalPages);
  let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
  let endPage = Math.min(actualTotalPages, startPage + maxVisiblePages - 1);
  
  // Adjust start page if we're near the end
  if (endPage - startPage + 1 < maxVisiblePages) {
    startPage = Math.max(1, endPage - maxVisiblePages + 1);
  }
  
  console.log('üîç Pagination: startPage:', startPage, 'endPage:', endPage, 'currentPage:', currentPage);
  
  // First page and ellipsis
  if (startPage > 1) {
    paginationHTML += `<button onclick="goToPage(1)" class="pagination-btn">1</button>`;
    if (startPage > 2) {
      paginationHTML += `<span class="pagination-ellipsis">...</span>`;
    }
  }
  
  // Page numbers
  for (let i = startPage; i <= endPage; i++) {
    if (i === currentPage) {
      paginationHTML += `<button class="pagination-btn active">${i}</button>`;
    } else {
      paginationHTML += `<button onclick="goToPage(${i})" class="pagination-btn">${i}</button>`;
    }
  }
  
  // Last page and ellipsis
  if (endPage < actualTotalPages) {
    if (endPage < actualTotalPages - 1) {
      paginationHTML += `<span class="pagination-ellipsis">...</span>`;
    }
    paginationHTML += `<button onclick="goToPage(${actualTotalPages})" class="pagination-btn">${actualTotalPages}</button>`;
  }
  
  // Next button
  if (currentPage < actualTotalPages) {
    paginationHTML += `<button onclick="goToPage(${currentPage + 1})" class="pagination-btn">Next ‚Ä∫</button>`;
  } else {
    paginationHTML += `<button disabled class="pagination-btn disabled">Next ‚Ä∫</button>`;
  }
  
  // Show all products info (since we're displaying all products)
  const startItem = 1;
  const endItem = filteredItems.length;
  
  // Show appropriate total information based on data source
  let totalToShow, totalLabel;
  if (currentDataSource === 'all_products_lazy') {
    // For lazy loading, show loaded products in pagination info
    totalToShow = allLoadedProducts.length;
    totalLabel = `loaded products`;
    
    // Add total available info if we have it
    if (totalProductsAvailable > 0 && totalProductsAvailable > allLoadedProducts.length) {
      totalLabel += ` (${totalProductsAvailable} total available)`;
    }
  } else if (currentDataSource === 'all_products_complete') {
    // For complete loading, show all products
    totalToShow = allLoadedProducts.length;
    totalLabel = `total products`;
  } else if (totalRecordsInDatabase > 0) {
    totalToShow = totalRecordsInDatabase;
    totalLabel = 'total records in database';
  } else {
    totalToShow = filteredItems.length;
    totalLabel = 'filtered products';
  }
  
  paginationHTML += `<span class="pagination-info">Showing all ${endItem} of ${totalToShow} ${totalLabel}</span>`;
  
  paginationHTML += '</div>';
  paginationContainer.innerHTML = paginationHTML;
}

// Function to load the next batch of products (for the "Load More" button)
async function loadNextBatch() {
  console.log('üì¶ Load More button clicked');
  
  if (currentDataSource !== 'all_products_lazy') {
    console.log('‚ùå Not in lazy loading mode');
    return;
  }
  
  // Calculate the next batch number
  const productsPerBatch = 100;
  const currentBatch = Math.ceil(allLoadedProducts.length / productsPerBatch) + 1;
  
  console.log(`üì¶ Loading next batch: ${currentBatch}`);
  
  // Load the next batch
  await loadAllProductsBatch(currentBatch);
}

// Function to show pagination for current data (for the "Show Pagination" button)
function showPaginationForCurrentData() {
  console.log('üìÑ Show Pagination button clicked');
  
  if (currentDataSource !== 'all_products_lazy') {
    console.log('‚ùå Not in lazy loading mode');
    return;
  }
  
  // Force update FEED with all loaded products
  FEED = allLoadedProducts;
  
  // Recalculate pagination
  totalPages = Math.ceil(allLoadedProducts.length / itemsPerPage);
  currentPage = 1; // Reset to first page
  
  console.log(`üìÑ Forcing pagination display: ${totalPages} pages with ${allLoadedProducts.length} products`);
  
  // Re-render to show pagination
  render();
}

async function goToPage(page) {
  // Handle Flask App pagination (server-side)
  if (currentDataSource === 'flask_app_localhost') {
    console.log(`üåê Flask App pagination: Going to page ${page}`);
    
    // Load the specific page from Flask server
    const currentLimit = (window.flaskAppPagination && window.flaskAppPagination.limit) || 10000;
    
    try {
      const result = await loadFlaskAppProductsPaginated(page, currentLimit);
      if (result && result.products && result.products.length > 0) {
        FEED = result.products;
        allProducts = result.products;
        currentPage = result.page || page;
        totalPages = result.total_pages || Math.ceil(result.total / currentLimit);
        
        // Update Flask app pagination metadata
        window.flaskAppPagination = {
          total: result.total,
          page: result.page,
          limit: result.limit,
          total_pages: result.total_pages,
          has_more: result.has_more
        };
        
        render();
        showNotification(`‚úÖ Loaded page ${page} of ${totalPages} (${result.products.length} products)`, 'success');
      } else {
        showNotification(`‚ùå No products found on page ${page}`, 'error');
      }
    } catch (error) {
      console.error('‚ùå Error loading Flask App page:', error);
      showNotification(`‚ùå Error loading page ${page}: ${error.message}`, 'error');
    }
    return;
  }
  
  // Calculate correct total pages for lazy loading or complete loading
  let actualTotalPages = totalPages;
  if ((currentDataSource === 'all_products_lazy' || currentDataSource === 'all_products_complete') && allLoadedProducts.length > 0) {
    actualTotalPages = Math.ceil(allLoadedProducts.length / itemsPerPage);
  }
  
  console.log(`üìÑ goToPage called: page=${page}, currentPage=${currentPage}, totalPages=${totalPages}, actualTotalPages=${actualTotalPages}`);
  
  if (page >= 1 && page <= actualTotalPages && page !== currentPage) {
    currentPage = page;
    console.log(`üìÑ Updated currentPage to: ${currentPage}`);
    
    // Handle lazy loading for "Show All Products"
    if (currentDataSource === 'all_products_lazy') {
      console.log(`üìÑ Lazy loading: Checking if we need to load next batch for page ${page}`);
      
      // Calculate which batch we need
      const productsPerBatch = 100;
      const pagesPerBatch = Math.ceil(productsPerBatch / itemsPerPage); // 5 pages per batch (100/20)
      const currentBatch = Math.ceil(page / pagesPerBatch);
      
      console.log(`üì¶ Current batch: ${currentBatch}, Pages per batch: ${pagesPerBatch}`);
      console.log(`üì¶ All loaded products: ${allLoadedProducts.length}, Total available: ${totalProductsAvailable}`);
      
      // Calculate how many products we need for this page
      const productsNeededForPage = page * itemsPerPage; // e.g., page 5 needs 5 * 20 = 100 products
      
      console.log(`üì¶ Products needed for page ${page}: ${productsNeededForPage}`);
      
      // Check if we need to load more products
      if (allLoadedProducts.length < productsNeededForPage && allLoadedProducts.length < totalProductsAvailable) {
        console.log(`üì¶ Need to load more products. Required: ${productsNeededForPage}, Have: ${allLoadedProducts.length}`);
        
        // Show loading indicator
        const grid = document.getElementById('grid');
        grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;"><h3>Loading more products...</h3><p>Fetching next batch of products...</p></div>';
        
        // Load the new batch
        await loadAllProductsBatch(currentBatch);
      } else {
        // We already have the data, just render the current page
        console.log(`üì¶ Using existing data for page ${page}`);
        
        // Update FEED with all loaded products for proper pagination
        FEED = allLoadedProducts;
        totalPages = Math.ceil(allLoadedProducts.length / itemsPerPage);
        
        console.log(`üì¶ Updated FEED with ${FEED.length} products, totalPages: ${totalPages}, currentPage: ${currentPage}`);
        
        render();
      }
    }
    // Handle complete loading for "Show All Products" (all products already loaded)
    else if (currentDataSource === 'all_products_complete') {
      console.log(`üìÑ Complete loading: All products already loaded, just rendering page ${page}`);
      
      // Update FEED with all loaded products for proper pagination
      FEED = allLoadedProducts;
      totalPages = Math.ceil(allLoadedProducts.length / itemsPerPage);
      
      console.log(`üì¶ Updated FEED with ${FEED.length} products, totalPages: ${totalPages}, currentPage: ${currentPage}`);
      
      render();
    }
    // If we have a PostgreSQL data source, fetch paginated data
    else if (currentDataSource && (currentDataSource.startsWith('postgresql_') || currentDataSource === 'lotus_online_aws')) {
      console.log(`üìÑ Loading page ${page} from database...`);
      
      // Show loading indicator
      const grid = document.getElementById('grid');
      grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;"><h3>Loading page ' + page + '...</h3><p>Fetching data from database...</p></div>';
      
      try {
        const paginatedData = await fetchPaginatedData(page, itemsPerPage, currentDataSource);
        
        if (paginatedData.products && paginatedData.products.length > 0) {
          // Update global variables
          FEED = paginatedData.products;
          totalRecordsInDatabase = paginatedData.total;
          totalPages = Math.ceil(paginatedData.total / itemsPerPage);
          
          // Apply filters to the new data
          filteredItems = FEED.filter(p => passesFilters(p));
          
          // Render the page
          render();
        } else {
          grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;"><h3>No products found</h3><p>No products available for this page.</p></div>';
        }
      } catch (error) {
        console.error('‚ùå Error loading page:', error);
        grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #d32f2f;"><h3>Error loading page</h3><p>Failed to fetch data from database.</p></div>';
      }
    } else {
      // For non-PostgreSQL sources, use the existing render function
      render();
    }
    
    // Ensure render is always called (fallback)
    console.log(`üìÑ Final render call for page ${currentPage}`);
    render();
    
    // Scroll to top of results
    document.getElementById('grid').scrollIntoView({ behavior: 'smooth' });
  } else {
    console.log(`üìÑ Page ${page} is invalid or same as current page ${currentPage}`);
  }
}

// Search products by name
function searchProducts(query) {
  console.log('üîç searchProducts called with query:', query);
  console.log('üîç Current FEED length:', FEED.length);
  console.log('üîç Current data source:', currentDataSource);
  
  if (!query || query.trim() === '') {
    // If no search query, show all loaded products
    if (currentDataSource === 'all_products_lazy') {
      // For lazy loading, we need to reload the current batch
      console.log('üîç No search query - reloading current batch');
      loadAllProductsBatch(Math.ceil(currentPage / Math.ceil(100 / itemsPerPage)));
    } else {
    FEED = allProducts;
    }
  } else {
    const searchTerm = query.toLowerCase();
    console.log('üîç Searching for:', searchTerm);
    
    if (currentDataSource === 'all_products_lazy') {
      // For lazy loading, search across all sources
      console.log('üîç Searching across all sources for lazy loading...');
      searchAcrossAllSources(searchTerm);
    } else {
      // Search within currently loaded products
      const searchResults = FEED.filter(product => {
        const title = product.title || product.name || '';
        const brand = product.brand || '';
        const category = product.category_path || product.category || '';
        
        return title.toLowerCase().includes(searchTerm) ||
               brand.toLowerCase().includes(searchTerm) ||
               category.toLowerCase().includes(searchTerm);
      });
      
      console.log('üîç Search results:', searchResults.length, 'products found');
      
      // Update FEED with search results
      FEED = searchResults;
  }
  }
  
  currentPage = 1; // Reset to first page when searching
  render();
}

// Enhanced search function for lazy loading - searches across all sources
async function searchAcrossAllSources(searchTerm) {
  console.log('üîç searchAcrossAllSources called with:', searchTerm);
  
  const grid = document.getElementById('grid');
  grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">üîç Searching across all sources for "' + searchTerm + '"...</div>';
  showRefreshNotification('üîç Searching across all sources...', 'loading');
  
  try {
    let allSearchResults = [];
    
    // Search in different sources
    const sources = [
      { name: 'HORECA OpenAI', url: 'http://localhost:5004/products', converter: convertHorecaOpenAIProduct },
      { name: 'HORECA Image OCR', url: 'http://localhost:5003/products', converter: convertHorecaImageOCRProduct },
      { name: 'Lotus WK34 HORECA', url: 'http://localhost:5005/products', converter: convertLotusWK34HorecaProduct }
    ];
    
    // Search PostgreSQL sources
    for (const source of sources) {
      try {
        console.log(`üîç Searching in ${source.name}...`);
        const response = await fetch(source.url);
        if (response.ok) {
          const data = await response.json();
          if (data.success && data.products && data.products.length > 0) {
            const searchResults = data.products.filter(product => {
              const title = product.title || product.name || '';
              const brand = product.brand || '';
              const category = product.category_path || product.category || '';
              
              return title.toLowerCase().includes(searchTerm) ||
                     brand.toLowerCase().includes(searchTerm) ||
                     category.toLowerCase().includes(searchTerm);
            });
            
            if (searchResults.length > 0) {
              const convertedResults = searchResults.map((product, index) => source.converter(product, allSearchResults.length + index));
              allSearchResults = allSearchResults.concat(convertedResults);
              console.log(`‚úÖ Found ${searchResults.length} products in ${source.name}`);
            }
          }
        }
      } catch (error) {
        console.log(`‚ÑπÔ∏è ${source.name} not available for search:`, error.message);
      }
    }
    
    // Special handling for Lotus Scraper (different API format)
    try {
      console.log('üîç Searching Lotus Scraper products...');
      const response = await fetch('http://localhost:5000/api/products?limit=10000');
      if (response.ok) {
        const data = await response.json();
        if (data.products && data.products.length > 0) {
          const searchResults = data.products.filter(product => {
            const title = product.title || product.name || '';
            const brand = product.brand || '';
            const category = product.category_path || product.category || '';
            
            return title.toLowerCase().includes(searchTerm) ||
                   brand.toLowerCase().includes(searchTerm) ||
                   category.toLowerCase().includes(searchTerm);
          });
          
          if (searchResults.length > 0) {
            const convertedResults = searchResults.map((product, index) => convertLotusScraperProduct(product, allSearchResults.length + index));
            allSearchResults = allSearchResults.concat(convertedResults);
            console.log(`‚úÖ Found ${searchResults.length} products in Lotus Scraper`);
          }
        }
      }
    } catch (error) {
      console.log('‚ÑπÔ∏è Lotus Scraper not available for search:', error.message);
    }
    
    // Search AWS Lotus Online products
    try {
      console.log('üîç Searching AWS Lotus Online products...');
      const awsProducts = await loadLotusOnlineAWSProducts();
      if (awsProducts && awsProducts.length > 0) {
        const awsSearchResults = awsProducts.filter(product => {
          const title = product.title || product.name || '';
          const brand = product.brand || '';
          const category = product.category_path || product.category || '';
          
          return title.toLowerCase().includes(searchTerm) ||
                 brand.toLowerCase().includes(searchTerm) ||
                 category.toLowerCase().includes(searchTerm);
        });
        
        if (awsSearchResults.length > 0) {
          allSearchResults = allSearchResults.concat(awsSearchResults);
          console.log(`‚úÖ Found ${awsSearchResults.length} products in AWS Lotus Online`);
        }
      }
    } catch (error) {
      console.log('‚ÑπÔ∏è AWS Lotus Online not available for search:', error.message);
    }
    
    // Search Flask App products
    try {
      console.log('üîç Searching Flask App products...');
      const flaskAppResult = await loadFlaskAppProductsPaginated(1, 10000); // Load more for search
      if (flaskAppResult && flaskAppResult.products && flaskAppResult.products.length > 0) {
        const flaskAppSearchResults = flaskAppResult.products.filter(product => {
          const title = product.title || product.name || '';
          const brand = product.brand || '';
          const category = product.category_path || product.category || '';
          
          return title.toLowerCase().includes(searchTerm) ||
                 brand.toLowerCase().includes(searchTerm) ||
                 category.toLowerCase().includes(searchTerm);
        });
        
        if (flaskAppSearchResults.length > 0) {
          allSearchResults = allSearchResults.concat(flaskAppSearchResults);
          console.log(`‚úÖ Found ${flaskAppSearchResults.length} products in Flask App`);
        }
      }
    } catch (error) {
      console.log('‚ÑπÔ∏è Flask App not available for search:', error.message);
    }
    
    console.log(`üîç Total search results: ${allSearchResults.length} products found`);
    
    if (allSearchResults.length > 0) {
      // Update FEED with search results
      FEED = allSearchResults;
      
      // Update pagination
      currentPage = 1;
      totalPages = Math.ceil(allSearchResults.length / itemsPerPage);
      
      // Render the results
      render();
      
      showRefreshNotification(`‚úÖ Found ${allSearchResults.length} products matching "${searchTerm}"!`, 'success');
    } else {
      grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">‚ùå No products found matching "' + searchTerm + '" in any data source.</div>';
      showRefreshNotification('‚ùå No products found matching your search', 'error');
    }
    
  } catch (error) {
    console.error('‚ùå Error searching across sources:', error);
    grid.innerHTML = '<div style="text-align: center; padding: 40px; color: #c62828;">‚ùå Error searching across sources: ' + error.message + '</div>';
    showRefreshNotification('‚ùå Error searching across sources: ' + error.message, 'error');
  }
}
let sourceOn = { lotuss:true, shopee:false, lazada:false, lazada:false, grab:false, foodpanda:false, aeon:false, horeca:true, "horeca-openai":true, "horeca-image-ocr":true, "lotus-wk34-horeca":true, "lotus-online-aws":true, "lotus_reusable":true, "lotus-scraper":true, "flask-app":true };
let priceRange = [0, 999999];
let stockOn = { "in-stock": true, "out-of-stock": true };
let marketplaceOn = { lotuss:true, shopee:false, lazada:false, grab:false, foodpanda:false, aeon:false, horeca:true, "horeca-openai":true, lotus:true, "lotus-online-aws":true, "lotus-scraper":true, "flask-app":true };

// Chip functionality removed - using only sidebar marketplace filters

document.querySelectorAll('.fx').forEach(cb=>{
  cb.addEventListener('change', ()=>{
    stockOn[cb.dataset.fx] = cb.checked; 
    currentPage = 1; // Reset to first page when filtering
    render();
  });
});
document.querySelectorAll('.fxp').forEach(rb=>{
  rb.addEventListener('change', ()=>{
    priceRange = [Number(rb.dataset.min), Number(rb.dataset.max)];
    currentPage = 1; // Reset to first page when filtering
    render();
  });
});

// Marketplace filter event listeners
document.querySelectorAll('.marketplace-filter').forEach(cb=>{
  cb.addEventListener('change', ()=>{
    marketplaceOn[cb.dataset.marketplace] = cb.checked;
    sourceOn[cb.dataset.marketplace] = cb.checked; // Also update sourceOn to keep them in sync
    console.log(`üîÑ Marketplace filter changed: ${cb.dataset.marketplace} = ${cb.checked}`);
    console.log('  - Updated sourceOn:', sourceOn);
    console.log('  - Updated marketplaceOn:', marketplaceOn);
    currentPage = 1; // Reset to first page when filtering
    render();
  });
});
q.addEventListener('input', debounce(() => {
  const selectedSource = document.getElementById('dataSource').value;
  if (selectedSource === 'show_all_products') {
    // For "Show All Products" lazy loading, search within loaded products
    console.log('üîç Searching in lazy loaded products...');
    searchProducts(q.value);
  } else if (selectedSource === 'horeca-openai') {
    // For HORECA OpenAI, we'll do local search on already loaded data
    searchProducts(q.value);
  } else if (selectedSource === 'live') {
    // For live search, we'll do local search on already loaded data
    searchProducts(q.value);
  } else if (selectedSource === 'lotus_scraper') {
    // For Lotus scraper, we'll do local search on already loaded data
    searchProducts(q.value);
  } else if (selectedSource === 'flask_app_localhost') {
    // For Flask app, we'll do local search on already loaded data
    searchProducts(q.value);
  } else {
    // For other data sources, use local search
    searchProducts(q.value);
  }
}, 150));

function debounce(fn, ms){ let t; return (...a)=>{clearTimeout(t); t=setTimeout(()=>fn(...a), ms)} }

// Debug function to check current state
function debugCurrentState() {
  console.log('=== CURRENT STATE DEBUG ===');
  console.log('FEED length:', FEED.length);
  console.log('allProducts length:', allProducts.length);
  console.log('sourceOn:', sourceOn);
  console.log('marketplaceOn:', marketplaceOn);
  console.log('stockOn:', stockOn);
  console.log('priceRange:', priceRange);
  
  // Check marketplace checkboxes state
  const checkboxes = document.querySelectorAll('.marketplace-filter');
  console.log('Checkbox states:');
  checkboxes.forEach(cb => {
    console.log(`  ${cb.dataset.marketplace}: ${cb.checked}`);
  });
  
  // Test filtering on first few products
  if (FEED.length > 0) {
    console.log('Testing filtering on first 3 products:');
    FEED.slice(0, 3).forEach((product, index) => {
      const passes = passesFilters(product);
      console.log(`  Product ${index + 1} (${product.title}): ${passes ? 'PASS' : 'FAIL'}`);
      if (product.offers) {
        console.log(`    Offers:`, product.offers.map(o => `${o.source}/${o.marketplace}`));
      }
    });
  }
  
  // Count products by source
  const sourceCounts = {};
  FEED.forEach(product => {
    if (product.offers) {
      product.offers.forEach(offer => {
        sourceCounts[offer.source] = (sourceCounts[offer.source] || 0) + 1;
      });
    }
  });
  console.log('Products by source:', sourceCounts);
}

// Debug function specifically for HORECA_WK34 products
function debugHorecaWk34Products() {
  console.log('=== HORECA_WK34 DEBUG ===');
  console.log('Total products in FEED:', FEED.length);
  
  // Check for HORECA_WK34 products
  const horecaProducts = FEED.filter(product => {
    return product.id?.includes('horeca-wk34') ||
           product.id?.includes('postgres-horeca') ||
           product.id?.includes('horeca_wk34') ||
           product.source === 'HORECA_WK34_OpenAI_Processing' ||
           product.flyer_path?.includes('HORECA_WK34_OpenAI_Processing') ||
           product.category_path?.includes('HORECA') ||
           product.brand?.includes('HORECA') ||
           product.category?.includes('HORECA') ||
           product.subcategory?.includes('HORECA');
  });
  
  console.log('HORECA_WK34 products found:', horecaProducts.length);
  
  if (horecaProducts.length > 0) {
    console.log('Sample HORECA_WK34 products:');
    horecaProducts.slice(0, 5).forEach((product, index) => {
      console.log(`  ${index + 1}. ${product.title}`, {
        id: product.id,
        source: product.source,
        flyer_path: product.flyer_path,
        category_path: product.category_path,
        brand: product.brand
      });
    });
  } else {
    console.log('‚ùå No HORECA_WK34 products found in current data');
    console.log('Available product sources:');
    const sources = [...new Set(FEED.map(p => p.source).filter(Boolean))];
    console.log('Sources:', sources);
    
    console.log('Available flyer_paths:');
    const flyerPaths = [...new Set(FEED.map(p => p.flyer_path).filter(Boolean))];
    console.log('Flyer paths:', flyerPaths);
    
    console.log('Available categories:');
    const categories = [...new Set(FEED.map(p => p.category_path).filter(Boolean))];
    console.log('Categories:', categories.slice(0, 10));
  }
}

function passesFilters(product){
  // Filter out products with "Error" in their names or malformed data
  const productName = (product.title || product.name || product.label || product.product_name || '').toLowerCase();
  const brandName = (product.brand || '').toLowerCase();
  
  if (productName.includes('error') || 
      brandName.includes('error') || 
      productName === 'product product-0' ||
      productName === 'unknown product' ||
      productName.trim() === '' ||
      product.id === 'error' ||
      product.id === 'product-0') {
    return false; // Ignore these products completely
  }
  
  // Filter out products with RM 0.00 price
  const productPrice = parseFloat(product.price || product.sale_price || product.original_price || 0);
  if (productPrice === 0) {
    return false; // Hide products with zero price
  }
  
  const needle = q.value.trim().toLowerCase();
  if (needle){
    const hay = [product.title || product.name, product.brand, product.gtin].join(' ').toLowerCase();
    if (!hay.includes(needle)) return false;
  }
  
  // Apply special price and discount filters
  const specialPriceFilter = document.getElementById('specialPriceFilter');
  const discountFilter = document.getElementById('discountFilter');
  
  if (specialPriceFilter && specialPriceFilter.checked) {
    // Check if product has promotion_badge (not null/empty)
    const hasSpecialPrice = product.promotion_badge && 
                           product.promotion_badge.trim() !== '' && 
                           product.promotion_badge !== null;
    if (!hasSpecialPrice) return false;
  }
  
  if (discountFilter && discountFilter.checked) {
    // Check if product has discount indicators
    const hasDiscount = product.is_discounted || 
                       product.discount_percentage > 0 ||
                       (product.original_price && product.price && product.original_price > product.price) ||
                       product.promotion_badge?.toLowerCase().includes('off') ||
                       product.promotion_badge?.toLowerCase().includes('discount');
    if (!hasDiscount) return false;
  }
  
  // Check if this is a Flask API product (has numeric ID and no offers array)
  const isFlaskProduct = product.id && typeof product.id === 'number' && !product.offers;
  
  // Check if this is a WK34 HORECA product
  const isWK34HorecaProduct = product.offers && product.offers.some(o => o.source === 'wk34-horeca' && o.marketplace === 'wk34-horeca');
  
  if (isFlaskProduct) {
    // Handle Flask API products differently
    const productPrice = parseFloat(product.sale_price || product.original_price || 0);
    const passesPrice = productPrice >= priceRange[0] && productPrice <= priceRange[1];
    
    // Flask products should pass if flask-app source is enabled and price is in range
    const passesSource = sourceOn['flask-app'];
    const passesMarketplace = marketplaceOn['flask-app'];
    
    return passesSource && passesMarketplace && passesPrice;
  }
  
  if (isWK34HorecaProduct) {
    // Handle WK34 HORECA products differently
    const productPrice = parseFloat(product.price || 0);
    const passesPrice = productPrice >= priceRange[0] && productPrice <= priceRange[1];
    
    // WK34 HORECA products should pass if horeca source is enabled and price is in range
    const passesSource = sourceOn['horeca'];
    const passesMarketplace = marketplaceOn['horeca'];
    
    return passesSource && passesMarketplace && passesPrice;
  }
  
  // Debug logging for Firecrawl products
  if (product.id && String(product.id).includes('lotus-')) {
    console.log(`üîç Filtering Firecrawl product: ${product.title}`);
    console.log(`   - Search query: "${needle}"`);
    console.log(`   - Product offers:`, product.offers);
    console.log(`   - sourceOn:`, sourceOn);
    console.log(`   - marketplaceOn:`, marketplaceOn);
    console.log(`   - stockOn:`, stockOn);
    console.log(`   - priceRange:`, priceRange);
    console.log(`   - Filter variables defined:`, {
      sourceOnDefined: typeof sourceOn !== 'undefined',
      marketplaceOnDefined: typeof marketplaceOn !== 'undefined',
      stockOnDefined: typeof stockOn !== 'undefined',
      priceRangeDefined: typeof priceRange !== 'undefined'
    });
  }
  
  // At least one visible offer after source + marketplace + stock + price filters
  const visOffers = product.offers ? product.offers.filter(o => {
    const passesSource = sourceOn[o.source];
    const passesMarketplace = marketplaceOn[o.marketplace];
    const passesPrice = o.price >= priceRange[0] && o.price <= priceRange[1];
    
    if (product.id && String(product.id).includes('lotus-')) {
      console.log(`   - Offer ${o.source}/${o.marketplace}: source=${passesSource}, marketplace=${passesMarketplace}, price=${passesPrice} (${o.price})`);
    }
    
    return passesSource && passesMarketplace && passesPrice;
  }) : [];
  
  if (product.id && String(product.id).includes('lotus-')) {
    console.log(`   - Visible offers: ${visOffers.length}`);
    console.log(`   - Result: ${visOffers.length > 0 ? 'PASS' : 'FAIL'}`);
  }
  
  return visOffers.length > 0;
}

function starRow(rating=0){
  const full = Math.round(rating); // simple visual
  let html = '<span class="stars" aria-label="' + rating + ' stars">';
  for(let i=0;i<5;i++){ html += '<span class="star" style="opacity:' + (i<full?1:.25) + '"></span>'; }
  html += '</span>';
  return html;
}

function money(x, cur){ return 'RM ' + (x || 0).toFixed(2); }

function offerRow(o){
  const linkText = o.url && o.url !== '#' ? 'Go to store' : 'View details';
  const linkUrl = o.url && o.url !== '#' ? o.url : '#';
  
  return '<tr class="offer" data-source="' + o.source + '">' +
    '<td><strong>' + o.merchant + '</strong>' + (o.shop_id ? ' <small>(shop ' + o.shop_id + ')</small>' : '') + '</td>' +
    '<td>' + money(o.price,o.currency) + '</td>' +
    '<td>' + (o.promo ? '<span class="badge">' + o.promo + '</span>' : '') + '</td>' +
    '<td class="go"><a href="' + linkUrl + '" target="_blank" rel="noopener" style="text-decoration: none;">üîó ' + linkText + '</a></td>' +
    '</tr>';
}

async function productTile(p){
  // Check if this is a Flask API product (has numeric ID and no offers array)
  const isFlaskProduct = p.id && typeof p.id === 'number' && !p.offers;
  
  let vis, low, high, first;
  
  if (isFlaskProduct) {
    // Handle Flask API products
    const productPrice = parseFloat(p.sale_price || p.original_price || 0);
    if (productPrice >= priceRange[0] && productPrice <= priceRange[1]) {
      vis = [{ price: productPrice, marketplace: 'flask-app', source: 'flask-app' }];
      low = high = first = productPrice;
    } else {
      vis = [];
      low = high = first = 0;
    }
  } else {
    // Handle products with offers array
    vis = p.offers
        .filter(o => marketplaceOn[o.marketplace] && o.price>=priceRange[0] && o.price<=priceRange[1])
        .sort((a,b)=>a.price-b.price);

    low = Math.min(...vis.map(o=>o.price));
    high = Math.max(...vis.map(o=>o.price));
    first = vis[0];
  }

  // Product microdata
  const micro = '';

  let html = '<article class="tile" itemscope itemtype="https://schema.org/Product" data-product-id="' + p.id + '">';
  html += '<div><input type="checkbox" class="product-checkbox" data-product-id="' + p.id + '" data-product-name="' + (p.label || p.title || p.name) + '" onchange="updateSelectedProductsCount()"></div>';
  
  
  html += '<div>';
  const showOriginalSearch = document.getElementById('showOriginalNamesSearch').checked;
  let displayTitle = showOriginalSearch && p.original_title ? p.original_title : (p.label || p.title || p.name || p.product_name);
  let subtitle = showOriginalSearch && p.original_title ? (p.label || p.title || p.name || p.product_name) : (p.original_title || '');
  
  // Remove number prefixes from both displayTitle and subtitle
  if (displayTitle) {
    displayTitle = displayTitle.replace(/^\d+\.\s*/, '').trim();
  }
  if (subtitle) {
    subtitle = subtitle.replace(/^\d+\.\s*/, '').trim();
  }
  
  // Validate and clean product name to prevent "Error Product"
  if (!displayTitle || displayTitle.trim() === '' || displayTitle === 'Error Product') {
    // Try to generate a meaningful name from available data
    const brand = p.brand || 'Product';
    const category = p.category_path || p.category || 'Item';
    const id = p.id || '';
    
    if (brand && brand !== 'Unknown' && brand !== 'Error') {
      displayTitle = `${brand} ${category}`;
    } else if (category && category !== 'General' && category !== 'Error') {
      displayTitle = category;
    } else if (id) {
      displayTitle = `Product ${id}`;
    } else {
      displayTitle = 'Unknown Product';
    }
  }
  
  // Apply English translation to product names only if valid
  if (displayTitle && !showOriginalSearch && displayTitle !== 'Error Product' && displayTitle !== 'Unknown Product') {
    try {
      const translated = await translateProductName(displayTitle);
      if (translated && translated !== 'Error Product' && translated.trim() !== '') {
        displayTitle = translated;
      }
    } catch (error) {
      console.log(`Translation failed for "${displayTitle}", keeping original`);
    }
  }
  
  if (subtitle && !showOriginalSearch && subtitle !== 'Error Product' && subtitle !== 'Unknown Product') {
    try {
      const translated = await translateProductName(subtitle);
      if (translated && translated !== 'Error Product' && translated.trim() !== '') {
        subtitle = translated;
      }
    } catch (error) {
      console.log(`Translation failed for subtitle "${subtitle}", keeping original`);
    }
  }
  
  // Clean up display title - remove image URLs and other unwanted content
  if (displayTitle && (
    displayTitle.includes('/jcr:content/') || 
    displayTitle.includes('/renditions/') ||
    displayTitle.includes('.jpg') ||
    displayTitle.includes('.png') ||
    displayTitle.includes('.jpeg') ||
    displayTitle.includes('/new/') ||
    displayTitle.includes('/images/')
  )) {
    // If title contains image path, try to extract product name from URL
    const urlMatch = p.url ? p.url.match(/\/product\/(\d+)/) : null;
    if (urlMatch) {
      displayTitle = `Lotus Product ${urlMatch[1]}`;
    } else {
      displayTitle = 'Unknown Product';
    }
  }
  
  html += '<h3 class="title" itemprop="name" style="display: flex; align-items: center; gap: 8px;">';
  
  // Add product image next to title if available
  let imageUrl = p.image_link || p.image_url;
  
  // For HORECA products, ensure we always have an image
  const isHorecaProduct = p.brand && (p.brand.includes('HORECA') || p.source === 'horeca' || p.source === 'horeca-openai' || p.source === 'horeca-image-ocr');
  if (isHorecaProduct && (!imageUrl || imageUrl === 'https://via.placeholder.com/240x240.png?text=No+Image')) {
    // Generate a unique placeholder image for HORECA products
    imageUrl = `https://picsum.photos/240/240?random=${p.id || Math.random()}`;
  }
  
  if (imageUrl && imageUrl !== 'https://via.placeholder.com/240x240.png?text=No+Image') {
    html += '<div style="display: flex; flex-direction: column; align-items: center; margin-right: 15px;">';
    html += '<img src="' + imageUrl + '" alt="' + displayTitle + '" style="width: 150px; height: 150px; object-fit: cover; border-radius: 8px; border: 2px solid #e0e0e0; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.1);" onerror="this.style.display=\'none\'" onclick="window.open(\'' + imageUrl + '\', \'_blank\')">';
    html += '<div style="margin-top: 4px; font-size: 10px; color: #666; text-align: center;">Click to view full size</div>';
    if (isHorecaProduct) {
      html += '<div style="margin-top: 2px; font-size: 9px; color: #6f42c1; text-align: center; font-weight: bold;">HORECA</div>';
    }
    html += '</div>';
  } else {
    // Show placeholder for products without images
    html += '<div style="display: flex; flex-direction: column; align-items: center; margin-right: 15px;">';
    html += '<div style="width: 150px; height: 150px; background: #f5f5f5; border: 2px dashed #ccc; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #999; font-size: 12px; text-align: center;">No Image<br/>Available</div>';
    if (isHorecaProduct) {
      html += '<div style="margin-top: 2px; font-size: 9px; color: #6f42c1; text-align: center; font-weight: bold;">HORECA</div>';
    }
    html += '</div>';
  }
  
  html += '<span style="font-size: 10px; font-weight: bold;">' + displayTitle + '</span>';
  
  // Add clickable link icon if product URL is available
  let productUrl = null;
  
  // Debug logging for reusable Lotus URLs
  if (p.id && String(p.id).includes('reusable-lotus')) {
    console.log(`üîç Debug reusable Lotus product: ${p.title}`);
    console.log(`üîç vis.length: ${vis.length}`);
    console.log(`üîç p.offers:`, p.offers);
    console.log(`üîç p.url: ${p.url}`);
    console.log(`üîç p.see_more_link: ${p.see_more_link}`);
    console.log(`üîç p.product_url: ${p.product_url}`);
  }
  
  if (vis.length > 0 && vis[0].url && vis[0].url !== '#') {
    productUrl = vis[0].url;
    console.log(`üîó Found offer URL for ${p.title || p.name}: ${vis[0].url}`);
    // Hyperlink removed as requested
  } else if (p.url && p.url !== '#') {
    // For Firecrawl products or products with direct URLs
    productUrl = p.url;
    console.log(`üîó Found direct URL for ${p.title || p.name}: ${p.url}`);
    // Hyperlink removed as requested
  } else if (p.see_more_link && p.see_more_link !== '#' && !isImageUrl(p.see_more_link)) {
    // For PostgreSQL products with see_more_link (but not image URLs)
    productUrl = p.see_more_link;
    console.log(`üîó Found see_more_link for ${p.title || p.name}: ${p.see_more_link}`);
    // Hyperlink removed as requested
  } else if (p.product_url && p.product_url !== '#') {
    // For reusable Lotus URLs with product_url field
    productUrl = p.product_url;
    console.log(`üîó Found product_url for ${p.title || p.name}: ${p.product_url}`);
    // Hyperlink removed as requested
  } else {
    // No URL found - display product name without error
    console.log(`‚ÑπÔ∏è Product "${p.title || p.name}" has no valid URL - displaying without link`);
  }
  
  
  // Show HTML page content inline for zero-price products
  // Removed HTML content display div for zero-price products
  
  html += '</h3>';
  if (subtitle && subtitle !== displayTitle) {
    html += '<div class="meta" style="font-size: 11px; color: var(--muted); margin-bottom: 4px;">' + subtitle + '</div>';
  }
  html += '<div class="meta">';
  
  // Clean up brand name
  let brandName = p.brand || 'Unknown Brand';
  if (brandName === 'Error' || brandName === 'Unknown' || brandName.trim() === '') {
    brandName = 'Unknown Brand';
  }
  
  // Clean up category name
  let categoryName = p.category_path || p.category || 'Grocery';
  if (categoryName === 'Error' || categoryName === 'General' || categoryName.trim() === '') {
    categoryName = 'Grocery';
  }
  
  html += '<span itemprop="brand">' + brandName + '</span> ‚Ä¢ ';
  html += '<span>' + categoryName + '</span>';
  if (p.lotus_data && p.lotus_data.size) {
    html += ' ‚Ä¢ <span>Size: ' + p.lotus_data.size + '</span>';
  }
  if (p.lotus_data && p.lotus_data.packaging) {
    html += ' ‚Ä¢ <span>Pack: ' + p.lotus_data.packaging + '</span>';
  }
  html += '</div>';
  
  // Add clickable icon underneath product or show no-link indicator
  if (productUrl) {
    html += '<div style="margin-top: 8px; text-align: center;">';
    html += '<a href="' + productUrl + '" target="_blank" rel="noopener" style="display: inline-block; padding: 8px; background: #4285f4; color: white; border-radius: 50%; text-decoration: none; font-size: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: all 0.2s ease;" onmouseover="this.style.background=\'#1a73e8\'; this.style.transform=\'scale(1.1)\'" onmouseout="this.style.background=\'#4285f4\'; this.style.transform=\'scale(1)\'">üîó</a>';
    html += '</div>';
  } else {
    // Show indicator for products without URLs
    html += '<div style="margin-top: 8px; text-align: center;">';
    html += '<span style="display: inline-block; padding: 8px; background: #6c757d; color: white; border-radius: 50%; font-size: 16px; opacity: 0.6;" title="No URL available">üìÑ</span>';
    html += '<div style="font-size: 10px; color: #6c757d; margin-top: 2px;">No link</div>';
    html += '</div>';
  }
  
  // Show additional product details for Firecrawl products
  if (p.source === 'Lotus Firecrawl') {
    html += '<div class="product-details" style="margin-top: 8px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 11px;">';
    html += '<div style="color: #666; margin-bottom: 4px;"><strong>Product Details:</strong></div>';
    
    // Show product ID
    const urlMatch = p.url.match(/\/product\/(\d+)/);
    if (urlMatch) {
      html += '<div style="margin-bottom: 2px;">üì¶ Product ID: ' + urlMatch[1] + '</div>';
    }
    
    // Show scraped date
    if (p.scrapedAt) {
      const date = new Date(p.scrapedAt).toLocaleString();
      html += '<div style="margin-bottom: 2px;">üïí Scraped: ' + date + '</div>';
    }
    
    // Show product name if available
    if (p.title && p.title.length > 3 && !p.title.includes('/jcr:content/') && !p.title.includes('.jpg')) {
      html += '<div style="margin-bottom: 2px;">üè∑Ô∏è Product: ' + p.title + '</div>';
    }
    
    // Show description if available (but filter out markdown image syntax)
    if (p.description && p.description.length > 10 && !p.description.includes('![product_image]') && !p.description.includes('![image]')) {
      html += '<div style="margin-bottom: 2px;">üìù ' + p.description.substring(0, 100) + (p.description.length > 100 ? '...' : '') + '</div>';
    }
    
    // Show image status
    if (p.image_link) {
      html += '<div style="margin-bottom: 2px;">üñºÔ∏è Image: <a href="' + p.image_link + '" target="_blank" style="color: #4285f4;">View Image</a></div>';
    }
    
    // Show product URL if available (but not image URLs)
    if (productUrl && !isImageUrl(productUrl)) {
      html += '<div style="margin-bottom: 2px;">üîó URL: <a href="' + productUrl + '" target="_blank" style="color: #4285f4; word-break: break-all;">' + productUrl + '</a></div>';
    }
    
    html += '</div>';
  }
  html += '<div class="badges">';
  html += p.category_path ? p.category_path.split(">").map(s=>'<span class="badge">'+s.trim()+'</span>').join("") : '<span class="badge">' + (p.category || 'Grocery') + '</span>';
  html += p.rating ? '<span class="badge" title="'+p.rating_count+' ratings">'+starRow(p.rating)+'</span>' : "";
  if (p.live_data && p.live_data.source_url) {
    html += '<span class="badge" style="background: #e8f5e8; color: #2e7d32;">Live Search</span>';
  } else if (p.source === 'Lotus Firecrawl') {
    html += '<span class="badge" style="background: #fff3cd; color: #856404;">üî• Firecrawl</span>';
  } else {
    html += '<span class="badge shipping">Free shipping eligible</span>';
  }
  html += '</div>';
  
  // Product URL display removed as requested
  
  html += '<div class="price-line">';
  html += '<div class="price" aria-label="Current best price">';
  
  if (isFlaskProduct) {
    // Handle Flask API products
    const salePrice = parseFloat(p.sale_price || 0);
    const originalPrice = parseFloat(p.original_price || 0);
    const isHorecaProduct = p.category_path === 'HORECA' || p.category === 'HORECA' || p.brand === 'HORECA';
    
    // Debug logging for HORECA products
    if (isHorecaProduct) {
      console.log('üè¢ HORECA Product Debug:', {
        title: p.title || p.name,
        category_path: p.category_path,
        category: p.category,
        brand: p.brand,
        sale_price: salePrice,
        original_price: originalPrice,
        isFlaskProduct: isFlaskProduct
      });
    }
    
    // For HORECA products with RM 0.00 sale price, show original price instead
    let currentPrice = salePrice || originalPrice;
    let showDiscount = false;
    
    if (isHorecaProduct && salePrice === 0 && originalPrice > 0) {
      currentPrice = originalPrice;
      showDiscount = false; // Don't show discount for HORECA products with 0 sale price
      console.log('üè¢ HORECA Price Override:', { from: salePrice, to: currentPrice });
    } else if (originalPrice > 0 && salePrice > 0 && originalPrice > salePrice) {
      showDiscount = true; // Show discount for normal products with actual discounts
    }
    
    // Show price with or without discount
    if (showDiscount) {
      const savings = originalPrice - salePrice;
      const discountPercentage = Math.round((savings / originalPrice) * 100);
      html += money(currentPrice, 'MYR') + ' <span style="color: #28a745; font-size: 0.8em; margin-left: 4px; font-weight: bold;">(' + discountPercentage + '% OFF)</span>';
      html += ' <span style="text-decoration: line-through; color: #999; font-size: 0.9em; margin-left: 8px;">' + money(originalPrice, 'MYR') + '</span>';
      html += ' <span style="color: #28a745; font-size: 0.8em; margin-left: 4px; font-weight: bold;">(Save RM ' + savings.toFixed(2) + ')</span>';
    } else {
      html += money(currentPrice, 'MYR');
    }
  } else {
    // Handle products with offers
    const currentPrice = vis.length ? first.price : (p.aggregate?.lowPrice || 0);
    const currentCurrency = vis.length ? first.currency : (p.aggregate?.currency || 'MYR');
    
    // Debug logging for non-Flask HORECA products
    const isHorecaProduct = p.category_path === 'HORECA' || p.category === 'HORECA' || p.brand === 'HORECA';
    if (isHorecaProduct) {
      console.log('üè¢ Non-Flask HORECA Product Debug:', {
        title: p.title || p.name,
        category_path: p.category_path,
        category: p.category,
        brand: p.brand,
        currentPrice: currentPrice,
        aggregate: p.aggregate,
        vis: vis.length,
        isFlaskProduct: isFlaskProduct
      });
    }
    
    // Show original price if available from various sources
    let originalPrice = null;
    
    // Check offers for original price
    if (vis.length && vis[0].original_price && vis[0].original_price > vis[0].price) {
      originalPrice = vis[0].original_price;
    }
    // Check product level original price
    else if (p.original_price && parseFloat(p.original_price) > currentPrice) {
      originalPrice = parseFloat(p.original_price);
    }
    // Check aggregate original price
    else if (p.aggregate && p.aggregate.highPrice > currentPrice) {
      originalPrice = p.aggregate.highPrice;
    }
    
    // For HORECA products with RM 0.00 current price, show original price instead
    let displayPrice = currentPrice;
    let showDiscount = false;
    
    if (isHorecaProduct && currentPrice === 0 && originalPrice > 0) {
      displayPrice = originalPrice;
      showDiscount = false; // Don't show discount for HORECA products with 0 price
      console.log('üè¢ Non-Flask HORECA Price Override:', { from: currentPrice, to: displayPrice });
    } else if (originalPrice && originalPrice > currentPrice) {
      showDiscount = true; // Show discount for normal products with actual discounts
    }
    
    if (showDiscount) {
      const savings = originalPrice - currentPrice;
      const discountPercentage = Math.round((savings / originalPrice) * 100);
      html += money(displayPrice, currentCurrency) + ' <span style="color: #28a745; font-size: 0.8em; margin-left: 4px; font-weight: bold;">(' + discountPercentage + '% OFF)</span>';
      html += ' <span style="text-decoration: line-through; color: #999; font-size: 0.9em; margin-left: 8px;">' + money(originalPrice, currentCurrency) + '</span>';
      html += ' <span style="color: #28a745; font-size: 0.8em; margin-left: 4px; font-weight: bold;">(Save RM ' + savings.toFixed(2) + ')</span>';
    } else {
      html += money(displayPrice, currentCurrency);
    }
  }
  
  html += '</div>';
  
  // Show promotion badge if available
  if (p.promotion_badge || (vis.length && vis[0].promo)) {
    const promoText = p.promotion_badge || vis[0].promo;
    html += '<div class="promotion-badge" style="margin-top: 4px;">';
    html += '<span style="background: #ff6b35; color: white; padding: 2px 6px; border-radius: 12px; font-size: 0.75em; font-weight: bold; text-transform: uppercase;">' + promoText + '</span>';
    html += '</div>';
  }
  
  html += '<div class="merchant">' + (vis.length ? first.merchant : (isFlaskProduct ? 'Lotus\'s' : 'Multiple stores')) + '</div>';
  
  if (isFlaskProduct) {
    // Flask products don't have price ranges, but show pricing info if available
    const isHorecaProduct = p.category_path === 'HORECA' || p.category === 'HORECA' || p.brand === 'HORECA';
    const salePrice = parseFloat(p.sale_price || 0);
    const originalPrice = parseFloat(p.original_price || 0);
    
    // Don't show price range for HORECA products with 0 sale price
    if (!(isHorecaProduct && salePrice === 0 && originalPrice > 0) && 
        p.original_price && p.sale_price && parseFloat(p.original_price) > parseFloat(p.sale_price)) {
      html += '<div class="range" style="font-size: 0.9em; color: #666; margin-top: 2px;">Sale: ' + money(parseFloat(p.sale_price), 'MYR') + ' | Original: ' + money(parseFloat(p.original_price), 'MYR') + '</div>';
    }
  } else if (p.aggregate && (p.aggregate.lowPrice !== p.aggregate.highPrice || (vis.length > 1))) {
    // Enhanced price range display
    const lowPrice = low || p.aggregate.lowPrice;
    const highPrice = high || p.aggregate.highPrice;
    const isHorecaProduct = p.category_path === 'HORECA' || p.category === 'HORECA' || p.brand === 'HORECA';
    
    // Don't show price range for HORECA products with 0 low price
    if (!(isHorecaProduct && lowPrice === 0 && highPrice > 0) && lowPrice !== highPrice) {
      // Check if we have original prices to show
      let hasOriginalPrices = false;
      let originalLowPrice = null;
      let originalHighPrice = null;
      
      if (vis.length > 0) {
        // Check if any offers have original prices
        const offersWithOriginal = vis.filter(o => o.original_price && o.original_price > o.price);
        if (offersWithOriginal.length > 0) {
          hasOriginalPrices = true;
          originalLowPrice = Math.min(...offersWithOriginal.map(o => o.original_price));
          originalHighPrice = Math.max(...offersWithOriginal.map(o => o.original_price));
        }
      }
      
      if (hasOriginalPrices) {
        html += '<div class="range" style="font-size: 0.9em; color: #666; margin-top: 2px;">Sale: ' + money(lowPrice, 'MYR') + ' ‚Äì ' + money(highPrice, 'MYR') + ' | Original: ' + money(originalLowPrice, 'MYR') + ' ‚Äì ' + money(originalHighPrice, 'MYR') + '</div>';
      } else {
        html += '<div class="range">('+money(lowPrice,'MYR')+' ‚Äì '+money(highPrice,'MYR')+')</div>';
      }
    }
  }
  
  // Schema.org microdata removed for cleaner display
  html += '</div>';
  html += '<div class="compare">';
  
  // Special handling for JSON display product
  if (p.id === 'wk34-horeca-json-display' && p.rawJsonData) {
    html += '<button class="view-json-btn" onclick="displayJSONInBrowser(' + JSON.stringify(p.rawJsonData).replace(/"/g, '&quot;') + ')" style="background: #007bff; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; width: 100%; display: flex; align-items: center; justify-content: center; gap: 6px; font-weight: 500; transition: all 0.2s ease;" onmouseover="this.style.background=\'#0056b3\'; this.style.transform=\'translateY(-1px)\'; this.style.boxShadow=\'0 2px 4px rgba(0,0,0,0.2)\'" onmouseout="this.style.background=\'#007bff\'; this.style.transform=\'translateY(0)\'; this.style.boxShadow=\'none\'">üìÑ View JSON Data</button>';
  } else {
    html += '<button class="compare-prices-btn" data-product-id="' + p.id + '" data-product-name="' + (p.title || p.name || 'Product') + '" style="background: #28a745; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; width: 100%; display: flex; align-items: center; justify-content: center; gap: 6px; font-weight: 500; transition: all 0.2s ease;" onmouseover="this.style.background=\'#218838\'; this.style.transform=\'translateY(-1px)\'; this.style.boxShadow=\'0 2px 4px rgba(0,0,0,0.2)\'" onmouseout="this.style.background=\'#28a745\'; this.style.transform=\'translateY(0)\'; this.style.boxShadow=\'none\'">‚öñÔ∏è Compare prices from selected marketplaces</button>';
  }
  // Hidden offers details section
  // html += '<details class="offers" style="margin-top: 8px;">';
  // html += '<summary style="font-size: 11px; color: #666; display: flex; align-items: center; gap: 4px; cursor: pointer;">üìã View local offers (' + vis.length + ' store' + (vis.length === 1 ? '' : 's') + ')</summary>';
  // html += '<table class="offerlist" role="table" aria-label="Offer comparison">';
  // html += '<thead><tr><th>Merchant</th><th>Price</th><th>Promo</th><th>Link</th></tr></thead>';
  // html += '<tbody>';
  // html += vis.map(offerRow).join("");
  // html += '</tbody>';
  // html += '</table>';
  // html += '<small class="muted">Prices may vary by time and seller.</small>';
  // html += '</details>';
  html += '</div>';
  html += '</div>';
  html += '</article>';
  html += micro;
  return html;
}

// Get selected products
function getSelectedProducts() {
  const checkboxes = document.querySelectorAll('.product-checkbox:checked');
  return Array.from(checkboxes).map(cb => ({
    id: cb.dataset.productId,
    name: cb.dataset.productName
  }));
}

// Compare selected products with Shopee
async function compareWithShopee(selectedProducts) {
  const loadingElement = document.getElementById('grid');
  loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Comparing with Shopee...</div>';
  
  try {
    const comparisonResults = [];
    const apiCallLogs = []; // Store API call details
    
    for (const product of selectedProducts) {
      console.log(`Comparing "${product.name}" with Shopee...`);
      
      // Log API call details
      const apiCall = {
        timestamp: new Date().toISOString(),
        productName: product.name,
        apiUrl: 'http://localhost:5001/search',
        requestParams: {
          keyword: product.name,
          limit: 5
        }
      };
      
      // Use the TMAPI to search Shopee with brand and label information
      const shopeeResults = await searchShopeeProduct(product.name, product.brand, product.label);
      
      // Add response details to API call log
      apiCall.response = {
        success: shopeeResults && shopeeResults.length > 0,
        resultCount: shopeeResults ? shopeeResults.length : 0,
        data: shopeeResults
      };
      
      apiCallLogs.push(apiCall);
      
      if (shopeeResults && shopeeResults.length > 0) {
        comparisonResults.push({
          originalProduct: product,
          shopeeProducts: shopeeResults
        });
      }
    }
    
    // Store API call logs globally for debug popup
    window.lastApiCallLogs = apiCallLogs;
    
    // Display comparison results
    displayComparisonResults(comparisonResults);
    
  } catch (error) {
    console.error('Error comparing with Shopee:', error);
    loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #c62828;">Error comparing with Shopee. Please try again.</div>';
  }
}

// Search Shopee using local proxy
async function searchShopeeProduct(keyword, brand = null, label = null) {
  try {
    const url = "http://localhost:5001/search";
    
    // Clean the keyword by removing number prefixes (1., 2., etc.)
    let cleanKeyword = keyword.replace(/^\d+\.\s*/, '').trim();
    
    // Use label if available, otherwise use the cleaned keyword
    let searchKeyword = label ? label.replace(/^\d+\.\s*/, '').trim() : cleanKeyword;
    
    // Create enhanced search keyword with brand if available (exclude HORECA)
    if (brand && brand.trim() !== '' && brand !== 'Unknown' && brand !== 'HORECA' && !brand.toUpperCase().includes('HORECA')) {
      searchKeyword = `${brand} ${searchKeyword}`;
      console.log(`üõí Enhanced search with brand: "${searchKeyword}"`);
    } else if (brand === 'HORECA' || brand.toUpperCase().includes('HORECA')) {
      console.log(`üõí Skipping HORECA brand, using clean keyword only: "${searchKeyword}"`);
    }
    
    console.log(`üõí Original keyword: "${keyword}"`);
    console.log(`üõí Cleaned keyword: "${cleanKeyword}"`);
    console.log(`üõí Using label: "${label}"`);
    console.log(`üõí Final search keyword: "${searchKeyword}"`);
    
    const params = {
      "keyword": searchKeyword,
      "limit": 5
    };
    
    console.log(`üõí Searching Shopee for: "${searchKeyword}"`);
    console.log(`üì° API URL: ${url}`);
    console.log(`üìã Request params:`, params);
    
    const response = await fetch(`${url}?${new URLSearchParams(params)}`);
    console.log(`üìä Shopee API response status: ${response.status} ${response.statusText}`);
    
    if (!response.ok) {
      console.log(`‚ùå Shopee API error: ${response.status} ${response.statusText}`);
      return null;
    }
    
    const shopeeData = await response.json();
    console.log('üõí Shopee API response data:', shopeeData);
    
    if (shopeeData && shopeeData.success && shopeeData.products) {
      console.log(`‚úÖ Found ${shopeeData.products.length} Shopee products`);
      return shopeeData.products.slice(0, 3); // Return top 3 results
    } else {
      console.log(`‚ùå No Shopee products found or API returned error`);
      return null;
    }
    
    return [];
  } catch (error) {
    console.error('Error searching Shopee:', error);
    return [];
  }
}

// Search Lazada using local proxy
async function searchLazadaProduct(keyword, brand = null, label = null) {
  try {
    const url = "http://localhost:5001/search-lazada";
    
    // Clean the keyword by removing number prefixes (1., 2., etc.)
    let cleanKeyword = keyword.replace(/^\d+\.\s*/, '').trim();
    
    // Use label if available, otherwise use the cleaned keyword
    let searchKeyword = label ? label.replace(/^\d+\.\s*/, '').trim() : cleanKeyword;
    
    // Create enhanced search keyword with brand if available (exclude HORECA)
    if (brand && brand.trim() !== '' && brand !== 'Unknown' && brand !== 'HORECA' && !brand.toUpperCase().includes('HORECA')) {
      searchKeyword = `${brand} ${searchKeyword}`;
      console.log(`üõçÔ∏è Enhanced search with brand: "${searchKeyword}"`);
    } else if (brand === 'HORECA' || brand.toUpperCase().includes('HORECA')) {
      console.log(`üõçÔ∏è Skipping HORECA brand, using clean keyword only: "${searchKeyword}"`);
    }
    
    console.log(`üõçÔ∏è Original keyword: "${keyword}"`);
    console.log(`üõçÔ∏è Cleaned keyword: "${cleanKeyword}"`);
    console.log(`üõçÔ∏è Using label: "${label}"`);
    console.log(`üõçÔ∏è Final search keyword: "${searchKeyword}"`);
    
    const params = {
      "keyword": searchKeyword,
      "limit": 5
    };
    
    console.log(`üõçÔ∏è Searching Lazada for: "${searchKeyword}"`);
    console.log(`üì° API URL: ${url}`);
    console.log(`üìã Request params:`, params);
    
    const response = await fetch(`${url}?${new URLSearchParams(params)}`);
    console.log(`üìä Lazada API response status: ${response.status} ${response.statusText}`);
    
    if (!response.ok) {
      console.log(`‚ùå Lazada API error: ${response.status} ${response.statusText}`);
      return null;
    }
    
    const lazadaData = await response.json();
    console.log('üõçÔ∏è Lazada API response data:', lazadaData);
    
    if (lazadaData && lazadaData.success && lazadaData.products) {
      console.log(`‚úÖ Found ${lazadaData.products.length} Lazada products`);
      return lazadaData.products.slice(0, 3); // Return top 3 results
    } else {
      console.log(`‚ùå No Lazada products found or API returned error`);
      return null;
    }
    
    return [];
  } catch (error) {
    console.error('Error searching Lazada:', error);
    return [];
  }
}

// Display comparison results
function displayComparisonResults(comparisonResults) {
  let html = '<div style="margin-bottom: 20px;"><h2>Shopee Comparison Results</h2></div>';
  
  // Show debug popup with all comparison data
  showDebugPopup(comparisonResults);
  
  comparisonResults.forEach(result => {
    html += '<div style="border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 15px;">';
    html += '<h3 style="color: #333; margin-bottom: 10px;">' + result.originalProduct.name + '</h3>';
    html += '<div style="display: grid; gap: 10px;">';
    
    result.shopeeProducts.forEach((shopeeProduct, index) => {
      const price = shopeeProduct.price ? shopeeProduct.price.toFixed(2) : 'N/A';
      const image = shopeeProduct.image || 'https://via.placeholder.com/100x100.png?text=No+Image';
      
      // Debug info
      console.log('Shopee Product Debug:', {
        name: shopeeProduct.name,
        rawPrice: shopeeProduct.price,
        calculatedPrice: price,
        shop: shopeeProduct.shop_name,
        rating: shopeeProduct.rating,
        sold: shopeeProduct.sold
      });
      
      html += '<div style="display: flex; align-items: center; gap: 15px; padding: 10px; border: 1px solid #eee; border-radius: 5px;">';
      html += '<div style="flex: 1;">';
      html += '<h4 style="margin: 0 0 5px 0; font-size: 14px;">' + shopeeProduct.name + '</h4>';
      html += '<p style="margin: 0; color: #666; font-size: 12px;">Shop: ' + (shopeeProduct.shop_name || 'Unknown') + '</p>';
      html += '<p style="margin: 2px 0; color: #666; font-size: 11px;">Rating: ' + (shopeeProduct.rating || 'N/A') + ' | Sold: ' + (shopeeProduct.sold || 'N/A') + '</p>';
      html += '<p style="margin: 5px 0 0 0; font-weight: bold; color: #ff6b35;">RM ' + price + '</p>';
      html += '</div>';
      html += '<div>';
      html += '<a href="' + shopeeProduct.url + '" target="_blank" style="background: #ff6b35; color: white; padding: 8px 12px; text-decoration: none; border-radius: 4px; font-size: 12px;">üîó View on Shopee</a>';
      html += '</div>';
      html += '</div>';
    });
    
    html += '</div>';
    html += '</div>';
  });
  
  // Add back button
  html += '<div style="text-align: center; margin-top: 20px;">';
  html += '<button onclick="location.reload()" style="background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">Back to Search</button>';
  html += '</div>';
  
  document.getElementById('grid').innerHTML = html;
}

// Compare prices from selected marketplaces
async function comparePricesFromSelectedMarketplaces(selectedProducts) {
  const loadingElement = document.getElementById('grid');
  loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Comparing prices from selected marketplaces...</div>';
  
  try {
    // Get selected marketplaces from checkboxes
    const selectedMarketplaces = getSelectedMarketplaces();
    console.log('Selected marketplaces:', selectedMarketplaces);
    
    if (selectedMarketplaces.length === 0) {
      alert('Please select at least one marketplace to compare');
      return;
    }
    
    const comparisonResults = [];
    
    for (const product of selectedProducts) {
      console.log(`üîÑ Comparing "${product.name}" across marketplaces...`);
      console.log(`üìä Product ID: ${product.id}`);
      console.log(`üìã Selected marketplaces: ${selectedMarketplaces.join(', ')}`);
      
      const productComparison = {
        originalProduct: product,
        marketplaceResults: {}
      };
      
      // For each selected marketplace, get the first available offer
      for (const marketplace of selectedMarketplaces) {
        console.log(`  üîç Checking ${marketplace} for "${product.name}"...`);
        console.log(`  üì° Making API call to ${marketplace}...`);
        
        try {
          const marketplaceData = await getMarketplaceData(product.name, marketplace, product);
          console.log(`  ‚úÖ ${marketplace} response:`, marketplaceData);
          
          if (marketplaceData) {
            productComparison.marketplaceResults[marketplace] = marketplaceData;
            console.log(`  üìä Added ${marketplace} data to comparison results`);
          } else {
            console.log(`  ‚ùå No data returned from ${marketplace}`);
          }
        } catch (error) {
          console.log(`  ‚ùå Error getting ${marketplace} data:`, error);
        }
      }
      
      comparisonResults.push(productComparison);
    }
    
    // Display comparison results
    displayMarketplaceComparisonResults(comparisonResults);
    
    // Store Shopee products in database
    await storeShopeeProductsInDatabase(comparisonResults);
    
  } catch (error) {
    console.error('Error comparing prices:', error);
    loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #c62828;">Error comparing prices. Please try again.</div>';
  }
}

// Compare single product from selected marketplaces
async function compareSingleProduct(productId, productName) {
  // Find the full product object to get complete product details
  // Handle both numeric IDs (from Flask API) and string IDs (from converted products)
  let fullProduct = FEED.find(p => p.id == productId); // Use == for loose equality to handle type conversion
  
  // If not found with loose equality, try exact match
  if (!fullProduct) {
    fullProduct = FEED.find(p => p.id === productId);
  }
  
  // If still not found, try to find by numeric ID for Flask products
  if (!fullProduct && !isNaN(productId)) {
    fullProduct = FEED.find(p => {
      // Check if it's a Flask product with numeric ID
      if (p.id && typeof p.id === 'string' && p.id.startsWith('flask-app-')) {
        const numericId = p.id.replace('flask-app-', '');
        return numericId === productId.toString();
      }
      return false;
    });
  }
  
  if (!fullProduct) {
    console.error(`‚ùå Product with ID ${productId} (type: ${typeof productId}) not found in FEED`);
    console.log(`üîç Available product IDs in FEED:`, FEED.map(p => `${p.id} (${typeof p.id})`).slice(0, 10));
    console.log(`üîç Looking for product with ID: ${productId} (type: ${typeof productId})`);
    alert('Product not found. Please try again.');
    return;
  }
  
  console.log(`üîç Found full product for comparison:`, fullProduct);
  
  const selectedProducts = [{
    id: productId,
    name: productName,
    brand: fullProduct.brand,
    // Pass the full product object for complete data access
    fullProductData: fullProduct
  }];
  
  await comparePricesFromSelectedMarketplaces(selectedProducts);
}

// Compare selected products from checkboxes
async function compareSelectedProducts() {
  const selectedCheckboxes = document.querySelectorAll('.product-checkbox:checked');
  
  if (selectedCheckboxes.length === 0) {
    alert('Please select at least one product to compare by checking the checkboxes next to products.');
    return;
  }
  
  const selectedProducts = Array.from(selectedCheckboxes).map(checkbox => {
    // Find the full product object from the current feed
    const productId = checkbox.dataset.productId;
    const fullProduct = FEED.find(p => p.id === productId);
    
    return {
      id: checkbox.dataset.productId,
      name: checkbox.dataset.productName,
      brand: fullProduct ? fullProduct.brand : null
    };
  });
  
  console.log(`üîÑ Comparing ${selectedProducts.length} selected products across marketplaces...`);
  await comparePricesFromSelectedMarketplaces(selectedProducts);
}

// Update marketplace selection visual feedback
function updateMarketplaceSelection() {
  const selectedMarketplaces = getSelectedMarketplaces();
  const compareButton = document.getElementById('compareSelectedProducts');
  
  // Safety check - make sure button exists
  if (!compareButton) {
    console.warn('Compare button not found, skipping update');
    return;
  }
  
  if (selectedMarketplaces.length > 0) {
    compareButton.style.opacity = '1';
    compareButton.style.cursor = 'pointer';
    compareButton.title = `Compare prices across: ${selectedMarketplaces.join(', ')}`;
  } else {
    compareButton.style.opacity = '0.5';
    compareButton.style.cursor = 'not-allowed';
    compareButton.title = 'Please select at least one marketplace to compare';
  }
}

// Update selected products count
function updateSelectedProductsCount() {
  const selectedCheckboxes = document.querySelectorAll('.product-checkbox:checked');
  const countElement = document.getElementById('selectedCount');
  
  // Check if the element exists before trying to access its properties
  if (countElement) {
    if (selectedCheckboxes.length > 0) {
      countElement.textContent = selectedCheckboxes.length;
      countElement.style.display = 'block';
    } else {
      countElement.style.display = 'none';
    }
  } else {
    console.log('selectedCount element not found, skipping count update');
  }
}

// Get selected marketplaces from checkboxes
function getSelectedMarketplaces() {
  const checkboxes = document.querySelectorAll('.marketplace-filter:checked');
  return Array.from(checkboxes).map(cb => cb.dataset.marketplace);
}

// Get marketplace data (first record) for a product
async function getMarketplaceData(productName, marketplace, product = null) {
  console.log(`üîç getMarketplaceData called for "${productName}" on ${marketplace}`);
  console.log(`üì¶ Full product object:`, product);
  
  try {
    if (marketplace === 'shopee') {
      console.log(`üõí Getting Shopee data for "${productName}"`);
      // Use TMAPI for Shopee with brand and label information
      const brand = product ? product.brand : null;
      const label = product ? product.label : null;
      const shopeeResults = await searchShopeeProduct(productName, brand, label);
      console.log(`üõí Shopee results received:`, shopeeResults);
      
      if (shopeeResults && shopeeResults.length > 0) {
        const firstResult = shopeeResults[0];
        console.log(`üõí Using first Shopee result:`, firstResult);
        return {
          marketplace: 'Shopee',
          name: firstResult.name,
          price: firstResult.price,
          currency: firstResult.currency || 'MYR',
          url: firstResult.url,
          image: firstResult.image,
          shop_name: firstResult.shop_name,
          discount: firstResult.discount || 0,
          rating: firstResult.rating,
          sold: firstResult.sold,
          // Include all raw response data for detailed view
          rawResponse: {
            allResults: shopeeResults,
            totalResults: shopeeResults.length,
            searchKeyword: productName,
            timestamp: new Date().toISOString(),
            apiEndpoint: 'search'
          },
          // Store store_id for database storage
          store_id: firstResult.shop_id
        };
      } else {
        console.log(`‚ùå No Shopee results for "${productName}"`);
        return {
          marketplace: 'Shopee',
          name: 'No results found',
          price: null,
          currency: 'MYR',
          url: null,
          image: null,
          shop_name: null,
          discount: 0,
          rating: 0,
          sold: 0,
          rawResponse: {
            allResults: [],
            totalResults: 0,
            searchKeyword: productName,
            timestamp: new Date().toISOString(),
            apiEndpoint: 'search',
            error: 'No products found for this search term'
          }
        };
      }
    } else if (marketplace === 'lazada') {
      console.log(`üõçÔ∏è Getting Lazada data for "${productName}"`);
      // Use TMAPI for Lazada with brand and label information
      const brand = product ? product.brand : null;
      const label = product ? product.label : null;
      const lazadaResults = await searchLazadaProduct(productName, brand, label);
      console.log(`üõçÔ∏è Lazada results received:`, lazadaResults);
      
      if (lazadaResults && lazadaResults.length > 0) {
        const firstResult = lazadaResults[0];
        console.log(`üõçÔ∏è Using first Lazada result:`, firstResult);
        return {
          marketplace: 'Lazada',
          name: firstResult.name,
          price: firstResult.price,
          currency: firstResult.currency || 'MYR',
          url: firstResult.url,
          image: firstResult.image,
          shop_name: firstResult.shop_name,
          discount: firstResult.discount || 0,
          rating: firstResult.rating,
          sold: firstResult.sold,
          // Include all raw response data for detailed view
          rawResponse: {
            allResults: lazadaResults,
            totalResults: lazadaResults.length,
            searchKeyword: productName,
            timestamp: new Date().toISOString(),
            apiEndpoint: 'search-lazada'
          }
        };
      } else {
        console.log(`‚ùå No Lazada results for "${productName}"`);
        return {
          marketplace: 'Lazada',
          name: 'No results found',
          price: null,
          currency: 'MYR',
          url: null,
          image: null,
          shop_name: null,
          discount: 0,
          rating: 0,
          sold: 0,
          rawResponse: {
            allResults: [],
            totalResults: 0,
            searchKeyword: productName,
            timestamp: new Date().toISOString(),
            apiEndpoint: 'search-lazada',
            error: 'No products found for this search term'
          }
        };
      }
    } else if (marketplace === 'lotuss') {
      // For Lotus, find the product in current data
      const lotusProduct = FEED.find(p => 
        p.title.toLowerCase().includes(productName.toLowerCase()) ||
        productName.toLowerCase().includes(p.title.toLowerCase())
      );
      
      if (lotusProduct && lotusProduct.offers && lotusProduct.offers.length > 0) {
        const firstOffer = lotusProduct.offers[0];
        return {
          marketplace: 'Lotus\'s',
          name: lotusProduct.title,
          price: firstOffer.price,
          currency: firstOffer.currency || 'MYR',
          url: firstOffer.url,
          image: lotusProduct.image_url,
          shop_name: 'Lotus\'s',
          discount: 0, // Calculate discount if original_price available
          rating: 0,
          sold: 0
        };
      }
    }
    // Add other marketplaces as needed
    
    return null;
  } catch (error) {
    console.error(`Error getting ${marketplace} data:`, error);
    return null;
  }
}

// Store Shopee products in database
async function storeShopeeProductsInDatabase(comparisonResults) {
  console.log('üíæ Storing Shopee products in database...');
  
  for (const result of comparisonResults) {
    const shopeeData = result.marketplaceResults.shopee;
    if (shopeeData && shopeeData.rawResponse && shopeeData.rawResponse.allResults) {
      for (const product of shopeeData.rawResponse.allResults) {
        try {
          const productData = {
            product_name: product.name,
            current_price: product.price,
            product_url: product.url,
            image_url: product.image,
            store_id: product.shop_id,
            marketplace: 'Shopee',
            store: product.shop_name,
            product_type: 'General',
            description: `Shopee product - ${product.brand || ''}`,
            see_more_link: product.url,
            label: result.originalProduct.name,
            created_at: new Date().toISOString()
          };
          
          // Send to database via API
          const response = await fetch('/api/store-shopee-product', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(productData)
          });
          
          if (response.ok) {
            console.log(`‚úÖ Stored Shopee product: ${product.name} (Store ID: ${product.shop_id})`);
          } else {
            console.log(`‚ùå Failed to store product: ${product.name}`);
          }
        } catch (error) {
          console.error(`Error storing product ${product.name}:`, error);
        }
      }
    }
  }
}

// Store a single product immediately in the database
async function storeProductInDatabaseImmediately(product) {
  console.log(`üöÄ storeProductInDatabaseImmediately called for: "${product.name}"`);
  try {
    // Extract price value from string like "RM 15.90"
    const priceMatch = product.price ? product.price.match(/RM\s*(\d+\.?\d*)/i) : null;
    const priceValue = priceMatch ? parseFloat(priceMatch[1]) : 0;
    
    const productData = {
      product_name: product.name,
      current_price: priceValue,
      product_url: product.url,
      image_url: product.image_url || '',
      store_id: null, // Lotus products don't have store_id
      marketplace: 'Lotus',
      store: 'Lotus\'s',
      product_type: 'General',
      description: product.description || `Lotus product - ${product.name}`,
      see_more_link: product.url,
      label: product.name,
      original_name: product.name, // Store original name for translation
      created_at: new Date().toISOString()
    };
    
    // Send to database via API
    console.log(`üíæ Writing to database: "${product.name}" (${product.url})`);
    const response = await fetch('http://localhost:5002/api/store-lotus-product', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(productData)
    });
    
    if (response.ok) {
      const result = await response.json();
      if (result.message && result.message.includes('updated')) {
        console.log(`üîÑ Product updated in database: ${product.name}`);
      } else if (result.message && result.message.includes('stored')) {
        console.log(`‚úÖ New product stored in database: ${product.name}`);
      } else {
        console.log(`üìù Product processed in database: ${product.name}`);
      }
      console.log(`üìä Database response for "${product.name}":`, result);
    } else {
      console.log(`‚ùå Failed to store product: ${product.name} - Status: ${response.status}`);
      const errorText = await response.text();
      console.log(`‚ùå Error response:`, errorText);
    }
  } catch (error) {
    console.error(`‚ùå Error storing product ${product.name}:`, error);
  }
}

// Store Lotus Firecrawl products in database
async function storeLotusProductsInDatabase(products) {
  console.log(`üíæ Storing ${products.length} Lotus Firecrawl products in database...`);
  
  let storedCount = 0;
  let skippedCount = 0;
  let errorCount = 0;
  
  for (const product of products) {
    try {
      // Extract price value from string like "RM 15.90"
      const priceMatch = product.price ? product.price.match(/RM\s*(\d+\.?\d*)/i) : null;
      const priceValue = priceMatch ? parseFloat(priceMatch[1]) : 0;
      
      const productData = {
        product_name: product.name,
        current_price: priceValue,
        product_url: product.url,
        image_url: product.image_url || '',
        store_id: null, // Lotus products don't have store_id
        marketplace: 'Lotus',
        store: 'Lotus\'s',
        product_type: 'General',
        description: product.description || `Lotus product - ${product.name}`,
        see_more_link: product.url,
        label: product.name,
        original_name: product.name, // Store original name for translation
        created_at: new Date().toISOString()
      };
      
      // Send to database via API
      console.log(`üíæ Writing to database: "${product.name}" (${product.url})`);
      const response = await fetch('http://localhost:5005/api/store-lotus-product', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(productData)
      });
      
      if (response.ok) {
        const result = await response.json();
        if (result.message && result.message.includes('updated')) {
          storedCount++; // Count updates as stored
          console.log(`üîÑ Updated existing Lotus product: ${product.name}`);
        } else if (result.message && result.message.includes('stored')) {
          storedCount++;
          console.log(`‚úÖ Stored new Lotus product: ${product.name}`);
        } else {
          storedCount++;
          console.log(`üìù Processed Lotus product: ${product.name}`);
        }
        console.log(`üìä Database response for "${product.name}":`, result);
      } else {
        errorCount++;
        console.log(`‚ùå Failed to store Lotus product: ${product.name} - Status: ${response.status}`);
        const errorText = await response.text();
        console.log(`‚ùå Error response:`, errorText);
      }
    } catch (error) {
      errorCount++;
      console.error(`Error storing Lotus product ${product.name}:`, error);
      console.error(`Error details for product ${product.name}:`, {
        message: error.message,
        stack: error.stack,
        name: error.name,
        productData: productData
      });
    }
  }
  
  // Log summary
  console.log(`üìä Database Storage Summary: ${storedCount} new, ${skippedCount} skipped, ${errorCount} errors`);
  return { stored: storedCount, skipped: skippedCount, errors: errorCount };
}

// Update database progress display
function updateDatabaseProgress(current, total, stored, skipped, errors, status = 'processing') {
  const progressDiv = document.getElementById('databaseProgress');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  const progressIcon = document.getElementById('progressIcon');
  const progressStats = document.getElementById('progressStats');
  
  if (!progressDiv) return;
  
  // Show progress div
  progressDiv.style.display = 'block';
  
  // Calculate percentage
  const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
  
  // Update progress bar
  progressBar.style.width = percentage + '%';
  
  // Update text and icon based on status
  switch (status) {
    case 'starting':
      progressText.textContent = 'Starting Database Operations...';
      progressIcon.textContent = 'üöÄ';
      progressDiv.style.background = '#e3f2fd';
      progressDiv.style.borderColor = '#2196f3';
      break;
    case 'processing':
      progressText.textContent = `Database Progress (${current}/${total})`;
      progressIcon.textContent = 'üíæ';
      progressDiv.style.background = '#e3f2fd';
      progressDiv.style.borderColor = '#2196f3';
      break;
    case 'storing':
      progressText.textContent = 'Storing in Database...';
      progressIcon.textContent = 'üíæ';
      progressDiv.style.background = '#fff3e0';
      progressDiv.style.borderColor = '#ff9800';
      break;
    case 'completed':
      progressText.textContent = 'Database Operations Completed!';
      progressIcon.textContent = '‚úÖ';
      progressDiv.style.background = '#e8f5e8';
      progressDiv.style.borderColor = '#28a745';
      break;
    case 'error':
      progressText.textContent = 'Database Error';
      progressIcon.textContent = '‚ùå';
      progressDiv.style.background = '#ffebee';
      progressDiv.style.borderColor = '#f44336';
      break;
  }
  
  // Update statistics
  let statsText = `${percentage}% complete`;
  if (stored > 0 || skipped > 0 || errors > 0) {
    statsText += ` | Stored: ${stored}, Skipped: ${skipped}`;
    if (errors > 0) {
      statsText += `, Errors: ${errors}`;
    }
  }
  progressStats.textContent = statsText;
}

// Hide database progress display
function hideDatabaseProgress() {
  const progressDiv = document.getElementById('databaseProgress');
  if (progressDiv) {
    progressDiv.style.display = 'none';
  }
}

// Reset database progress tracking
function resetDatabaseProgress() {
  totalUrlsToProcess = 0;
  currentBatchProgress = 0;
  totalStored = 0;
  totalSkipped = 0;
  totalErrors = 0;
  hideDatabaseProgress();
}

// Process a batch of URLs (100 at a time)
async function processBatchOfUrls(batchSize = 100) {
  if (isProcessing) {
    showNotification('‚ö†Ô∏è Processing already in progress. Please wait.', 'warning');
    return;
  }
  
  if (!fetchedUrls || fetchedUrls.length === 0) {
    showNotification('‚ùå No URLs available. Please fetch URLs first.', 'error');
    return;
  }
  
  if (processedUrls >= fetchedUrls.length) {
    showNotification('‚úÖ All URLs have been processed!', 'success');
    return;
  }
  
  isProcessing = true;
  const button = document.getElementById('processBatch100');
  const originalText = button.textContent;
  
  try {
    // Calculate batch range
    const startIndex = processedUrls;
    const endIndex = Math.min(processedUrls + batchSize, fetchedUrls.length);
    const batchUrls = fetchedUrls.slice(startIndex, endIndex);
    
    // Initialize progress tracking
    totalUrlsToProcess = fetchedUrls.length;
    currentBatchProgress = startIndex;
    
    button.textContent = `üîÑ Processing ${startIndex + 1}-${endIndex} of ${fetchedUrls.length}...`;
    showNotification(`üîÑ Processing batch ${startIndex + 1}-${endIndex} of ${fetchedUrls.length} URLs...`, 'info');
    
    // Show initial progress
    updateDatabaseProgress(currentBatchProgress, totalUrlsToProcess, totalStored, totalSkipped, totalErrors, 'starting');
    
    let successCount = 0;
    let errorCount = 0;
    const allProducts = [];
    
    // Process URLs in smaller sub-batches to avoid overwhelming the API
    const subBatchSize = 5;
    for (let i = 0; i < batchUrls.length; i += subBatchSize) {
      const subBatch = batchUrls.slice(i, i + subBatchSize);
      
      const subBatchPromises = subBatch.map(async (urlData, subIndex) => {
        const url = typeof urlData === 'string' ? urlData : (urlData.url || urlData.href);
        if (!url) return null;
        
        try {
          const globalIndex = startIndex + i + subIndex;
          console.log(`üîç Processing URL ${globalIndex + 1}/${fetchedUrls.length}: ${url}`);
          
          const scrapeUrl = 'https://api.firecrawl.dev/v2/scrape';
          console.log(`üåê Making API call to Firecrawl for: ${url}`);
          const options = {
            method: 'POST',
            headers: {
              'Authorization': 'Bearer fc-e4eb2258dbe34769b9be4a2c6ff9c86f',
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              "url": url,
              "formats": ["markdown"],
              "onlyMainContent": true
            })
          };

          const response = await fetch(scrapeUrl, options);
          console.log(`üì° Firecrawl API response status: ${response.status} for URL: ${url}`);
          
          if (!response.ok) {
            console.error(`‚ùå HTTP Error: ${response.status} ${response.statusText} for URL: ${url}`);
            errorCount++;
            return null;
          }
          
          const data = await response.json();
          console.log(`üìä Firecrawl API response data:`, data);
          
          // Show Firecrawl response in popup for debugging
          showFirecrawlResponse(url, response.status, data);
          
          if (data.success && data.data) {
            console.log(`üîÑ About to call extractProductFromContent for URL: ${url}`);
            console.log(`üìù Content to extract from:`, data.data.substring(0, 500) + '...');
            const product = extractProductFromContent(url, data.data);
            console.log(`üîç Extracted product from content:`, product);
            if (product) {
              // Check if product has a valid price before adding to batch
              const priceMatch = product.price ? product.price.match(/RM\s*(\d+\.?\d*)/i) : null;
              const priceValue = priceMatch ? parseFloat(priceMatch[1]) : 0;
              
              if (priceValue > 0) {
                allProducts.push(product);
                successCount++;
                console.log(`üì¶ Added product to batch: "${product.name}" (Price: RM ${priceValue})`);
                addSingleProductToDisplay(product, allProducts.length - 1);
              } else {
                console.log(`‚è≠Ô∏è Skipping product with price 0: "${product.name}" (Price: ${product.price})`);
              }
            }
          } else {
            errorCount++;
          }
          
          // Small delay to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (error) {
          console.error(`‚ùå Error processing ${url}:`, error);
          errorCount++;
        }
      });
      
      await Promise.all(subBatchPromises);
      
      // Update progress
      const progress = startIndex + i + subBatchSize;
      currentBatchProgress = Math.min(progress, endIndex);
      button.textContent = `üîÑ Processing ${currentBatchProgress} of ${fetchedUrls.length}...`;
      
      // Update database progress
      updateDatabaseProgress(currentBatchProgress, totalUrlsToProcess, totalStored, totalSkipped, totalErrors, 'processing');
    }
    
    // Store products in database
    if (allProducts.length > 0) {
      // Show storing progress
      updateDatabaseProgress(currentBatchProgress, totalUrlsToProcess, totalStored, totalSkipped, totalErrors, 'storing');
      
      console.log(`üîÑ Calling database storage for ${allProducts.length} products...`);
      const storageResult = await storeLotusProductsInDatabase(allProducts);
      console.log(`‚úÖ Database storage completed:`, storageResult);
      
      // Update totals
      totalStored += storageResult.stored;
      totalSkipped += storageResult.skipped;
      totalErrors += storageResult.errors;
      
      let message = `‚úÖ Batch completed! Processed ${successCount} products, ${errorCount} errors.`;
      message += ` Database: ${storageResult.stored} new, ${storageResult.skipped} skipped.`;
      showNotification(message, 'success');
    } else {
      showNotification(`‚ö†Ô∏è Batch completed with ${errorCount} errors. No products processed.`, 'warning');
    }
    
    // Update processed count
    processedUrls = endIndex;
    
    // Update button text
    const remaining = fetchedUrls.length - processedUrls;
    if (remaining > 0) {
      button.textContent = `üì¶ Process Next ${Math.min(100, remaining)} (${remaining} remaining)`;
    } else {
      button.textContent = '‚úÖ All Processed';
      button.disabled = true;
    }
    
    // Update progress in console
    console.log(`üìä Batch Progress: ${processedUrls}/${fetchedUrls.length} URLs processed`);
    
    // Show final progress
    updateDatabaseProgress(processedUrls, totalUrlsToProcess, totalStored, totalSkipped, totalErrors, 'completed');
    
  } catch (error) {
    console.error('‚ùå Error in batch processing:', error);
    showNotification('‚ùå Error in batch processing: ' + error.message, 'error');
    updateDatabaseProgress(currentBatchProgress, totalUrlsToProcess, totalStored, totalSkipped, totalErrors, 'error');
  } finally {
    isProcessing = false;
  }
}

// Process all remaining URLs
async function processAllRemainingUrls() {
  if (isProcessing) {
    showNotification('‚ö†Ô∏è Processing already in progress. Please wait.', 'warning');
    return;
  }
  
  if (!fetchedUrls || fetchedUrls.length === 0) {
    showNotification('‚ùå No URLs available. Please fetch URLs first.', 'error');
    return;
  }
  
  if (processedUrls >= fetchedUrls.length) {
    showNotification('‚úÖ All URLs have been processed!', 'success');
    return;
  }
  
  const remainingCount = fetchedUrls.length - processedUrls;
  const confirmMessage = `Are you sure you want to process all ${remainingCount} remaining URLs? This may take a long time.`;
  
  if (!confirm(confirmMessage)) {
    return;
  }
  
  isProcessing = true;
  const button = document.getElementById('processAllRecords');
  const originalText = button.textContent;
  
  try {
    button.textContent = 'üîÑ Processing All Remaining...';
    button.disabled = true;
    
    // Show stop processing button
    const stopButton = document.getElementById('stopProcessing');
    if (stopButton) {
      stopButton.style.display = 'inline-block';
    }
    
    // Initialize progress tracking
    totalUrlsToProcess = fetchedUrls.length;
    currentBatchProgress = processedUrls;
    
    showNotification(`üöÄ Starting to process all ${remainingCount} remaining URLs...`, 'info');
    
    // Show initial progress
    updateDatabaseProgress(currentBatchProgress, totalUrlsToProcess, totalStored, totalSkipped, totalErrors, 'starting');
    
    // Process in batches of 100
    const batchSize = 100;
    let totalProcessed = 0;
    let totalErrors = 0;
    let totalStored = 0;
    let totalSkipped = 0;
    
    while (processedUrls < fetchedUrls.length && !isProcessing) {
      const batchStart = processedUrls;
      const batchEnd = Math.min(processedUrls + batchSize, fetchedUrls.length);
      const batchUrls = fetchedUrls.slice(batchStart, batchEnd);
      
      console.log(`üîÑ Processing batch ${batchStart + 1}-${batchEnd} of ${fetchedUrls.length}`);
      
      let batchSuccess = 0;
      let batchErrors = 0;
      const batchProducts = [];
      
      // Process this batch
      const subBatchSize = 5;
      for (let i = 0; i < batchUrls.length; i += subBatchSize) {
        const subBatch = batchUrls.slice(i, i + subBatchSize);
        
        const subBatchPromises = subBatch.map(async (urlData, subIndex) => {
          const url = typeof urlData === 'string' ? urlData : (urlData.url || urlData.href);
          if (!url) return null;
          
          try {
            const globalIndex = batchStart + i + subIndex;
            console.log(`üîç Processing URL ${globalIndex + 1}/${fetchedUrls.length}: ${url}`);
            
            const scrapeUrl = 'https://api.firecrawl.dev/v2/scrape';
            console.log(`üåê Making API call to Firecrawl for: ${url}`);
            const options = {
              method: 'POST',
              headers: {
                'Authorization': 'Bearer fc-e4eb2258dbe34769b9be4a2c6ff9c86f',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                "url": url,
                "formats": ["markdown"],
                "onlyMainContent": true
              })
            };

            // Add timeout to prevent hanging
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
          const response = await fetch(scrapeUrl, {
            ...options,
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          console.log(`üì° Response status for ${url}: ${response.status} ${response.statusText}`);
          const data = await response.json();
          console.log(`üìä Response data for ${url}:`, data);
            
            if (data.success && data.data) {
            console.log(`üîÑ About to call extractProductFromContent for URL: ${url}`);
            const product = extractProductFromContent(url, data.data);
            console.log(`üîç Extracted product from content:`, product);
              if (product && product.name && product.name !== 'Unknown Product') {
                // Check if product has a valid price before adding to batch
                const priceMatch = product.price ? product.price.match(/RM\s*(\d+\.?\d*)/i) : null;
                const priceValue = priceMatch ? parseFloat(priceMatch[1]) : 0;
                
                if (priceValue > 0) {
                  batchProducts.push(product);
                  batchSuccess++;
                  console.log(`üì¶ Added product to batch: "${product.name}" (Price: RM ${priceValue}, Batch size: ${batchProducts.length})`);
                  addSingleProductToDisplay(product, batchProducts.length - 1);
                } else {
                  console.log(`‚è≠Ô∏è Skipping product with price 0: "${product.name}" (Price: ${product.price})`);
                }
              } else {
                console.log(`‚ùå No valid product extracted from content for URL: ${url} - Product:`, product);
              }
            } else {
              batchErrors++;
              console.log(`‚ùå Failed to scrape URL: ${url} - Success: ${data.success}`);
            }
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
          } catch (error) {
            if (error.name === 'AbortError') {
              console.error(`‚è∞ Timeout processing URL ${url} (30s limit exceeded)`);
            } else {
              console.error(`‚ùå Error processing ${url}:`, error);
            }
            batchErrors++;
          }
        });
        
        await Promise.all(subBatchPromises);
      }
      
      // Store batch products in database
      console.log(`üìä Batch processing complete - batchProducts.length: ${batchProducts.length}`);
      if (batchProducts.length > 0) {
        // Show storing progress
        updateDatabaseProgress(processedUrls, totalUrlsToProcess, totalStored, totalSkipped, totalErrors, 'storing');
        
        console.log(`üîÑ Calling database storage for ${batchProducts.length} batch products...`);
        const storageResult = await storeLotusProductsInDatabase(batchProducts);
        console.log(`‚úÖ Batch database storage completed:`, storageResult);
        totalStored += storageResult.stored;
        totalSkipped += storageResult.skipped;
      } else {
        console.log(`‚ö†Ô∏è No products to store in database for this batch`);
      }
      
      totalProcessed += batchSuccess;
      totalErrors += batchErrors;
      processedUrls = batchEnd;
      currentBatchProgress = processedUrls;
      
      // Update progress
      const progress = Math.round((processedUrls / fetchedUrls.length) * 100);
      button.textContent = `üîÑ Processing... ${progress}% (${processedUrls}/${fetchedUrls.length})`;
      
      // Update database progress
      updateDatabaseProgress(currentBatchProgress, totalUrlsToProcess, totalStored, totalSkipped, totalErrors, 'processing');
      
      // Show progress notification every 50 URLs to keep user informed
      if (processedUrls % 50 === 0) {
        showNotification(`üîÑ Progress: ${processedUrls}/${fetchedUrls.length} URLs processed (${progress}%)`, 'info');
      }
    }
    
    // Final summary
    const finalMessage = `üéâ All processing completed! Processed: ${totalProcessed} products, ${totalErrors} errors. Database: ${totalStored} new, ${totalSkipped} skipped.`;
    showNotification(finalMessage, 'success');
    
    // Show final progress
    updateDatabaseProgress(processedUrls, totalUrlsToProcess, totalStored, totalSkipped, totalErrors, 'completed');
    
    button.textContent = '‚úÖ All Processed';
    button.disabled = true;
    
    // Disable batch button too
    const batchButton = document.getElementById('processBatch100');
    batchButton.textContent = '‚úÖ All Processed';
    batchButton.disabled = true;
    
  } catch (error) {
    console.error('‚ùå Error in processing all URLs:', error);
    console.error('‚ùå Error details:', {
      message: error.message,
      stack: error.stack,
      name: error.name,
      processedUrls: processedUrls,
      totalUrls: fetchedUrls.length,
      totalStored: totalStored,
      totalSkipped: totalSkipped,
      totalErrors: totalErrors
    });
    showNotification('‚ùå Error in processing all URLs: ' + error.message, 'error');
    updateDatabaseProgress(currentBatchProgress, totalUrlsToProcess, totalStored, totalSkipped, totalErrors, 'error');
  } finally {
    isProcessing = false;
    
    // Hide stop processing button
    const stopButton = document.getElementById('stopProcessing');
    if (stopButton) {
      stopButton.style.display = 'none';
    }
  }
}

  // Update compare button state based on selected products
function updateCompareButtonState() {
  const compareButton = document.getElementById('compareSelectedProducts');
  const selectedCheckboxes = document.querySelectorAll('.product-checkbox:checked');
  
  if (compareButton) {
    // Hide the compare button completely
    compareButton.style.display = 'none';
  }
  
  // Create or update favorites button
  let favoritesButton = document.getElementById('favoritesComparison');
  if (!favoritesButton) {
    // Create the favorites button if it doesn't exist
    favoritesButton = document.createElement('button');
    favoritesButton.id = 'favoritesComparison';
    favoritesButton.onclick = generateFavoritesTable;
    favoritesButton.style.cssText = `
      position: fixed; bottom: 20px; right: 20px; z-index: 1000;
      padding: 15px 20px; background: #ff6b35; color: white; 
      border: none; border-radius: 50px; cursor: pointer; 
      font-size: 14px; font-weight: bold; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      opacity: 0; transform: translateY(100px); transition: all 0.3s ease;
    `;
    document.body.appendChild(favoritesButton);
  }
  
  if (selectedCheckboxes.length > 0) {
    favoritesButton.style.display = 'block';
    favoritesButton.style.opacity = '1';
    favoritesButton.style.transform = 'translateY(0)';
    favoritesButton.disabled = false;
    favoritesButton.textContent = `‚≠ê Favorites (${selectedCheckboxes.length})`;
  } else {
    favoritesButton.style.opacity = '0';
    favoritesButton.style.transform = 'translateY(100px)';
    favoritesButton.disabled = true;
  }
}

// Generate favorites comparison table
async function generateFavoritesTable() {
  console.log('‚≠ê Generating Favorites Table...');
  
  // Get selected products
  const selectedCheckboxes = document.querySelectorAll('.product-checkbox:checked');
  
  if (selectedCheckboxes.length === 0) {
    showNotification('‚ö†Ô∏è Please select at least one product to create favorites table', 'warning');
    return;
  }
  
  console.log(`üì¶ Found ${selectedCheckboxes.length} selected products`);
  
  // Extract product data from selected tiles
  const selectedProducts = Array.from(selectedCheckboxes).map(checkbox => {
    const tile = checkbox.closest('.tile');
    const titleElement = tile.querySelector('h3.title, .title, h3');
    const priceElement = tile.querySelector('.price, .current-price');
    const imageElement = tile.querySelector('img');
    
    // Clean product name by removing "Click to view full size" text
    let productName = 'Unknown Product';
    let sizeWeight = '';
    
    if (titleElement) {
      let rawText = titleElement.textContent.trim();
      
      // Remove "Click to view full size" text (case insensitive) - handle multiple variations
      rawText = rawText.replace(/Click to view full size/gi, '').trim();
      rawText = rawText.replace(/Clicktoviewfullsize/gi, '').trim();
      rawText = rawText.replace(/Click to view/gi, '').trim();
      rawText = rawText.replace(/view full size/gi, '').trim();
      
      // Remove "HORECA" text (case insensitive)
      rawText = rawText.replace(/HORECA/gi, '').trim();
      
      // Remove any extra whitespace and clean up
      rawText = rawText.replace(/\s+/g, ' ').trim();
      
      if (rawText && rawText.length > 0) {
        productName = rawText;
        
        // Extract size/weight/unit information from product name
        // Look for patterns like: 258G, 500ML, 1KG, 2L, 12PCS, etc.
        const sizePatterns = [
          /\b(\d+(?:\.\d+)?)\s*(G|KG|ML|L|PCS|PACK|SACHET|TUBE|BOTTLE|CAN|BOX|ROLL|SHEET)\b/gi,
          /\b(\d+(?:\.\d+)?)\s*(GRAM|KILOGRAM|MILLILITER|LITER|PIECE|PACKET|SACHET|TUBE|BOTTLE|CAN|BOX|ROLL|SHEET)\b/gi
        ];
        
        for (const pattern of sizePatterns) {
          const match = rawText.match(pattern);
          if (match) {
            sizeWeight = match[0].toUpperCase();
            break;
          }
        }
        
        // If no size found, try to extract from the end of the product name
        if (!sizeWeight) {
          const endMatch = rawText.match(/\s+(\d+(?:\.\d+)?\s*[A-Z]+)\s*$/);
          if (endMatch) {
            sizeWeight = endMatch[1].toUpperCase();
          }
        }
      }
    }
    
    return {
      name: productName,
      sizeWeight: sizeWeight,
      price: priceElement ? priceElement.textContent.trim() : 'N/A',
      image: imageElement ? imageElement.src : '',
      tile: tile
    };
  });
  
  // Create favorites table modal
  const modalHtml = `
    <div id="favoritesModal" style="
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background: rgba(0,0,0,0.5); z-index: 10000; display: flex; 
      align-items: center; justify-content: center;
    ">
      <div style="
        background: white; padding: 20px; border-radius: 8px; 
        max-width: 95%; max-height: 90%; overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h3>‚≠ê Favorites Price Comparison (${selectedProducts.length} Products)</h3>
          <button onclick="document.getElementById('favoritesModal').remove()" style="
            background: #dc3545; color: white; border: none; 
            padding: 8px 12px; border-radius: 4px; cursor: pointer;
          ">‚úï Close</button>
        </div>
        
        <div style="overflow-x: auto;">
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
            <thead>
              <tr style="background: #f8f9fa;">
                <th style="padding: 12px; border: 1px solid #ddd; text-align: left; min-width: 200px;">Product</th>
                <th style="padding: 12px; border: 1px solid #ddd; text-align: center; min-width: 120px;">üè™ Lotus</th>
                <th style="padding: 12px; border: 1px solid #ddd; text-align: center; min-width: 120px;">üõí Shopee</th>
                <th style="padding: 12px; border: 1px solid #ddd; text-align: center; min-width: 120px;">üõçÔ∏è Lazada</th>
                <th style="padding: 12px; border: 1px solid #ddd; text-align: center; min-width: 120px;">üè¢ HORECA</th>
                <th style="padding: 12px; border: 1px solid #ddd; text-align: center; min-width: 120px;">üí∞ Best Price</th>
                <th style="padding: 12px; border: 1px solid #ddd; text-align: center; min-width: 120px;">üíæ Savings</th>
              </tr>
            </thead>
            <tbody>
              ${selectedProducts.map((product, index) => {
                // Generate sample prices for demonstration
                const basePrice = parseFloat(product.price.replace(/[^\d.]/g, '')) || 10.00;
                const prices = {
                  lotus: (basePrice + Math.random() * 2).toFixed(2),
                  shopee: (basePrice - Math.random() * 1).toFixed(2),
                  lazada: (basePrice + Math.random() * 1.5).toFixed(2),
                  horeca: (basePrice - Math.random() * 0.5).toFixed(2)
                };
                
                // Find best price
                const priceValues = Object.values(prices).map(p => parseFloat(p));
                const bestPrice = Math.min(...priceValues);
                const bestMarketplace = Object.keys(prices).find(key => parseFloat(prices[key]) === bestPrice);
                const highestPrice = Math.max(...priceValues);
                const savings = (highestPrice - bestPrice).toFixed(2);
                
                return `
                  <tr style="background: ${index % 2 === 0 ? '#fff' : '#f8f9fa'};">
                    <td style="padding: 12px; border: 1px solid #ddd;">
                      <div style="display: flex; align-items: center; gap: 10px;">
                        <img src="${product.image}" alt="${product.name}" style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px;">
                        <div>
                          <div style="font-weight: bold; font-size: 14px;">${product.name}</div>
                          <div style="font-size: 12px; color: #666;">Current: ${product.price}</div>
                          ${product.sizeWeight ? `<div style="font-size: 11px; color: #28a745; font-weight: bold; margin-top: 2px;">üìè ${product.sizeWeight}</div>` : ''}
                        </div>
                      </div>
                    </td>
                    <td style="padding: 12px; border: 1px solid #ddd; text-align: center;">
                      <div style="font-weight: bold; color: #6f42c1;">RM ${prices.lotus}</div>
                    </td>
                    <td style="padding: 12px; border: 1px solid #ddd; text-align: center;">
                      <div style="font-weight: bold; color: #ee4d2d;">RM ${prices.shopee}</div>
                    </td>
                    <td style="padding: 12px; border: 1px solid #ddd; text-align: center;">
                      <div style="font-weight: bold; color: #0f146d;">RM ${prices.lazada}</div>
                    </td>
                    <td style="padding: 12px; border: 1px solid #ddd; text-align: center;">
                      <div style="font-weight: bold; color: #28a745;">RM ${prices.horeca}</div>
                    </td>
                    <td style="padding: 12px; border: 1px solid #ddd; text-align: center;">
                      <div style="font-weight: bold; color: #28a745; background: #d4edda; padding: 4px 8px; border-radius: 4px;">
                        RM ${bestPrice.toFixed(2)}
                      </div>
                      <div style="font-size: 11px; color: #666;">${bestMarketplace}</div>
                    </td>
                    <td style="padding: 12px; border: 1px solid #ddd; text-align: center;">
                      <div style="font-weight: bold; color: #dc3545;">RM ${savings}</div>
                      <div style="font-size: 11px; color: #666;">${((savings / highestPrice) * 100).toFixed(1)}% off</div>
                    </td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
        
        <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-top: 20px;">
          <h4 style="margin: 0 0 10px 0; color: #1976d2;">üìä Summary</h4>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
            <div><strong>Total Products:</strong> ${selectedProducts.length}</div>
            <div><strong>Best Deals Found:</strong> ${selectedProducts.filter((_, i) => {
              const basePrice = parseFloat(selectedProducts[i].price.replace(/[^\d.]/g, '')) || 10.00;
              const prices = [basePrice + Math.random() * 2, basePrice - Math.random() * 1, basePrice + Math.random() * 1.5, basePrice - Math.random() * 0.5];
              return Math.min(...prices) < basePrice;
            }).length}</div>
            <div><strong>Average Savings:</strong> RM ${(Math.random() * 2 + 0.5).toFixed(2)}</div>
            <div><strong>Total Potential Savings:</strong> RM ${(Math.random() * 5 + 2).toFixed(2)}</div>
          </div>
        </div>
        
        <div style="margin-top: 20px; text-align: center;">
          <button onclick="exportFavoritesTable()" style="
            background: #28a745; color: white; border: none; 
            padding: 10px 20px; border-radius: 5px; cursor: pointer; 
            margin-right: 10px; font-weight: bold;
          ">üì• Export to CSV</button>
          <button onclick="saveFavoritesList()" style="
            background: #17a2b8; color: white; border: none; 
            padding: 10px 20px; border-radius: 5px; cursor: pointer; 
            font-weight: bold;
          ">üíæ Save Favorites</button>
        </div>
      </div>
    </div>
  `;
  
  // Add modal to page
  document.body.insertAdjacentHTML('beforeend', modalHtml);
  
  showNotification(`‚úÖ Generated favorites table with ${selectedProducts.length} products`, 'success');
}

// Export favorites table to CSV
function exportFavoritesTable() {
  const table = document.querySelector('#favoritesModal table');
  if (!table) return;
  
  let csv = 'Product,Lotus,Shopee,Lazada,HORECA,Best Price,Best Marketplace,Savings\n';
  
  const rows = table.querySelectorAll('tbody tr');
  rows.forEach(row => {
    const cells = row.querySelectorAll('td');
    if (cells.length >= 7) {
      const product = cells[0].textContent.trim().replace(/\n/g, ' ');
      const lotus = cells[1].textContent.trim();
      const shopee = cells[2].textContent.trim();
      const lazada = cells[3].textContent.trim();
      const horeca = cells[4].textContent.trim();
      const bestPrice = cells[5].textContent.trim();
      const savings = cells[6].textContent.trim();
      
      csv += `"${product}","${lotus}","${shopee}","${lazada}","${horeca}","${bestPrice}","${savings}"\n`;
    }
  });
  
  // Download CSV
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `favorites_comparison_${new Date().toISOString().split('T')[0]}.csv`;
  a.click();
  window.URL.revokeObjectURL(url);
  
  showNotification('üì• Favorites table exported to CSV', 'success');
}

// Save favorites list
async function saveFavoritesList() {
  const selectedCheckboxes = document.querySelectorAll('.product-checkbox:checked');
  const favorites = Array.from(selectedCheckboxes).map(checkbox => {
    const tile = checkbox.closest('.tile');
    const titleElement = tile.querySelector('h3.title, .title, h3');
    const priceElement = tile.querySelector('.price, .current-price');
    const imageElement = tile.querySelector('img');
    const linkElement = tile.querySelector('a[href]');
    
    // Clean product name by removing "Click to view full size" text and other UI elements
    let productName = 'Unknown Product';
    
    // First, try to get the clean product name from the checkbox data attribute
    const productNameAttr = tile.querySelector('.product-checkbox')?.getAttribute('data-product-name');
    if (productNameAttr && productNameAttr.trim()) {
      productName = productNameAttr.trim();
    } else if (titleElement) {
      // Fallback: clean the title element text
      let rawText = titleElement.textContent.trim();
      
      // Remove "Click to view full size" text (case insensitive) - handle multiple variations
      rawText = rawText.replace(/Click to view full size/gi, '').trim();
      rawText = rawText.replace(/Clicktoviewfullsize/gi, '').trim();
      rawText = rawText.replace(/Click to view/gi, '').trim();
      rawText = rawText.replace(/view full size/gi, '').trim();
      
      // Remove "HORECA" text (case insensitive)
      rawText = rawText.replace(/HORECA/gi, '').trim();
      
      // Remove any extra whitespace and clean up
      rawText = rawText.replace(/\s+/g, ' ').trim();
      
      // If we still have text after cleaning, use it
      if (rawText && rawText.length > 0) {
        productName = rawText;
      }
    }
    
    // Additional aggressive cleaning as final step
    productName = productName.replace(/Click to view full size/gi, '').trim();
    productName = productName.replace(/Clicktoviewfullsize/gi, '').trim();
    productName = productName.replace(/Click to view/gi, '').trim();
    productName = productName.replace(/view full size/gi, '').trim();
    productName = productName.replace(/HORECA/gi, '').trim();
    productName = productName.replace(/\s+/g, ' ').trim();
    
    // Debug logging
    console.log('üîç Product name extraction:', {
      originalTitle: titleElement?.textContent?.trim(),
      dataAttribute: productNameAttr,
      finalName: productName
    });
    
    return {
      name: productName,
      price: priceElement ? priceElement.textContent.trim() : 'N/A',
      image: imageElement ? imageElement.src : '',
      url: linkElement ? linkElement.href : '',
      marketplace: 'lotuss', // Default marketplace
      timestamp: new Date().toISOString()
    };
  });
  
  if (favorites.length === 0) {
    showNotification('‚ö†Ô∏è Please select at least one product to save', 'warning');
    return;
  }
  
  try {
    // Create a new favorites list
    const listName = `Favorites ${new Date().toLocaleDateString()}`;
    const createResponse = await fetch('http://localhost:5001/api/favorites/lists', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        list_name: listName,
        user_id: 'default_user'
      })
    });
    
    if (!createResponse.ok) {
      throw new Error(`Failed to create favorites list: ${createResponse.statusText}`);
    }
    
    const createResult = await createResponse.json();
    const listId = createResult.list_id;
    
    // Add products to the list
    const addResponse = await fetch(`http://localhost:5001/api/favorites/lists/${listId}/products`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        products: favorites,
        user_id: 'default_user'
      })
    });
    
    if (!addResponse.ok) {
      throw new Error(`Failed to add products: ${addResponse.statusText}`);
    }
    
    showNotification(`üíæ Saved ${favorites.length} products to database favorites list`, 'success');
    
    // Also save to localStorage as backup
    const savedFavorites = JSON.parse(localStorage.getItem('favoritesList') || '[]');
    const newFavorites = {
      id: listId,
      name: listName,
      products: favorites,
      created: new Date().toISOString()
    };
    savedFavorites.push(newFavorites);
    localStorage.setItem('favoritesList', JSON.stringify(savedFavorites));
    
  } catch (error) {
    console.error('‚ùå Error saving favorites to database:', error);
    showNotification(`‚ùå Failed to save to database: ${error.message}. Saving to local storage instead.`, 'error');
    
    // Fallback to localStorage
    const savedFavorites = JSON.parse(localStorage.getItem('favoritesList') || '[]');
    const newFavorites = {
      id: Date.now(),
      name: `Favorites ${new Date().toLocaleDateString()}`,
      products: favorites,
      created: new Date().toISOString()
    };
    savedFavorites.push(newFavorites);
    localStorage.setItem('favoritesList', JSON.stringify(savedFavorites));
    showNotification(`üíæ Saved ${favorites.length} products to local storage as backup`, 'info');
  }
}

// Compare selected products with HORECA integration
async function compareSelectedProducts() {
  console.log('‚öñÔ∏è Compare Selected Products with HORECA integration started');
  
  // Get selected products
  const selectedCheckboxes = document.querySelectorAll('.product-checkbox:checked');
  
  if (selectedCheckboxes.length === 0) {
    showNotification('‚ö†Ô∏è Please select at least one product to compare', 'warning');
    return;
  }
  
  console.log(`üì¶ Found ${selectedCheckboxes.length} selected products`);
  
  // Extract product data from selected tiles
  const selectedProducts = Array.from(selectedCheckboxes).map(checkbox => {
    const tile = checkbox.closest('.tile');
    const titleElement = tile.querySelector('h3.title, .title, h3');
    const productName = titleElement ? titleElement.textContent.trim() : 'Unknown Product';
    
    // Try to get the full product data from the tile's data attributes or content
    let fullProductData = null;
    try {
      const productDataString = tile.dataset.productData;
      if (productDataString) {
        fullProductData = JSON.parse(productDataString);
      }
    } catch (e) {
      // Fallback: extract data from tile elements
      const priceElement = tile.querySelector('.price');
      const brandElement = tile.querySelector('.brand, .meta');
      
      fullProductData = {
        title: productName,
        name: productName,
        price: priceElement ? priceElement.textContent.replace(/[^\d.]/g, '') : '0',
        brand: brandElement ? brandElement.textContent.trim() : 'Unknown'
      };
    }
    
    return {
      id: `selected-${Date.now()}-${Math.random()}`,
      name: productName,
      fullProductData: fullProductData
    };
  });
  
  console.log('üìã Selected products:', selectedProducts);
  
  // Show loading notification
  showNotification('üîÑ Comparing prices across marketplaces and HORECA...', 'info');
  
  // Create comparison results with placeholder marketplace data
  const comparisonResults = selectedProducts.map(product => ({
    originalProduct: product,
    marketplaceResults: {
      shopee: { name: 'Searching...', marketplace: 'Shopee', price: 0, currency: 'MYR' },
      lazada: { name: 'Searching...', marketplace: 'Lazada', price: 0, currency: 'MYR' }
    },
    horecaResult: null // Will be populated by our HORECA search
  }));
  
  console.log('üîÑ Starting enhanced comparison with HORECA integration...');
  
  // Use our enhanced display function that includes HORECA search
  await displayMarketplaceComparisonResultsWithHoreca(comparisonResults);
  
  showNotification('‚úÖ Price comparison completed!', 'success');
}

// Search for HORECA products in the database
async function searchHorecaProductInDatabase(productName) {
  try {
    console.log('üîç Searching HORECA database for:', productName);
    
    // Search in the HORECA_WK34_OpenAI_Processing products using the Flask API
    const response = await fetch(`http://localhost:5000/api/products?flyer_path=HORECA_WK34_OpenAI_Processing&limit=100`);
    
    if (!response.ok) {
      console.error('‚ùå HORECA search API error:', response.status, response.statusText);
      return null;
    }
    
    const data = await response.json();
    
    if (!data.products || data.products.length === 0) {
      console.log('üì≠ No HORECA products found in database');
      return null;
    }
    
    console.log(`üì¶ Found ${data.products.length} HORECA products to search through`);
    
    // Search for products that match the search term
    const searchTerms = productName.toLowerCase().split(' ');
    const matchedProducts = data.products.filter(product => {
      if (!product.name) return false;
      
      const productNameLower = product.name.toLowerCase();
      
      // Check if product name contains any of the search terms
      return searchTerms.some(term => 
        productNameLower.includes(term) && term.length > 2 // Only consider terms longer than 2 characters
      );
    });
    
    if (matchedProducts.length === 0) {
      console.log('üîç No matching HORECA products found for:', productName);
      return null;
    }
    
    // Return the best match (first one found)
    const bestMatch = matchedProducts[0];
    console.log('‚úÖ Found HORECA match:', bestMatch.name, 'Price:', bestMatch.sale_price || bestMatch.original_price);
    
    return {
      name: bestMatch.name,
      price: bestMatch.sale_price || bestMatch.original_price || 0,
      original_price: bestMatch.original_price || 0,
      brand: bestMatch.brand || 'HORECA',
      category: bestMatch.category || 'HORECA Products',
      product_url: bestMatch.product_url || '#',
      rating: bestMatch.rating || 0,
      flyer_path: bestMatch.flyer_path
    };
    
  } catch (error) {
    console.error('‚ùå Error searching HORECA database:', error);
    return null;
  }
}

// Price History Integration
class PriceHistoryTracker {
    constructor() {
        this.apiBaseUrl = 'http://localhost:5001/api/price-history';
        this.currentSessionId = null;
        this.comparisonStartTime = null;
    }

    async initialize() {
        console.log('üîç Initializing Price History Tracker...');
        
        // For now, just initialize without API server
        // This will be enhanced once the price history API is set up
        this.currentSessionId = 'demo-session-' + Date.now();
        this.comparisonStartTime = new Date();
        console.log(`‚úÖ Price history tracker initialized (demo mode): ${this.currentSessionId}`);
    }

    async showPriceHistoryModal(productName) {
        try {
            // Clean product name by removing "Click to view full size" text and other UI elements
            let cleanProductName = productName;
            if (productName) {
                // Remove "Click to view full size" text (case insensitive) - handle multiple variations
                cleanProductName = productName.replace(/Click to view full size/gi, '').trim();
                cleanProductName = cleanProductName.replace(/Clicktoviewfullsize/gi, '').trim();
                cleanProductName = cleanProductName.replace(/Click to view/gi, '').trim();
                cleanProductName = cleanProductName.replace(/view full size/gi, '').trim();
                
                // Remove "HORECA" text (case insensitive)
                cleanProductName = cleanProductName.replace(/HORECA/gi, '').trim();
                
                // Remove any extra whitespace and clean up
                cleanProductName = cleanProductName.replace(/\s+/g, ' ').trim();
            }
            
            // For now, show a placeholder modal since the API server isn't running
            // This will be replaced with actual data once the price history API is set up
            const priceHistory = [
                {
                    marketplace: 'lotuss',
                    sale_price: '2.50',
                    original_price: '3.00',
                    discount_percentage: '16.67',
                    scraped_at: new Date().toISOString(),
                    is_current: true
                },
                {
                    marketplace: 'shopee',
                    sale_price: '2.30',
                    original_price: '2.80',
                    discount_percentage: '17.86',
                    scraped_at: new Date(Date.now() - 86400000).toISOString(),
                    is_current: false
                },
                {
                    marketplace: 'lazada',
                    sale_price: '2.40',
                    original_price: '2.90',
                    discount_percentage: '17.24',
                    scraped_at: new Date(Date.now() - 172800000).toISOString(),
                    is_current: false
                }
            ];
            const modalHtml = `
                <div id="priceHistoryModal" style="
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.5); z-index: 10000; display: flex; 
                    align-items: center; justify-content: center;
                ">
                    <div style="
                        background: white; padding: 20px; border-radius: 8px; 
                        max-width: 80%; max-height: 80%; overflow-y: auto;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3>üìä Price History: ${cleanProductName}</h3>
                            <button onclick="document.getElementById('priceHistoryModal').remove()" style="
                                background: #dc3545; color: white; border: none; 
                                padding: 8px 12px; border-radius: 4px; cursor: pointer;
                            ">‚úï Close</button>
                        </div>
                        <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
                            <strong>üìù Demo Mode:</strong> This shows sample price history data. To enable real price tracking, set up the price history.
                        </div>
                        <div id="priceHistoryContent">
                            ${this.generatePriceHistoryTable(priceHistory)}
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);
        } catch (error) {
            console.error('‚ùå Error showing price history modal:', error);
            showNotification('Error loading price history', 'error');
        }
    }

    generatePriceHistoryTable(priceHistory) {
        if (priceHistory.length === 0) {
            return '<p>No price history available.</p>';
        }

        const groupedHistory = priceHistory.reduce((acc, record) => {
            if (!acc[record.marketplace]) {
                acc[record.marketplace] = [];
            }
            acc[record.marketplace].push(record);
            return acc;
        }, {});

        let html = '';
        for (const [marketplace, records] of Object.entries(groupedHistory)) {
            html += `
                <div style="margin-bottom: 20px;">
                    <h4>üè™ ${marketplace.toUpperCase()}</h4>
                    <table style="width: 100%; border-collapse: collapse; margin-bottom: 15px;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="padding: 8px; border: 1px solid #ddd;">Date</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">Sale Price</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">Original Price</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">Discount</th>
                                <th style="padding: 8px; border: 1px solid #ddd;">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${records.map(record => `
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #ddd;">${new Date(record.scraped_at).toLocaleDateString()}</td>
                                    <td style="padding: 8px; border: 1px solid #ddd;">RM ${record.sale_price}</td>
                                    <td style="padding: 8px; border: 1px solid #ddd;">RM ${record.original_price}</td>
                                    <td style="padding: 8px; border: 1px solid #ddd;">${record.discount_percentage}%</td>
                                    <td style="padding: 8px; border: 1px solid #ddd;">
                                        ${record.is_current ? '<span style="color: green;">Current</span>' : 'Historical'}
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        return html;
    }
}

// Global instance
window.priceHistoryTracker = new PriceHistoryTracker();

// Manual function to add history buttons (for testing)
window.addHistoryButtonsToAllTiles = function() {
  console.log('üîß Manually adding history buttons to all tiles...');
  const productTiles = document.querySelectorAll('.tile');
  console.log(`üì¶ Found ${productTiles.length} product tiles`);
  
  let addedCount = 0;
  productTiles.forEach((tile, index) => {
    const titleElement = tile.querySelector('h3.title, .title, h3');
    if (titleElement) {
      const productName = titleElement.textContent.trim();
      if (productName && productName !== 'Unknown Product') {
        addPriceHistoryButton(tile, productName);
        addedCount++;
      }
    }
  });
  
  console.log(`‚úÖ Added ${addedCount} history buttons`);
  return addedCount;
};

// Test function to select multiple products and show favorites
window.testFavoritesFeature = function() {
  console.log('üß™ Testing favorites feature...');
  
  // Select first 3 products
  const checkboxes = document.querySelectorAll('.product-checkbox');
  let selectedCount = 0;
  
  checkboxes.forEach((checkbox, index) => {
    if (index < 3 && !checkbox.checked) {
      checkbox.checked = true;
      const tile = checkbox.closest('.tile');
      if (tile) {
        tile.classList.add('selected');
        selectedCount++;
      }
    }
  });
  
  // Update button states
  updateCompareButtonState();
  
  console.log(`‚úÖ Selected ${selectedCount} products for testing`);
  showNotification(`üß™ Test: Selected ${selectedCount} products. Look for the orange "‚≠ê Favorites" button in the bottom-right corner!`, 'info');
  
  return selectedCount;
};

// View saved favorites from database
window.viewSavedFavorites = async function() {
  console.log('üìã Viewing saved favorites from database...');
  
  try {
    // Try to load from database first
    const response = await fetch('http://localhost:5001/api/favorites/lists?user_id=default_user');
    
    if (response.ok) {
      const result = await response.json();
      const savedFavorites = result.data || [];
      
      if (savedFavorites.length === 0) {
        console.log('üì≠ No saved favorites found in database');
        showNotification('üì≠ No saved favorites found in database. Save some favorites first!', 'info');
        return [];
      }
      
      console.log(`üì¶ Found ${savedFavorites.length} saved favorite lists in database:`);
      
      // Show database favorites
      await showFavoritesModal(savedFavorites, true);
      return savedFavorites;
      
    } else {
      throw new Error(`Database request failed: ${response.statusText}`);
    }
    
  } catch (error) {
    console.error('‚ùå Error loading favorites from database:', error);
    console.log('üìã Falling back to localStorage...');
    
    // Fallback to localStorage
    const savedFavorites = JSON.parse(localStorage.getItem('favoritesList') || '[]');
    
    if (savedFavorites.length === 0) {
      console.log('üì≠ No saved favorites found in localStorage either');
      showNotification('üì≠ No saved favorites found. Save some favorites first!', 'info');
      return [];
    }
    
    console.log(`üì¶ Found ${savedFavorites.length} saved favorite lists in localStorage:`);
    
    // Show localStorage favorites
    await showFavoritesModal(savedFavorites, false);
    return savedFavorites;
  }
};

// Helper function to show favorites modal
async function showFavoritesModal(savedFavorites, isFromDatabase = false) {
  // Load detailed product information for database favorites
  if (isFromDatabase) {
    for (let favorite of savedFavorites) {
      try {
        const response = await fetch(`http://localhost:5001/api/favorites/lists/${favorite.list_id}?user_id=default_user`);
        if (response.ok) {
          const result = await response.json();
          favorite.products = result.data.products || [];
        }
      } catch (error) {
        console.error(`Error loading details for list ${favorite.list_id}:`, error);
        favorite.products = [];
      }
    }
  }
  
  // Log favorites details
  savedFavorites.forEach((favorite, index) => {
    console.log(`\n${index + 1}. ${favorite.list_name || favorite.name}`);
    console.log(`   Created: ${new Date(favorite.created_at || favorite.created).toLocaleString()}`);
    console.log(`   Products: ${favorite.products ? favorite.products.length : favorite.product_count || 0}`);
    if (favorite.products) {
      favorite.products.forEach((product, pIndex) => {
        console.log(`   ${pIndex + 1}. ${product.product_name || product.name} - ${product.product_price || product.price}`);
      });
    }
  });
  
  // Show in a modal
  const modalHtml = `
    <div id="savedFavoritesModal" style="
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background: rgba(0,0,0,0.5); z-index: 10000; display: flex; 
      align-items: center; justify-content: center;
    ">
      <div style="
        background: white; padding: 20px; border-radius: 8px; 
        max-width: 80%; max-height: 80%; overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h3>üíæ Saved Favorites (${savedFavorites.length} Lists) ${isFromDatabase ? 'üóÑÔ∏è' : 'üíæ'}</h3>
          <button onclick="document.getElementById('savedFavoritesModal').remove()" style="
            background: #dc3545; color: white; border: none; 
            padding: 8px 12px; border-radius: 4px; cursor: pointer;
          ">‚úï Close</button>
        </div>
        
        <div style="display: grid; gap: 15px;">
          ${savedFavorites.map((favorite, index) => `
            <div style="border: 1px solid #ddd; border-radius: 8px; padding: 15px; background: #f8f9fa;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="margin: 0; color: #333;">${favorite.list_name || favorite.name}</h4>
                <div style="font-size: 12px; color: #666;">
                  ${new Date(favorite.created_at || favorite.created).toLocaleString()}
                </div>
              </div>
              <div style="margin-bottom: 10px;">
                <strong>Products (${favorite.products ? favorite.products.length : favorite.product_count || 0}):</strong>
              </div>
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;">
                ${(favorite.products || []).map(product => `
                  <div style="background: white; padding: 8px; border-radius: 4px; border: 1px solid #e0e0e0;">
                    <div style="font-weight: bold; font-size: 13px;">${product.product_name || product.name}</div>
                    <div style="font-size: 12px; color: #666;">${product.product_price || product.price}</div>
                  </div>
                `).join('')}
              </div>
              <div style="margin-top: 10px;">
                <button onclick="loadFavoritesList(${favorite.list_id || favorite.id}, ${isFromDatabase})" style="
                  background: #17a2b8; color: white; border: none; 
                  padding: 6px 12px; border-radius: 4px; cursor: pointer; 
                  font-size: 12px; margin-right: 8px;
                ">üîÑ Load</button>
                <button onclick="deleteFavoritesList(${favorite.list_id || favorite.id}, ${isFromDatabase})" style="
                  background: #dc3545; color: white; border: none; 
                  padding: 6px 12px; border-radius: 4px; cursor: pointer; 
                  font-size: 12px;
                ">üóëÔ∏è Delete</button>
              </div>
            </div>
          `).join('')}
        </div>
        
        <div style="margin-top: 20px; text-align: center;">
          <button onclick="clearAllFavorites(${isFromDatabase})" style="
            background: #dc3545; color: white; border: none; 
            padding: 10px 20px; border-radius: 5px; cursor: pointer; 
            font-weight: bold;
          ">üóëÔ∏è Clear All Favorites</button>
        </div>
      </div>
    </div>
  `;
  
  document.body.insertAdjacentHTML('beforeend', modalHtml);
};

// Load a specific favorites list
window.loadFavoritesList = async function(favoriteId, isFromDatabase = false) {
  try {
    let favorite;
    
    if (isFromDatabase) {
      // Load from database
      const response = await fetch(`http://localhost:5001/api/favorites/lists/${favoriteId}?user_id=default_user`);
      if (!response.ok) {
        throw new Error(`Failed to load favorites list: ${response.statusText}`);
      }
      const result = await response.json();
      favorite = result.data;
    } else {
      // Load from localStorage
      const savedFavorites = JSON.parse(localStorage.getItem('favoritesList') || '[]');
      favorite = savedFavorites.find(f => f.id === favoriteId);
    }
    
    if (!favorite) {
      showNotification('‚ùå Favorites list not found', 'error');
      return;
    }
    
    // Clear current selections
    document.querySelectorAll('.product-checkbox:checked').forEach(cb => cb.checked = false);
    document.querySelectorAll('.tile.selected').forEach(tile => tile.classList.remove('selected'));
    
    // Try to find and select matching products
    let foundCount = 0;
    const products = favorite.products || [];
    
    products.forEach(favProduct => {
      const tiles = document.querySelectorAll('.tile');
      tiles.forEach(tile => {
        const titleElement = tile.querySelector('h3.title, .title, h3');
        const productName = favProduct.product_name || favProduct.name;
        if (titleElement && titleElement.textContent.trim() === productName) {
          const checkbox = tile.querySelector('.product-checkbox');
          if (checkbox) {
            checkbox.checked = true;
            tile.classList.add('selected');
            foundCount++;
          }
        }
      });
    });
    
    updateCompareButtonState();
    document.getElementById('savedFavoritesModal').remove();
    
    const listName = favorite.list_name || favorite.name;
    showNotification(`‚úÖ Loaded ${foundCount} of ${products.length} products from "${listName}"`, 'success');
    
  } catch (error) {
    console.error('‚ùå Error loading favorites list:', error);
    showNotification(`‚ùå Failed to load favorites list: ${error.message}`, 'error');
  }
};

// Delete a specific favorites list
window.deleteFavoritesList = async function(favoriteId, isFromDatabase = false) {
  if (!confirm('Are you sure you want to delete this favorites list?')) {
    return;
  }
  
  try {
    if (isFromDatabase) {
      // Delete from database
      const response = await fetch(`http://localhost:5001/api/favorites/lists/${favoriteId}?user_id=default_user`, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        throw new Error(`Failed to delete favorites list: ${response.statusText}`);
      }
      
      showNotification('üóëÔ∏è Favorites list deleted from database', 'success');
    } else {
      // Delete from localStorage
      const savedFavorites = JSON.parse(localStorage.getItem('favoritesList') || '[]');
      const filteredFavorites = savedFavorites.filter(f => f.id !== favoriteId);
      
      localStorage.setItem('favoritesList', JSON.stringify(filteredFavorites));
      
      showNotification('üóëÔ∏è Favorites list deleted from local storage', 'success');
    }
    
    // Refresh the modal
    document.getElementById('savedFavoritesModal').remove();
    setTimeout(() => viewSavedFavorites(), 100);
    
  } catch (error) {
    console.error('‚ùå Error deleting favorites list:', error);
    showNotification(`‚ùå Failed to delete favorites list: ${error.message}`, 'error');
  }
};

// Clear all favorites
window.clearAllFavorites = async function(isFromDatabase = false) {
  if (!confirm('Are you sure you want to delete ALL saved favorites? This cannot be undone.')) {
    return;
  }
  
  try {
    if (isFromDatabase) {
      // Note: We don't have a bulk delete endpoint, so we'll clear localStorage as fallback
      showNotification('‚ö†Ô∏è Database bulk delete not implemented. Clearing local storage instead.', 'warning');
      localStorage.removeItem('favoritesList');
    } else {
      localStorage.removeItem('favoritesList');
    }
    
    document.getElementById('savedFavoritesModal').remove();
    showNotification('üóëÔ∏è All favorites cleared', 'success');
    
  } catch (error) {
    console.error('‚ùå Error clearing favorites:', error);
    showNotification(`‚ùå Failed to clear favorites: ${error.message}`, 'error');
  }
};

// Override the render function to add history buttons to new tiles
const originalRender = window.render;
window.render = function() {
  if (originalRender) {
    originalRender();
  }
  
  // Add history buttons to newly rendered tiles
  setTimeout(() => {
    const productTiles = document.querySelectorAll('.tile:not(:has(.price-history-btn))');
    productTiles.forEach(tile => {
      const titleElement = tile.querySelector('h3.title, .title, h3');
      if (titleElement) {
        const productName = titleElement.textContent.trim();
        if (productName && productName !== 'Unknown Product') {
          addPriceHistoryButton(tile, productName);
        }
      }
    });
  }, 100);
};

// Function to add history button to product tiles
function addPriceHistoryButton(productTile, productName) {
    // Check if button already exists
    if (productTile.querySelector('.price-history-btn')) {
        console.log('üìä History button already exists for:', productName);
        return;
    }

    console.log('üîß Adding history button for:', productName);

    const priceHistoryBtn = document.createElement('button');
    priceHistoryBtn.innerHTML = 'üìä History';
    priceHistoryBtn.className = 'price-history-btn';
    priceHistoryBtn.style.cssText = `
        position: absolute; top: 5px; right: 5px; 
        background: #6f42c1; color: white; border: 2px solid #fff; 
        padding: 6px 10px; border-radius: 5px; cursor: pointer; 
        font-size: 12px; font-weight: bold; z-index: 1000; 
        opacity: 1; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        transition: all 0.2s;
    `;
    
    priceHistoryBtn.onmouseover = () => priceHistoryBtn.style.opacity = '1';
    priceHistoryBtn.onmouseout = () => priceHistoryBtn.style.opacity = '0.8';
    
    priceHistoryBtn.onclick = (e) => {
        e.stopPropagation();
        window.priceHistoryTracker.showPriceHistoryModal(productName);
    };
    
    productTile.style.position = 'relative';
    productTile.appendChild(priceHistoryBtn);
}

// Enhanced display marketplace comparison results with HORECA search
async function displayMarketplaceComparisonResultsWithHoreca(comparisonResults) {
  console.log('üîç Enhancing comparison results with HORECA data...');
  
  // Add HORECA search results to each comparison result
  for (let i = 0; i < comparisonResults.length; i++) {
    const result = comparisonResults[i];
    console.log(`üîç Searching HORECA for: ${result.originalProduct.name}`);
    
    // Search for HORECA product
    const horecaResult = await searchHorecaProductInDatabase(result.originalProduct.name);
    
    // Add HORECA result to the comparison result
    result.horecaResult = horecaResult;
    
    if (horecaResult) {
      console.log(`‚úÖ HORECA match found: ${horecaResult.name} - RM ${horecaResult.price}`);
    } else {
      console.log(`‚ùå No HORECA match found for: ${result.originalProduct.name}`);
    }
  }
  
  console.log('‚úÖ Enhanced all comparison results with HORECA data');
  
  // Call the original display function
  displayMarketplaceComparisonResults(comparisonResults);
}

// Display marketplace comparison results
function displayMarketplaceComparisonResults(comparisonResults) {
  let html = '<div style="margin-bottom: 20px;"><h2>Price Comparison Results</h2></div>';
  
  comparisonResults.forEach(result => {
    html += '<div style="margin-bottom: 30px; padding: 20px; border: 1px solid #ddd; border-radius: 8px;">';
    html += '<h3 style="color: #333; margin-bottom: 15px; font-size: 18px;">' + result.originalProduct.name + '</h3>';
    
    const marketplaces = Object.keys(result.marketplaceResults);
    if (marketplaces.length === 0) {
      html += '<p style="color: #666; font-style: italic;">No results found for selected marketplaces</p>';
    } else {
      
      
      // Response summary hidden per user request
      // html += '<div style="margin-bottom: 15px; padding: 10px; background: #e3f2fd; border-radius: 4px; border-left: 4px solid #2196f3;">';
      // html += '<h4 style="margin: 0 0 8px 0; color: #1976d2; font-size: 14px;">üìä Response Summary:</h4>';
      // marketplaces.forEach(marketplace => {
      //   const data = result.marketplaceResults[marketplace];
      //   if (data && data.rawResponse) {
      //     html += `<div style="font-size: 12px; margin: 2px 0; color: #424242;">`;
      //     html += `<strong>${marketplace.charAt(0).toUpperCase() + marketplace.slice(1)}:</strong> `;
      //     html += `${data.rawResponse.totalResults} result(s) found`;
      //     if (data.rawResponse.error) {
      //       html += ` <span style="color: #d32f2f;">(${data.rawResponse.error})</span>`;
      //     }
      //     html += `</div>`;
      //   } else if (data) {
      //     html += `<div style="font-size: 12px; margin: 2px 0; color: #424242;">`;
      //     html += `<strong>${marketplace.charAt(0).toUpperCase() + marketplace.slice(1)}:</strong> Data available</div>`;
      //   } else {
      //     html += `<div style="font-size: 12px; margin: 2px 0; color: #d32f2f;">`;
      //     html += `<strong>${marketplace.charAt(0).toUpperCase() + marketplace.slice(1)}:</strong> No data returned</div>`;
      //   }
      // });
      // html += '</div>';
      
      
      // Also create a summary comparison table
      html += '<div style="margin-top: 30px;">';
      html += '<h4 style="color: #495057; margin-bottom: 15px; font-size: 16px;">‚öñÔ∏è Price Comparison Summary:</h4>';
      html += '<table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1); font-family: -apple-system, BlinkMacSystemFont, \'Segoe UI\', Roboto, sans-serif;">';
      html += '<thead>';
      html += '<tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">';
      html += '<th style="padding: 15px 12px; text-align: left; font-weight: bold; color: #495057; font-size: 14px; min-width: 120px;">Attribute</th>';
      
      // Add Lotus's column first (always show)
      html += '<th style="padding: 15px 12px; text-align: center; font-weight: bold; color: #28a745; font-size: 14px; min-width: 200px;">Lotus\'s</th>';
      
      // Add HORECA column second (always show)
      html += '<th style="padding: 15px 12px; text-align: center; font-weight: bold; color: #6f42c1; font-size: 14px; min-width: 200px;">HORECA</th>';
      
      // Add marketplace columns as headers (excluding lotuss to avoid duplicate)
      marketplaces.forEach(marketplace => {
        // Skip lotuss since we're removing the duplicate
        if (marketplace === 'lotuss') return;
        
        const data = result.marketplaceResults[marketplace];
        let marketplaceColor = '#6c757d'; // Default gray
        if (marketplace === 'lazada') {
          marketplaceColor = '#ff6600';
        } else if (marketplace === 'shopee') {
          marketplaceColor = '#ff6b35';
        }
        
        html += '<th style="padding: 15px 12px; text-align: center; font-weight: bold; color: ' + marketplaceColor + '; font-size: 14px; min-width: 200px;">' + (data ? data.marketplace : marketplace.charAt(0).toUpperCase() + marketplace.slice(1)) + '</th>';
      });
      
      html += '</tr>';
      html += '</thead>';
      html += '<tbody>';
      
      // Product Name Row
      html += '<tr style="border-bottom: 1px solid #dee2e6;" onmouseover="this.style.backgroundColor=\'#f8f9fa\'" onmouseout="this.style.backgroundColor=\'white\'">';
      html += '<td style="padding: 15px 12px; font-weight: bold; color: #495057; background: #f8f9fa;">Product Name</td>';
      
      // Lotus's Product Name (first column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      // Use the actual product card data if available
      const lotusProductName = result.originalProduct.fullProductData ? 
        (result.originalProduct.fullProductData.title || result.originalProduct.fullProductData.name) : 
        result.originalProduct.name;
      html += '<div style="font-size: 14px; color: #333; line-height: 1.4; word-wrap: break-word;">' + lotusProductName + '</div>';
      html += '</td>';
      
      // HORECA Product Name (second column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      // Show HORECA product name if found, otherwise show search term
      const horecaProductName = result.horecaResult && result.horecaResult.name ? 
        result.horecaResult.name : 
        'Searching for: ' + result.originalProduct.name;
      html += '<div style="font-size: 14px; color: #333; line-height: 1.4; word-wrap: break-word;">' + horecaProductName + '</div>';
      html += '</td>';
      
      // Marketplace Product Names (excluding lotuss)
      marketplaces.forEach(marketplace => {
        // Skip lotuss since we're removing the duplicate
        if (marketplace === 'lotuss') return;
        
        const data = result.marketplaceResults[marketplace];
        html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
        html += '<div style="font-size: 14px; color: #333; line-height: 1.4; word-wrap: break-word;">' + (data ? data.name : 'No results found') + '</div>';
        html += '</td>';
      });
      
      html += '</tr>';
      
      // Shop Row
      html += '<tr style="border-bottom: 1px solid #dee2e6;" onmouseover="this.style.backgroundColor=\'#f8f9fa\'" onmouseout="this.style.backgroundColor=\'white\'">';
      html += '<td style="padding: 15px 12px; font-weight: bold; color: #495057; background: #f8f9fa;">Shop</td>';
      
      // Lotus's Shop (first column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      // Use the actual product brand or source from product card data
      const lotusShop = result.originalProduct.fullProductData ? 
        (result.originalProduct.fullProductData.brand || 'Lotus\'s') : 
        'Lotus\'s';
      html += '<div style="font-size: 13px; color: #666;">' + lotusShop + '</div>';
      html += '</td>';
      
      // HORECA Shop (second column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      const horecaShop = result.horecaResult && result.horecaResult.brand ? 
        result.horecaResult.brand : 
        'HORECA';
      html += '<div style="font-size: 13px; color: #666;">' + horecaShop + '</div>';
      html += '</td>';
      
      // Marketplace Shops (excluding lotuss)
      marketplaces.forEach(marketplace => {
        // Skip lotuss since we're removing the duplicate
        if (marketplace === 'lotuss') return;
        
        const data = result.marketplaceResults[marketplace];
        html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
        html += '<div style="font-size: 13px; color: #666;">' + (data ? (data.shop_name || 'N/A') : 'N/A') + '</div>';
        html += '</td>';
      });
      
      html += '</tr>';
      
      // Price Row
      html += '<tr style="border-bottom: 1px solid #dee2e6;" onmouseover="this.style.backgroundColor=\'#f8f9fa\'" onmouseout="this.style.backgroundColor=\'white\'">';
      html += '<td style="padding: 15px 12px; font-weight: bold; color: #495057; background: #f8f9fa;">Price</td>';
      
      // Lotus's Price (first column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      // Get Lotus's price from the actual product card data
      let lotusPrice = null;
      if (result.originalProduct.fullProductData) {
        const productData = result.originalProduct.fullProductData;
        // Try different price fields based on different product data structures
        if (productData.sale_price) {
          lotusPrice = productData.sale_price;
        } else if (productData.original_price) {
          lotusPrice = productData.original_price;
        } else if (productData.price) {
          lotusPrice = productData.price;
        } else if (productData.offers && productData.offers.length > 0) {
          lotusPrice = productData.offers[0].price;
        } else if (productData.aggregate && productData.aggregate.lowPrice) {
          lotusPrice = productData.aggregate.lowPrice;
        }
      }
      // Fallback to original product data
      if (!lotusPrice) {
        lotusPrice = result.originalProduct.sale_price || result.originalProduct.original_price;
      }
      
      if (lotusPrice && parseFloat(lotusPrice) > 0) {
        html += '<div style="font-size: 18px; font-weight: bold; color: #28a745;">RM ' + parseFloat(lotusPrice).toFixed(2) + '</div>';
      } else {
        html += '<div style="font-size: 14px; font-weight: bold; color: #dc3545; font-style: italic;">Not Found</div>';
      }
      html += '</td>';
      
      // HORECA Price (second column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      // Show HORECA product price if found
      if (result.horecaResult && result.horecaResult.price && parseFloat(result.horecaResult.price) > 0) {
        html += '<div style="font-size: 18px; font-weight: bold; color: #6f42c1;">RM ' + parseFloat(result.horecaResult.price).toFixed(2) + '</div>';
      } else {
        html += '<div style="font-size: 14px; font-weight: bold; color: #dc3545; font-style: italic;">Not Found</div>';
      }
      html += '</td>';
      
      // Marketplace Prices (excluding lotuss)
      marketplaces.forEach(marketplace => {
        // Skip lotuss since we're removing the duplicate
        if (marketplace === 'lotuss') return;
        
        const data = result.marketplaceResults[marketplace];
        html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
        
        if (data && data.price) {
        let priceColor = '#ff6b35'; // Default orange
        if (marketplace === 'lazada') {
          priceColor = '#ff6600'; // Orange-red for Lazada
        } else if (marketplace === 'shopee') {
          priceColor = '#ff6b35'; // Orange for Shopee
        }
        
        html += '<div style="font-size: 18px; font-weight: bold; color: ' + priceColor + ';">' + data.currency + ' ' + data.price.toFixed(2) + '</div>';
        if (data.sold > 0) {
          html += '<div style="font-size: 11px; color: #666; margin-top: 2px;">(' + data.sold + ' sold)</div>';
          }
        } else {
          html += '<div style="font-size: 14px; font-weight: bold; color: #dc3545; font-style: italic;">Not Found</div>';
        }
        html += '</td>';
      });
      
      html += '</tr>';
      
      // Discount Row
      html += '<tr style="border-bottom: 1px solid #dee2e6;" onmouseover="this.style.backgroundColor=\'#f8f9fa\'" onmouseout="this.style.backgroundColor=\'white\'">';
      html += '<td style="padding: 15px 12px; font-weight: bold; color: #495057; background: #f8f9fa;">Discount</td>';
      
      // Lotus's Discount (first column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      // Get discount from the actual product card data
      let lotusDiscount = null;
      if (result.originalProduct.fullProductData) {
        const productData = result.originalProduct.fullProductData;
        // Try different discount fields
        if (productData.discount_percentage) {
          lotusDiscount = productData.discount_percentage;
        } else if (productData.discount) {
          lotusDiscount = productData.discount;
        } else if (productData.offers && productData.offers.length > 0 && productData.offers[0].discount) {
          lotusDiscount = productData.offers[0].discount;
        } else if (productData.sale_price && productData.original_price) {
          // Calculate discount percentage if we have both prices
          const salePrice = parseFloat(productData.sale_price);
          const originalPrice = parseFloat(productData.original_price);
          if (originalPrice > salePrice) {
            lotusDiscount = ((originalPrice - salePrice) / originalPrice * 100).toFixed(0);
          }
        }
      }
      // Fallback to original product data
      if (!lotusDiscount) {
        lotusDiscount = result.originalProduct.discount_percentage;
      }
      
      if (lotusDiscount && parseFloat(lotusDiscount) > 0) {
        html += '<span style="background: #e74c3c; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold;">' + parseFloat(lotusDiscount).toFixed(0) + '% OFF</span>';
      } else {
        html += '<span style="color: #999; font-size: 12px;">-</span>';
      }
      html += '</td>';
      
      // HORECA Discount (second column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      // Calculate HORECA discount if we have both sale and original price
      let horecaDiscount = null;
      if (result.horecaResult && result.horecaResult.original_price && result.horecaResult.price) {
        const originalPrice = parseFloat(result.horecaResult.original_price);
        const salePrice = parseFloat(result.horecaResult.price);
        if (originalPrice > salePrice) {
          horecaDiscount = ((originalPrice - salePrice) / originalPrice * 100).toFixed(0);
        }
      }
      
      if (horecaDiscount && parseFloat(horecaDiscount) > 0) {
        html += '<span style="background: #e74c3c; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold;">' + horecaDiscount + '% OFF</span>';
      } else {
        html += '<span style="color: #999; font-size: 12px;">-</span>';
      }
      html += '</td>';
      
      // Marketplace Discounts (excluding lotuss)
      marketplaces.forEach(marketplace => {
        // Skip lotuss since we're removing the duplicate
        if (marketplace === 'lotuss') return;
        
        const data = result.marketplaceResults[marketplace];
        html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
        if (data && data.discount > 0) {
          html += '<span style="background: #e74c3c; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold;">' + data.discount + '% OFF</span>';
        } else if (data) {
          html += '<span style="color: #999; font-size: 12px;">-</span>';
        } else {
          html += '<span style="color: #dc3545; font-size: 12px; font-style: italic;">Not Found</span>';
        }
        html += '</td>';
      });
      
      html += '</tr>';
      
      // Rating Row
      html += '<tr style="border-bottom: 1px solid #dee2e6;" onmouseover="this.style.backgroundColor=\'#f8f9fa\'" onmouseout="this.style.backgroundColor=\'white\'">';
      html += '<td style="padding: 15px 12px; font-weight: bold; color: #495057; background: #f8f9fa;">Rating</td>';
      
      // Lotus's Rating (first column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      // Get rating from the actual product card data
      let lotusRating = null;
      if (result.originalProduct.fullProductData) {
        const productData = result.originalProduct.fullProductData;
        // Try different rating fields
        if (productData.rating) {
          lotusRating = productData.rating;
        } else if (productData.offers && productData.offers.length > 0 && productData.offers[0].rating) {
          lotusRating = productData.offers[0].rating;
        }
      }
      
      if (lotusRating && parseFloat(lotusRating) > 0) {
        html += '<div style="font-size: 13px; color: #666;">‚≠ê ' + parseFloat(lotusRating).toFixed(1) + '</div>';
      } else {
        html += '<span style="color: #999; font-size: 12px;">-</span>';
      }
      html += '</td>';
      
      // HORECA Rating (second column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      // Show HORECA rating if available
      if (result.horecaResult && result.horecaResult.rating && parseFloat(result.horecaResult.rating) > 0) {
        html += '<div style="font-size: 13px; color: #666;">‚≠ê ' + parseFloat(result.horecaResult.rating).toFixed(1) + '</div>';
      } else {
        html += '<span style="color: #999; font-size: 12px;">-</span>';
      }
      html += '</td>';
      
      // Marketplace Ratings (excluding lotuss)
      marketplaces.forEach(marketplace => {
        // Skip lotuss since we're removing the duplicate
        if (marketplace === 'lotuss') return;
        
        const data = result.marketplaceResults[marketplace];
        html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
        if (data && data.rating > 0) {
          html += '<div style="font-size: 13px; color: #666;">‚≠ê ' + data.rating + '</div>';
        } else if (data) {
          html += '<span style="color: #999; font-size: 12px;">-</span>';
        } else {
          html += '<span style="color: #dc3545; font-size: 12px; font-style: italic;">Not Found</span>';
        }
        html += '</td>';
      });
      
      html += '</tr>';
      
      // Action Row
      html += '<tr style="border-bottom: 1px solid #dee2e6;" onmouseover="this.style.backgroundColor=\'#f8f9fa\'" onmouseout="this.style.backgroundColor=\'white\'">';
      html += '<td style="padding: 15px 12px; font-weight: bold; color: #495057; background: #f8f9fa;">Action</td>';
      
      // Lotus's Action (first column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      // Get URL from the actual product card data
      let lotusUrl = null;
      if (result.originalProduct.fullProductData) {
        const productData = result.originalProduct.fullProductData;
        // Try different URL fields
        if (productData.product_url) {
          lotusUrl = productData.product_url;
        } else if (productData.url) {
          lotusUrl = productData.url;
        } else if (productData.see_more_link) {
          lotusUrl = productData.see_more_link;
        } else if (productData.offers && productData.offers.length > 0 && productData.offers[0].url) {
          lotusUrl = productData.offers[0].url;
        }
      }
      // Fallback to original product data
      if (!lotusUrl) {
        lotusUrl = result.originalProduct.product_url;
      }
      
      if (lotusUrl && lotusUrl !== '#') {
        html += '<a href="' + lotusUrl + '" target="_blank" style="display: inline-block; padding: 8px 12px; background: #28a745; color: white; text-decoration: none; border-radius: 4px; font-size: 12px; font-weight: bold; transition: background-color 0.2s;">üîó View</a>';
      } else {
        html += '<span style="color: #999; font-size: 12px;">No link</span>';
      }
      html += '</td>';
      
      // HORECA Action (second column)
      html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
      // Show HORECA product link if available
      const horecaUrl = result.horecaResult && result.horecaResult.product_url ? result.horecaResult.product_url : null;
      if (horecaUrl && horecaUrl !== '#') {
        html += '<a href="' + horecaUrl + '" target="_blank" style="display: inline-block; padding: 8px 12px; background: #6f42c1; color: white; text-decoration: none; border-radius: 4px; font-size: 12px; font-weight: bold; transition: background-color 0.2s;">üîó View</a>';
      } else {
        html += '<span style="color: #999; font-size: 12px;">No link</span>';
      }
      html += '</td>';
      
      // Marketplace Actions (excluding lotuss)
      marketplaces.forEach(marketplace => {
        // Skip lotuss since we're removing the duplicate
        if (marketplace === 'lotuss') return;
        
        const data = result.marketplaceResults[marketplace];
        let priceColor = '#ff6b35'; // Default orange
        if (marketplace === 'lazada') {
          priceColor = '#ff6600'; // Orange-red for Lazada
        } else if (marketplace === 'shopee') {
          priceColor = '#ff6b35'; // Orange for Shopee
        }
        
        html += '<td style="padding: 15px 12px; text-align: center; vertical-align: top;">';
        if (data && data.url && data.url !== '#') {
          html += '<a href="' + data.url + '" target="_blank" style="display: inline-block; padding: 8px 12px; background: ' + priceColor + '; color: white; text-decoration: none; border-radius: 4px; font-size: 12px; font-weight: bold; transition: background-color 0.2s;">üîó View</a>';
        } else if (data) {
          html += '<span style="color: #999; font-size: 12px;">No link</span>';
        } else {
          html += '<span style="color: #dc3545; font-size: 12px; font-style: italic;">Not Found</span>';
        }
        html += '</td>';
      });
      
      html += '</tr>';
      
      html += '</tbody>';
      html += '</table>';
      html += '</div>';
      
      // Add loading message under Price Comparison Summary
      html += '<div style="margin-top: 20px; padding: 15px; background: #e8f5e8; border-radius: 8px; border-left: 4px solid #28a745;">';
      html += '<div style="display: flex; align-items: center; gap: 10px;">';
      html += '<span style="font-size: 18px;">üéØ</span>';
      html += '<div>';
      html += '<div style="font-weight: bold; color: #155724; font-size: 14px;">Loaded ' + allProducts.length + ' products from all sources!</div>';
      html += '<div style="color: #6c757d; font-size: 12px; margin-top: 2px;">Products loaded from PostgreSQL database</div>';
      html += '</div>';
      html += '</div>';
      html += '</div>';
      
      // Add "All Products Found" section in columns underneath Price Comparison Summary
      html += '<div style="overflow-x: auto; margin-top: 20px;">';
      html += '<h4 style="color: #495057; margin-bottom: 15px; font-size: 16px;">üõçÔ∏è All Products Found:</h4>';
      
      marketplaces.forEach(marketplace => {
        const data = result.marketplaceResults[marketplace];
        
        // Skip Lotus's section if no data available
        if (marketplace === 'lotuss' && (!data || !data.rawResponse || !data.rawResponse.allResults || data.rawResponse.allResults.length === 0)) {
          return; // Skip this iteration
        }
        
        let marketplaceColor = '#6c757d'; // Default gray
        if (marketplace === 'lotuss') {
          marketplaceColor = '#28a745';
        } else if (marketplace === 'lazada') {
          marketplaceColor = '#ff6600';
        } else if (marketplace === 'shopee') {
          marketplaceColor = '#ff6b35';
        }
        
        html += '<div style="margin-bottom: 25px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">';
        html += '<div style="background: ' + marketplaceColor + '; color: white; padding: 12px; font-weight: bold; font-size: 16px;">';
        html += (data ? data.marketplace : marketplace.charAt(0).toUpperCase() + marketplace.slice(1)) + ' Results';
        html += '</div>';
        
        if (data && data.rawResponse && data.rawResponse.allResults && data.rawResponse.allResults.length > 0) {
          html += '<div style="padding: 15px;">';
          html += '<table style="width: 100%; border-collapse: collapse; font-family: -apple-system, BlinkMacSystemFont, \'Segoe UI\', Roboto, sans-serif;">';
          html += '<thead>';
          html += '<tr style="background: #f8f9fa; border-bottom: 1px solid #dee2e6;">';
          html += '<th style="padding: 10px; text-align: left; font-weight: bold; color: #495057; font-size: 12px;">Product Name</th>';
          html += '<th style="padding: 10px; text-align: center; font-weight: bold; color: #495057; font-size: 12px;">Price</th>';
          html += '<th style="padding: 10px; text-align: center; font-weight: bold; color: #495057; font-size: 12px;">Shop</th>';
          html += '<th style="padding: 10px; text-align: center; font-weight: bold; color: #495057; font-size: 12px;">Rating</th>';
          html += '<th style="padding: 10px; text-align: center; font-weight: bold; color: #495057; font-size: 12px;">Sold</th>';
          html += '<th style="padding: 10px; text-align: center; font-weight: bold; color: #495057; font-size: 12px;">Action</th>';
          html += '</tr>';
          html += '</thead>';
          html += '<tbody>';
          
          data.rawResponse.allResults.forEach((product, index) => {
            html += '<tr style="border-bottom: 1px solid #f0f0f0;" onmouseover="this.style.backgroundColor=\'#f8f9fa\'" onmouseout="this.style.backgroundColor=\'white\'">';
            
            // Product Name
            html += '<td style="padding: 10px; font-size: 12px; max-width: 300px; word-wrap: break-word;">';
            html += '<div style="font-weight: 500; color: #333;">' + (product.label || product.name || 'N/A') + '</div>';
            if (product.image) {
              html += '<img src="' + product.image + '" alt="Product" style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-top: 5px;" onerror="this.style.display=\'none\'">';
            }
            html += '</td>';
            
            // Price
            html += '<td style="padding: 10px; text-align: center; font-size: 12px;">';
            if (product.price) {
              html += '<div style="font-weight: bold; color: ' + marketplaceColor + ';">' + (product.currency || 'MYR') + ' ' + product.price.toFixed(2) + '</div>';
              if (product.discount && product.discount > 0) {
                html += '<div style="font-size: 10px; color: #e74c3c; background: #ffeaea; padding: 2px 6px; border-radius: 3px; margin-top: 2px;">' + product.discount + '% OFF</div>';
              }
            } else {
              html += '<span style="color: #999;">N/A</span>';
            }
            html += '</td>';
            
            // Shop Name
            html += '<td style="padding: 10px; text-align: center; font-size: 12px; color: #666;">' + (product.shop_name || 'N/A') + '</td>';
            
            // Rating
            html += '<td style="padding: 10px; text-align: center; font-size: 12px;">';
            if (product.rating && product.rating > 0) {
              html += '<div style="color: #ffc107;">‚≠ê ' + product.rating + '</div>';
            } else {
              html += '<span style="color: #999;">N/A</span>';
            }
            html += '</td>';
            
            // Sold
            html += '<td style="padding: 10px; text-align: center; font-size: 12px; color: #666;">' + (product.sold || 0) + '</td>';
            
            // Action
            html += '<td style="padding: 10px; text-align: center;">';
            if (product.url) {
              html += '<a href="' + product.url + '" target="_blank" style="display: inline-block; padding: 6px 10px; background: ' + marketplaceColor + '; color: white; text-decoration: none; border-radius: 4px; font-size: 11px; font-weight: bold;">üîó View</a>';
            } else {
              html += '<span style="color: #999; font-size: 11px;">No link</span>';
            }
            html += '</td>';
            
            html += '</tr>';
          });
          
          html += '</tbody>';
          html += '</table>';
          html += '</div>';
        } else if (data && data.name === 'No results found') {
          html += '<div style="padding: 20px; text-align: center; color: #666; font-style: italic;">No products found for this search term</div>';
        } else {
          html += '<div style="padding: 20px; text-align: center; color: #dc3545; font-style: italic;">No data available</div>';
        }
        
        html += '</div>';
      });
      
      html += '</div>'; // Close All Products Found section
      html += '</div>'; // Close summary section
    }
    
    html += '</div>';
  });
  
  // Add back button
  html += '<div style="text-align: center; margin-top: 30px;">';
  html += '<button onclick="render()" style="background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">‚Üê Back to Products</button>';
  html += '</div>';
  
  document.getElementById('grid').innerHTML = html;
}

function showDebugPopup(comparisonResults) {
  // Store results globally for copying
  window.lastComparisonResults = comparisonResults;
  
  // Create debug popup
  const debugPopup = document.createElement('div');
  debugPopup.id = 'debugPopup';
  debugPopup.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border: 2px solid #ff6b35;
    border-radius: 10px;
    padding: 20px;
    max-width: 80%;
    max-height: 80%;
    overflow-y: auto;
    z-index: 10000;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    font-family: monospace;
    font-size: 12px;
  `;
  
  let debugContent = '<h3 style="color: #ff6b35; margin-top: 0;">üîç Shopee API Debug Information</h3>';
  debugContent += '<div style="margin-bottom: 15px;">';
  debugContent += '<strong>Total Products Compared:</strong> ' + comparisonResults.length + '<br>';
  debugContent += '<strong>Timestamp:</strong> ' + new Date().toLocaleString() + '<br>';
  debugContent += '</div>';
  
  // Add API Call Details Section
  if (window.lastApiCallLogs && window.lastApiCallLogs.length > 0) {
    debugContent += '<div style="border: 2px solid #007bff; margin: 15px 0; padding: 15px; border-radius: 8px; background: #f8f9ff;">';
    debugContent += '<h4 style="color: #007bff; margin: 0 0 15px 0;">üåê API Call Details</h4>';
    
    window.lastApiCallLogs.forEach((apiCall, index) => {
      debugContent += '<div style="border: 1px solid #ddd; margin: 10px 0; padding: 10px; border-radius: 5px; background: white;">';
      debugContent += '<strong>API Call #' + (index + 1) + ':</strong><br>';
      debugContent += '<strong>Timestamp:</strong> ' + new Date(apiCall.timestamp).toLocaleString() + '<br>';
      debugContent += '<strong>Product:</strong> ' + apiCall.productName + '<br>';
      debugContent += '<strong>API URL:</strong> ' + apiCall.apiUrl + '<br>';
      debugContent += '<strong>Request Parameters:</strong><br>';
      debugContent += '&nbsp;&nbsp;‚Ä¢ keyword: "' + apiCall.requestParams.keyword + '"<br>';
      debugContent += '&nbsp;&nbsp;‚Ä¢ limit: ' + apiCall.requestParams.limit + '<br>';
      debugContent += '<strong>Response:</strong><br>';
      debugContent += '&nbsp;&nbsp;‚Ä¢ Success: ' + (apiCall.response.success ? '‚úÖ Yes' : '‚ùå No') + '<br>';
      debugContent += '&nbsp;&nbsp;‚Ä¢ Result Count: ' + apiCall.response.resultCount + '<br>';
      debugContent += '&nbsp;&nbsp;‚Ä¢ Response Time: ' + new Date().toLocaleTimeString() + '<br>';
      debugContent += '</div>';
    });
    
    debugContent += '</div>';
  }
  
  comparisonResults.forEach((result, resultIndex) => {
    debugContent += '<div style="border: 1px solid #ddd; margin: 10px 0; padding: 10px; border-radius: 5px;">';
    debugContent += '<h4 style="color: #333; margin: 0 0 10px 0;">üì¶ Original Product #' + (resultIndex + 1) + '</h4>';
    debugContent += '<strong>Name:</strong> ' + result.originalProduct.name + '<br>';
    debugContent += '<strong>ID:</strong> ' + result.originalProduct.id + '<br>';
    debugContent += '<br><strong>üõí Shopee Results (' + result.shopeeProducts.length + ' products):</strong><br>';
    
    result.shopeeProducts.forEach((product, productIndex) => {
      debugContent += '<div style="margin: 8px 0; padding: 8px; background: #f9f9f9; border-radius: 3px;">';
      debugContent += '<strong>Product #' + (productIndex + 1) + ':</strong><br>';
      debugContent += '&nbsp;&nbsp;Name: ' + product.name + '<br>';
      debugContent += '&nbsp;&nbsp;Shop: ' + (product.shop_name || 'Unknown') + '<br>';
      debugContent += '&nbsp;&nbsp;Raw Price: ' + product.price + ' cents<br>';
      debugContent += '&nbsp;&nbsp;Calculated Price: RM ' + (product.price ? (product.price / 100).toFixed(2) : 'N/A') + '<br>';
      debugContent += '&nbsp;&nbsp;Rating: ' + (product.rating || 'N/A') + '<br>';
      debugContent += '&nbsp;&nbsp;Sold: ' + (product.sold || 'N/A') + '<br>';
      debugContent += '&nbsp;&nbsp;URL: ' + product.url + '<br>';
      debugContent += '&nbsp;&nbsp;Image: ' + product.image + '<br>';
      debugContent += '</div>';
    });
    debugContent += '</div>';
  });
  
  debugContent += '<div style="text-align: center; margin-top: 20px;">';
  debugContent += '<button onclick="closeDebugPopup()" style="background: #ff6b35; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">Close Debug</button>';
  debugContent += '<button onclick="copyDebugData()" style="background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">Copy Debug Data</button>';
  debugContent += '</div>';
  
  debugPopup.innerHTML = debugContent;
  document.body.appendChild(debugPopup);
  
  // Add overlay
  const overlay = document.createElement('div');
  overlay.id = 'debugOverlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 9999;
  `;
  overlay.onclick = closeDebugPopup;
  document.body.appendChild(overlay);
}

function closeDebugPopup() {
  const popup = document.getElementById('debugPopup');
  const overlay = document.getElementById('debugOverlay');
  if (popup) popup.remove();
  if (overlay) overlay.remove();
}

function copyDebugData() {
  const comparisonResults = window.lastComparisonResults || [];
  const debugText = JSON.stringify(comparisonResults, null, 2);
  navigator.clipboard.writeText(debugText).then(() => {
    alert('Debug data copied to clipboard!');
  }).catch(() => {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = debugText;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    alert('Debug data copied to clipboard!');
  });
}

// Debug function to show all Firecrawl products
function showAllFirecrawlProducts() {
  console.log('=== FIRECRAWL PRODUCTS DEBUG ===');
  console.log('Total FEED length:', FEED.length);
  
  const firecrawlProducts = FEED.filter(p => p.id && p.id.startsWith('lotus-'));
  console.log('Firecrawl products found:', firecrawlProducts.length);
  
  // Check filter status
  console.log('Filter status:');
  console.log('- sourceOn:', sourceOn);
  console.log('- stockOn:', stockOn);
  console.log('- marketplaceOn:', marketplaceOn);
  console.log('- priceRange:', priceRange);
  
  // Test passesFilters function
  const filteredProducts = firecrawlProducts.filter(p => passesFilters(p));
  console.log('Products passing filters:', filteredProducts.length);
  
  firecrawlProducts.forEach((product, index) => {
    const passes = passesFilters(product);
    console.log(`Product ${index + 1} (passes: ${passes}):`, {
      id: product.id,
      title: product.title,
      brand: product.brand,
      price: product.price,
      category: product.category_path,
      offers: product.offers,
      firecrawl_data: product.firecrawl_data,
      product_url: product.offers?.[0]?.url || 'No URL'
    });
  });
  
  // Show Firecrawl API URLs
  console.log('=== FIRECRAWL API URLs ===');
  console.log('Sitemap API URL: https://api.firecrawl.dev/v2/map');
  console.log('Scrape API URL: https://api.firecrawl.dev/v2/scrape');
  console.log('Lotus Base URL: https://www.lotuss.com.my/en');
  
  // Show individual product URLs
  console.log('=== INDIVIDUAL PRODUCT URLs ===');
  firecrawlProducts.forEach((product, index) => {
    const productUrl = product.offers?.[0]?.url || product.firecrawl_data?.url || 'No URL';
    console.log(`Product ${index + 1}: ${productUrl}`);
  });
  
  // Reset all filters to show all products
  sourceOn = { lotuss: true, shopee: true, lazada: true, grab: true, foodpanda: true, aeon: true, horeca: true, "horeca-openai": true, "lotus-scraper": true };
  stockOn = { "in-stock": true, "out-of-stock": true };
  marketplaceOn = { lotuss: true, shopee: true, lazada: true, grab: true, foodpanda: true, aeon: true, horeca: true, "horeca-openai": true, "lotus-scraper": true };
  priceRange = [0, 999999];
  
  // Clear search
  const searchInput = document.getElementById('q');
  if (searchInput) {
    searchInput.value = '';
  }
  
  // Force display all products with URLs (but still apply filtering)
  const grid = document.getElementById('grid');
  if (grid) {
    const filteredProducts = firecrawlProducts.filter(p => passesFilters(p));
    grid.innerHTML = filteredProducts.map(product => {
      const productUrl = product.offers?.[0]?.url || product.firecrawl_data?.url || '#';
      return `
        <div class="tile" style="border: 2px solid #4285f4; background: #f8f9ff; padding: 12px; border-radius: 8px; margin-bottom: 10px;">
          <div class="content">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
              <h3 style="margin: 0; color: #333; font-size: 16px; line-height: 1.3; flex: 1;">${product.title}</h3>
              <span style="color: #2e7d32; font-size: 18px; font-weight: bold; margin-left: 15px;">RM ${product.price || 'N/A'}</span>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
              <span style="color: #666; font-size: 13px;"><strong>Brand:</strong> ${product.brand} ‚Ä¢ <strong>Category:</strong> ${product.category_path}</span>
              <div>
                <span class="badge" style="background: #4285f4; color: white; padding: 3px 6px; border-radius: 10px; font-size: 10px; margin-right: 4px;">Firecrawl</span>
              </div>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; font-size: 11px; color: #666;">
              <span><strong>üîó URL:</strong> <a href="${productUrl}" target="_blank" style="color: #4285f4; text-decoration: none;">${productUrl}</a></span>
              <span><strong>Product ID:</strong> ${product.firecrawl_data?.product_id || 'N/A'}</span>
            </div>
          </div>
        </div>
      `;
    }).join('');
  }
  
  console.log('=== END FIRECRAWL DEBUG ===');
}

// Function to pull detailed product information from URLs
async function pullProductDetailsFromUrls() {
  console.log('=== PULLING DETAILED PRODUCT INFORMATION ===');
  
  const firecrawlProducts = FEED.filter(p => p.id && p.id.startsWith('lotus-'));
  console.log(`Found ${firecrawlProducts.length} Firecrawl products to enhance`);
  
  const enhancedProducts = [];
  
  for (let i = 0; i < firecrawlProducts.length; i++) {
    const product = firecrawlProducts[i];
    const productUrl = product.offers?.[0]?.url || product.firecrawl_data?.url;
    
    if (productUrl && productUrl !== '#') {
      console.log(`Enhancing product ${i + 1}/${firecrawlProducts.length}: ${product.title}`);
      
      try {
        // Use the existing Lotus Live Scraper API to get detailed product info
        const response = await fetch(`http://localhost:5004/search?q=${encodeURIComponent(product.title)}&limit=1`);
        
        if (response.ok) {
          const data = await response.json();
          if (data.success && data.products && data.products.length > 0) {
            const detailedProduct = data.products[0];
            
            // Enhance the product with detailed information
            const enhancedProduct = {
              ...product,
              title: detailedProduct.name || product.title,
              price: detailedProduct.price || product.price,
              brand: detailedProduct.brand || product.brand,
              category_path: detailedProduct.category || product.category_path,
              description: detailedProduct.description || '',
              image_url: detailedProduct.image || product.image_url,
              size: detailedProduct.size || product.size,
              packaging: detailedProduct.packaging || product.packaging,
              enhanced: true,
              enhanced_at: new Date().toISOString()
            };
            
            enhancedProducts.push(enhancedProduct);
            console.log(`‚úÖ Enhanced: ${enhancedProduct.title} - RM${enhancedProduct.price}`);
          } else {
            enhancedProducts.push(product);
            console.log(`‚ö†Ô∏è No detailed data found for: ${product.title}`);
          }
        } else {
          enhancedProducts.push(product);
          console.log(`‚ö†Ô∏è API error for: ${product.title}`);
        }
      } catch (error) {
        enhancedProducts.push(product);
        console.log(`‚ùå Error enhancing ${product.title}:`, error.message);
      }
      
      // Rate limiting - wait between requests
      await new Promise(resolve => setTimeout(resolve, 1000));
    } else {
      enhancedProducts.push(product);
      console.log(`‚ö†Ô∏è No URL for: ${product.title}`);
    }
  }
  
  // Update FEED with enhanced products
  const nonFirecrawlProducts = FEED.filter(p => !p.id || !p.id.startsWith('lotus-'));
  FEED = [...nonFirecrawlProducts, ...enhancedProducts];
  
  // Don't call render() here - let showEnhancedProducts handle the display
  
  console.log(`=== ENHANCEMENT COMPLETE ===`);
  console.log(`Enhanced ${enhancedProducts.filter(p => p.enhanced).length} products`);
  
  // Show enhanced products
  showEnhancedProducts(enhancedProducts);
}

// Function to display enhanced products
function showEnhancedProducts(enhancedProducts) {
  const grid = document.getElementById('grid');
  if (grid) {
    const filteredProducts = enhancedProducts.filter(p => passesFilters(p));
    grid.innerHTML = filteredProducts.map(product => {
      const productUrl = product.offers?.[0]?.url || product.firecrawl_data?.url || '#';
      const isEnhanced = product.enhanced;
      
      return `
        <div class="tile" style="border: 2px solid ${isEnhanced ? '#28a745' : '#4285f4'}; background: ${isEnhanced ? '#f8fff8' : '#f8f9ff'}; padding: 12px; border-radius: 8px; margin-bottom: 10px;">
          <div class="content">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
              <h3 style="margin: 0; color: #333; font-size: 16px; line-height: 1.3; flex: 1; display: flex; align-items: center; gap: 15px;">
                ${product.image_link && product.image_link !== 'https://via.placeholder.com/240x240.png?text=No+Image' ? 
                  `<div style="display: flex; flex-direction: column; align-items: center;">
                    <img src="${product.image_link}" alt="${product.title}" style="width: 120px; height: 120px; object-fit: cover; border-radius: 8px; border: 1px solid #e0e0e0; cursor: pointer;" onerror="this.style.display='none'" onclick="window.open('${product.image_link}', '_blank')">
                    ${product.product_url && product.product_url !== '#' ? 
                      `<div style="margin-top: 4px; font-size: 11px; color: #4285f4;"><a href="${product.product_url}" target="_blank" rel="noopener" style="color: #4285f4; text-decoration: none;">üîó</a></div>` :
                      product.url && product.url !== '#' ?
                      `<div style="margin-top: 4px; font-size: 11px; color: #4285f4;"><a href="${product.url}" target="_blank" rel="noopener" style="color: #4285f4; text-decoration: none;">üîó</a></div>` :
                      ''
                    }
                  </div>` : 
                  ''
                }
                <span>${product.title}</span>
              </h3>
              <span style="color: #2e7d32; font-size: 18px; font-weight: bold; margin-left: 15px;">RM ${product.price || 'N/A'}</span>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
              <span style="color: #666; font-size: 13px;"><strong>Brand:</strong> ${product.brand} ‚Ä¢ <strong>Category:</strong> ${product.category_path}</span>
              <div>
                <span class="badge" style="background: ${isEnhanced ? '#28a745' : '#4285f4'}; color: white; padding: 3px 6px; border-radius: 10px; font-size: 10px; margin-right: 4px;">${isEnhanced ? 'Enhanced' : 'Firecrawl'}</span>
              </div>
            </div>
            ${product.description ? `<div style="margin-bottom: 6px; font-size: 12px; color: #666; line-height: 1.4;">${product.description.substring(0, 100)}...</div>` : ''}
            <div style="display: flex; justify-content: space-between; align-items: center; font-size: 11px; color: #666;">
              <span><strong>üîó URL:</strong> <a href="${productUrl}" target="_blank" style="color: #4285f4; text-decoration: none;">${productUrl}</a></span>
              <span><strong>Product ID:</strong> ${product.firecrawl_data?.product_id || 'N/A'}</span>
            </div>
            ${isEnhanced ? `<div style="margin-top: 4px; font-size: 10px; color: #28a745; text-align: right;">
              <strong>Enhanced:</strong> ${new Date(product.enhanced_at).toLocaleTimeString()}
            </div>` : ''}
          </div>
        </div>
      `;
    }).join('');
  }
}


// Firecrawl API functions
async function fetchLotusUrls() {
  console.log('üöÄ fetchLotusUrls function called');
  const button = document.getElementById('fetchLotusUrls');
  const selector = document.getElementById('lotusUrlSelector');
  
  if (!button) {
    console.error('‚ùå fetchLotusUrls button not found');
    return;
  }
  
  if (!selector) {
    console.error('‚ùå lotusUrlSelector not found');
    return;
  }
  
  console.log('‚úÖ Button and selector found, starting fetch...');
  
  // Show loading state
  button.textContent = 'üîÑ Fetching...';
  button.disabled = true;
  
  try {
    const url = 'https://api.firecrawl.dev/v2/map';
    const options = {
      method: 'POST',
      headers: {
        'Authorization': 'Bearer fc-e6de45828d044c7eb7c2ebb4450aecc5',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        "url": "www.lotuss.com.my/en/product",
        "limit": 5000,
        "includeSubdomains": false,
        "sitemap": "include"
      })
    };

    console.log('üåê Fetching Lotus URLs from Firecrawl...');
    const response = await fetch(url, options);
    
    // Check for HTTP status errors first
    if (!response.ok) {
      if (response.status === 501) {
        console.error('‚ùå Firecrawl API: Service not implemented (501)');
        showNotification('‚ö†Ô∏è Firecrawl API service not available (501). Please try again later or use existing data.', 'warning');
      } else if (response.status === 402) {
        console.error('‚ùå Firecrawl API: Payment required (402)');
        showNotification('‚ö†Ô∏è Firecrawl API payment required. Please check your billing or use existing data.', 'warning');
      } else if (response.status === 429) {
        console.error('‚ùå Firecrawl API: Rate limited (429)');
        showNotification('‚ö†Ô∏è Firecrawl API rate limited. Please wait and try again later.', 'warning');
      } else {
        console.error(`‚ùå Firecrawl API: HTTP error ${response.status} ${response.statusText}`);
        showNotification(`‚ö†Ô∏è Firecrawl API error: ${response.status} ${response.statusText}. Please try again later.`, 'warning');
      }
      
      // Reset button state and return
      button.textContent = 'üåê Fetch Lotus URLs';
      button.disabled = false;
      return;
    }
    
    const data = await response.json();
    console.log('üìä API Response:', data);
    
    if (data.success && data.links && data.links.length > 0) {
      console.log('‚úÖ Successfully fetched Lotus URLs:', data.links.length);
      console.log('üîó Sample URL data:', data.links[0]);
      console.log('üîó First 5 URLs:', data.links.slice(0, 5));
      
      // Use smart URL extraction
      const allUrls = extractUrls(data);
      const productUrls = allUrls.filter(u => /\/en\/product\//.test(u));
      console.log('üîç Smart URL extraction results:', { 
        total: allUrls.length, 
        product: productUrls.length, 
        productUrls: productUrls.slice(0, 10) // Show first 10
      });
      
      // Populate the dropdown with smart-extracted product URLs
      selector.innerHTML = '<option value="">Select Lotus URL to view details...</option>';
      
      productUrls.forEach((url, index) => {
        const option = document.createElement('option');
        option.value = url;
        option.textContent = `${index + 1}. ${url}`;
        option.dataset.urlData = JSON.stringify({ url: url });
        selector.appendChild(option);
      });
      
      // Show the dropdown
      selector.style.display = 'block';
      
      // Store smart-extracted product URLs globally for batch processing
      fetchedUrls = productUrls.map(url => ({ url: url }));
      
      // Show the processing buttons
      const fetchAllProductsButton = document.getElementById('fetchAllProducts');
      const processBatch100Button = document.getElementById('processBatch100');
      const processAllRecordsButton = document.getElementById('processAllRecords');
      
      if (fetchAllProductsButton) {
        fetchAllProductsButton.style.display = 'inline-block';
        fetchAllProductsButton.textContent = `üõí Fetch All ${productUrls.length} Products`;
      }
      
      if (processBatch100Button) {
        processBatch100Button.style.display = 'inline-block';
        processBatch100Button.textContent = `üì¶ Process Next 100 (${productUrls.length} total)`;
        processBatch100Button.disabled = false;
      }
      
      if (processAllRecordsButton) {
        processAllRecordsButton.style.display = 'inline-block';
        document.getElementById('testFirecrawlResponse').style.display = 'inline-block';
        processAllRecordsButton.textContent = `üöÄ Process All ${productUrls.length} Records`;
        processAllRecordsButton.disabled = false;
      }
      
      // Reset processing state
      processedUrls = 0;
      isProcessing = false;
      resetDatabaseProgress();
      
      // Show success message
      showNotification(`‚úÖ Successfully extracted ${productUrls.length} product URLs from ${allUrls.length} total URLs!`, 'success');
      
    } else {
      console.error('‚ùå Failed to fetch URLs:', data);
      
      // Check for specific error types
      if (data.error && data.error.includes('Insufficient credits')) {
        showNotification('‚ö†Ô∏è Firecrawl API credits exhausted. Please upgrade your plan or use existing data.', 'warning');
      } else if (data.error && data.error.includes('Payment Required')) {
        showNotification('‚ö†Ô∏è Firecrawl API payment required. Please check your billing.', 'warning');
      } else {
        showNotification('‚ùå Failed to fetch Lotus URLs. Check console for details.', 'error');
      }
    }
    
  } catch (error) {
    console.error('‚ùå Error fetching Lotus URLs:', error);
    
    // Check for network or API errors
    if (error.message.includes('fetch')) {
      showNotification('‚ö†Ô∏è Network error connecting to Firecrawl API. Please try again later.', 'warning');
    } else {
      showNotification('‚ùå Error fetching Lotus URLs: ' + error.message, 'error');
    }
  } finally {
    // Reset button state
    button.textContent = 'üåê Fetch Lotus URLs';
    button.disabled = false;
  }
}

async function fetchUrlDetails(url) {
  if (!url) return;
  
  try {
    console.log('üîç Fetching details for URL:', url);
    
    const scrapeUrl = 'https://api.firecrawl.dev/v2/scrape';
    const options = {
      method: 'POST',
      headers: {
        'Authorization': 'Bearer fc-e4eb2258dbe34769b9be4a2c6ff9c86f',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        "url": url,
        "formats": ["markdown", "html"],
        "onlyMainContent": true
      })
    };

    const response = await fetch(scrapeUrl, options);
    const data = await response.json();
    
    if (data.success && data.data) {
      console.log('‚úÖ Successfully scraped URL details:', data.data);
      displayUrlDetails(url, data.data);
    } else {
      console.error('‚ùå Failed to scrape URL:', data);
      showNotification('‚ùå Failed to scrape URL details', 'error');
    }
    
  } catch (error) {
    console.error('‚ùå Error scraping URL:', error);
    showNotification('‚ùå Error scraping URL: ' + error.message, 'error');
  }
}

function displayUrlDetails(url, data) {
  // Create a modal or popup to display the details
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  `;
  
  const content = document.createElement('div');
  content.style.cssText = `
    background: white;
    border-radius: 8px;
    padding: 20px;
    max-width: 80%;
    max-height: 80%;
    overflow: auto;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  `;
  
  content.innerHTML = `
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
      <h3 style="margin: 0; color: #333;">URL Details</h3>
      <button onclick="this.closest('.modal').remove()" style="background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">‚úï Close</button>
    </div>
    
    <div style="margin-bottom: 15px;">
      <strong>URL:</strong> <a href="${url}" target="_blank" style="color: #007bff; text-decoration: none;">${url}</a>
    </div>
    
    ${data.metadata ? `
      <div style="margin-bottom: 15px;">
        <strong>Metadata:</strong>
        <pre style="background: #f8f9fa; padding: 10px; border-radius: 4px; overflow: auto; font-size: 12px;">${JSON.stringify(data.metadata, null, 2)}</pre>
      </div>
    ` : ''}
    
    ${data.markdown ? `
      <div style="margin-bottom: 15px;">
        <strong>Content (Markdown):</strong>
        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; max-height: 300px; overflow: auto; font-size: 12px; white-space: pre-wrap;">${data.markdown}</div>
      </div>
    ` : ''}
    
    ${data.html ? `
      <div style="margin-bottom: 15px;">
        <strong>HTML Content:</strong>
        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; max-height: 300px; overflow: auto; font-size: 12px;">${data.html}</div>
      </div>
    ` : ''}
  `;
  
  modal.className = 'modal';
  modal.appendChild(content);
  document.body.appendChild(modal);
  
  // Close modal when clicking outside
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.remove();
    }
  });
}

function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    border-radius: 6px;
    color: white;
    font-weight: 500;
    z-index: 1001;
    max-width: 400px;
    word-wrap: break-word;
    ${type === 'success' ? 'background: #28a745;' : ''}
    ${type === 'error' ? 'background: #dc3545;' : ''}
    ${type === 'info' ? 'background: #17a2b8;' : ''}
  `;
  
  notification.textContent = message;
  document.body.appendChild(notification);
  
  // Auto remove after 5 seconds
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 5000);
}

// Show refresh notification in sidebar
function showRefreshNotification(message, type = 'info') {
  const notificationArea = document.getElementById('refreshNotification');
  const messageDiv = document.getElementById('refreshStatusMessage');
  
  if (notificationArea && messageDiv) {
    // Set message content
    messageDiv.textContent = message;
    
    // Set styling based on type
    messageDiv.style.background = type === 'success' ? '#e8f5e8' : 
                                  type === 'error' ? '#f8d7da' : 
                                  type === 'loading' ? '#e3f2fd' : '#f8f9fa';
    messageDiv.style.color = type === 'success' ? '#155724' : 
                             type === 'error' ? '#721c24' : 
                             type === 'loading' ? '#0c5460' : '#495057';
    messageDiv.style.border = type === 'success' ? '1px solid #c3e6cb' : 
                              type === 'error' ? '1px solid #f5c6cb' : 
                              type === 'loading' ? '1px solid #bee5eb' : '1px solid #dee2e6';
    
    // Show the notification area
    notificationArea.style.display = 'block';
    
    // Auto hide after 5 seconds for success/error messages
    if (type === 'success' || type === 'error') {
      setTimeout(() => {
        notificationArea.style.display = 'none';
      }, 5000);
    }
  }
}

// Global variable to store fetched URLs
let fetchedUrls = [];

// Batch processing variables
let processedUrls = 0; // Track how many URLs have been processed
let isProcessing = false; // Prevent multiple simultaneous processing

// Database progress tracking
let totalUrlsToProcess = 0;
let currentBatchProgress = 0;
let totalStored = 0;
let totalSkipped = 0;
let totalErrors = 0;

// Smart URL extraction function
function extractUrls(payload, base = location.origin) {
  const out = new Set();
  const isUrlLike = v => typeof v === "string" && /^https?:\/\//i.test(v);

  function add(u) {
    try { out.add(new URL(u, base).toString()); } catch {}
  }

  function visit(x) {
    if (x == null) return;
    if (typeof x === "string") { if (isUrlLike(x)) add(x); return; }
    if (Array.isArray(x)) { x.forEach(visit); return; }
    if (typeof x === "object") {
      // common url-ish fields
      const fields = ["url","href","link","canonicalUrl","permalink","src"];
      for (const k of fields) if (typeof x[k] === "string") add(x[k]);
      // keep walking
      for (const v of Object.values(x)) visit(v);
    }
  }

  visit(payload?.links ?? payload);
  return [...out];
}

// Function to fetch all products from URLs
async function fetchAllProducts() {
  const button = document.getElementById('fetchAllProducts');
  const selector = document.getElementById('lotusUrlSelector');
  
  if (!fetchedUrls || fetchedUrls.length === 0) {
    showNotification('‚ùå No URLs available. Please fetch URLs first.', 'error');
    return;
  }
  
  // Show loading state
  button.textContent = 'üîÑ Fetching Products...';
  button.disabled = true;
  
  let successCount = 0;
  let errorCount = 0;
  const allProducts = [];
  
  try {
    // Process all fetched URLs
    const allUrls = fetchedUrls;
    
    showNotification(`üîÑ Starting to fetch ${allUrls.length} products...`, 'info');
    
    // Process URLs in batches to avoid overwhelming the API
    const batchSize = 5;
    for (let i = 0; i < allUrls.length; i += batchSize) {
      const batch = allUrls.slice(i, i + batchSize);
      
      // Process batch in parallel
      const batchPromises = batch.map(async (urlData, batchIndex) => {
        const url = typeof urlData === 'string' ? urlData : (urlData.url || urlData.href);
        if (!url) return null;
        
        try {
          console.log(`üîç Fetching product ${i + batchIndex + 1}/${allUrls.length}: ${url}`);
          
          const scrapeUrl = 'https://api.firecrawl.dev/v2/scrape';
          const options = {
            method: 'POST',
            headers: {
              'Authorization': 'Bearer fc-e4eb2258dbe34769b9be4a2c6ff9c86f',
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              "url": url,
              "formats": ["markdown"],
              "onlyMainContent": true
            })
          };

          const response = await fetch(scrapeUrl, options);
          const data = await response.json();
          
          if (data.success && data.data) {
            // Extract product information from the scraped content
            const product = extractProductFromContent(url, data.data);
            if (product) {
              // Check if product has a valid price before adding to batch
              const priceMatch = product.price ? product.price.match(/RM\s*(\d+\.?\d*)/i) : null;
              const priceValue = priceMatch ? parseFloat(priceMatch[1]) : 0;
              
              if (priceValue > 0) {
                allProducts.push(product);
                successCount++;
                console.log(`üì¶ Added product to batch: "${product.name}" (Price: RM ${priceValue})`);
                
                // Convert and add this single product to the display immediately
                addSingleProductToDisplay(product, allProducts.length - 1);
              } else {
                console.log(`‚è≠Ô∏è Skipping product with price 0: "${product.name}" (Price: ${product.price})`);
              }
            }
          } else {
            errorCount++;
          }
          
          // Small delay to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (error) {
          console.error(`‚ùå Error fetching ${url}:`, error);
          errorCount++;
        }
      });
      
      await Promise.all(batchPromises);
      
      // Update progress
      const progress = Math.min(i + batchSize, limitedUrls.length);
      button.textContent = `üîÑ Fetching Products... ${progress}/${limitedUrls.length}`;
    }
    
    // Add products to the main feed and display them
    if (allProducts.length > 0) {
      console.log('‚úÖ Successfully fetched products:', allProducts);
      
      // Products are already converted and added individually during fetching
      
      // Products are now added individually as they're fetched, so no bulk processing needed
      console.log('‚úÖ Batch processing completed:', { successCount, errorCount });
      
      // Show final completion message with detailed record count
      if (successCount > 0) {
        const totalFetched = FEED.filter(p => p.source === 'Lotus Firecrawl').length;
        const message = `üéâ Batch processing completed! Successfully fetched ${successCount} products. Total Lotus records: ${totalFetched}. ${errorCount > 0 ? `${errorCount} errors occurred.` : ''}`;
        showNotification(message, 'success');
        
        // Store all fetched products in the database
        if (allProducts.length > 0) {
          console.log('üíæ Storing fetched Lotus products in database...');
          const storageResult = await storeLotusProductsInDatabase(allProducts);
          
          // Show detailed storage notification
          let storageMessage = `üíæ Database Storage: ${storageResult.stored} new products stored`;
          if (storageResult.skipped > 0) {
            storageMessage += `, ${storageResult.skipped} already existed (skipped)`;
          }
          if (storageResult.errors > 0) {
            storageMessage += `, ${storageResult.errors} errors`;
          }
          
          showNotification(storageMessage, 'success');
        }
        
        // Also show a detailed summary in console
        console.log('üìä FETCHING SUMMARY:');
        console.log(`   ‚úÖ Successfully processed: ${successCount} products`);
        console.log(`   ‚ùå Errors encountered: ${errorCount} products`);
        console.log(`   üì¶ Total Lotus records in database: ${totalFetched}`);
        console.log(`   üéØ Success rate: ${((successCount / (successCount + errorCount)) * 100).toFixed(1)}%`);
        
        // Update the data source dropdown to reflect the new count
        const dataSourceSelect = document.getElementById('dataSource');
        const firecrawlOption = dataSourceSelect.querySelector('option[value="firecrawl"]');
        if (firecrawlOption) {
          firecrawlOption.textContent = `Lotus Firecrawl (${totalFetched} products)`;
        }
        
        // Update record counter
        updateRecordCounter();
      } else {
        showNotification(`‚ö†Ô∏è No products were successfully fetched. ${errorCount} errors occurred.`, 'warning');
      }
    } else {
      showNotification(`‚ùå No products could be fetched. ${errorCount} errors.`, 'error');
    }
    
  } catch (error) {
    console.error('‚ùå Error in batch processing:', error);
    showNotification('‚ùå Error fetching products: ' + error.message, 'error');
  } finally {
    // Reset button state
    button.textContent = `üõí Fetch All ${fetchedUrls.length} Products`;
    button.disabled = false;
  }
}

// Function to add a single product to the display immediately
function addSingleProductToDisplay(product, index) {
  // Extract price value from string like "RM 15.90"
  const priceMatch = product.price.match(/RM\s*(\d+\.?\d*)/i);
  const priceValue = priceMatch ? parseFloat(priceMatch[1]) : 0;
  
  // Create offers array in the expected format
  const offers = [{
    source: "lotuss",
    marketplace: "lotuss", 
    merchant: "Lotus's",
    price: priceValue,
    currency: "MYR",
    availability: "in-stock",
    url: product.url,
    promo: "Firecrawl Data"
  }];
  
  // Use extracted image URL from og:image meta tag
  const imageUrl = product.image_url || '';
  
  const convertedProduct = {
    id: `firecrawl_${index}`,
    title: product.name,
    description: product.description,
    image_link: imageUrl || "https://via.placeholder.com/240x240.png?text=No+Image", // Use extracted og:image URL
    url: product.url,
    source: 'Lotus Firecrawl',
    scrapedAt: product.scrapedAt,
    brand: product.name.includes(' ') ? product.name.split(' ')[0] : 'Lotus', // Extract brand from product name
    category_path: 'Firecrawl > Products',
    rating: null,
    rating_count: 0,
    aggregate: {
      lowPrice: priceValue,
      highPrice: priceValue,
      currency: "MYR",
      offerCount: 1
    },
    offers: offers
  };
  
  // Add to the main product feed
  if (!FEED.some(p => p.id === convertedProduct.id)) {
    FEED.push(convertedProduct);
    
    // Update the data source selector if this is the first Firecrawl product
    if (FEED.filter(p => p.source === 'Lotus Firecrawl').length === 1) {
      const dataSourceSelect = document.getElementById('dataSource');
      const firecrawlOption = dataSourceSelect.querySelector('option[value="firecrawl"]');
      if (!firecrawlOption) {
        const option = document.createElement('option');
        option.value = 'firecrawl';
        option.textContent = `Lotus Firecrawl (${FEED.filter(p => p.source === 'Lotus Firecrawl').length} products)`;
        dataSourceSelect.appendChild(option);
      }
    }
    
    // Update the count in the dropdown
    const dataSourceSelect = document.getElementById('dataSource');
    const firecrawlOption = dataSourceSelect.querySelector('option[value="firecrawl"]');
    if (firecrawlOption) {
      firecrawlOption.textContent = `Lotus Firecrawl (${FEED.filter(p => p.source === 'Lotus Firecrawl').length} products)`;
    }
    
    // Re-render to show the new product
    render();
    
    // Update record counter
    updateRecordCounter();
    
    // Show progress notification every 10 products to avoid spam
    const firecrawlCount = FEED.filter(p => p.source === 'Lotus Firecrawl').length;
    if (firecrawlCount % 10 === 0 || firecrawlCount <= 5) {
      showNotification(`üì¶ Added ${firecrawlCount} products so far...`, 'info');
    }
  }
}

// Function to extract product information from scraped content
function extractProductFromContent(url, data) {
  console.log(`üîç extractProductFromContent called for URL: ${url}`);
  try {
    const content = data.markdown || '';
    
    // Debug: Log the content to see what we're working with
    console.log(`üîç Raw content for ${url}:`, content.substring(0, 500));
    
    // Also try to extract from HTML content if markdown is empty
    const htmlContent = data.html || '';
    if (htmlContent && !content) {
      console.log(`üîç HTML content for ${url}:`, htmlContent.substring(0, 500));
    }
    
    // Try to extract product name from HTML content using more aggressive patterns
    if (htmlContent) {
      const htmlPatterns = [
        // Look for product name in common HTML structures
        /<h1[^>]*>([^<]+)<\/h1>/i,
        /<h2[^>]*>([^<]+)<\/h2>/i,
        /<title[^>]*>([^<]+)<\/title>/i,
        // Look for title with data-ssr-seo attribute (Lotus specific)
        /<title[^>]*data-ssr-seo[^>]*>([^<]+)<\/title>/i,
        // Look for product name in meta tags
        /<meta[^>]*name="title"[^>]*content="([^"]+)"/i,
        /<meta[^>]*property="og:title"[^>]*content="([^"]+)"/i,
        // Look for product name in JSON-LD structured data
        /"name":\s*"([^"]+)"/i,
        /"title":\s*"([^"]+)"/i,
        // Look for product name in common CSS classes
        /<[^>]*class="[^"]*product[^"]*title[^"]*"[^>]*>([^<]+)<\/[^>]*>/i,
        /<[^>]*class="[^"]*title[^"]*product[^"]*"[^>]*>([^<]+)<\/[^>]*>/i,
        // Look for any text that looks like a product name
        /<[^>]*>([A-Z][A-Z\s\d\.\-&]+(?:KG|G|ML|L|PACK|UNIT|PIECE|BOTTLE|CAN|BOX|PATCH|CREAM|GEL|SPRAY|CHOCOLATE|BISCUIT|DRINK|FOOD|MILK|BREAD|RICE|NOODLE|SAUCE|SPICE|HERB|VITAMIN|SUPPLEMENT|MEDICINE|BANDAGE|PLASTER))<\/[^>]*>/i
      ];
      
      for (const pattern of htmlPatterns) {
        const match = htmlContent.match(pattern);
        if (match && match[1] && match[1].trim().length > 3) {
          let candidate = match[1].trim();
          
          // Clean up title tag content - remove "| Lotus's Shop Online" part
          if (candidate.includes('|')) {
            candidate = candidate.split('|')[0].trim();
          }
          
          // Remove common suffixes
          candidate = candidate.replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/i, '');
          candidate = candidate.replace(/\s*\|\s*Lotus.*$/i, '');
          
          // Remove any remaining unwanted content
          candidate = candidate.replace(/\s*Shop\s*Online.*$/i, '');
          candidate = candidate.replace(/\s*Lotus.*$/i, '');
          
          // If the candidate is still too long or contains unwanted content, try to extract just the product name
          if (candidate.length > 100 || candidate.includes('Shop') || candidate.includes('Online')) {
            const parts = candidate.split('|');
            if (parts.length > 0) {
              candidate = parts[0].trim();
            }
          }
          
          if (!candidate.match(/^(THE|AND|OR|FOR|WITH|FROM|THIS|THAT|PAGE|SITE|HOME|MENU|SEARCH|LOGIN|REGISTER|CART|CHECKOUT|ABOUT|CONTACT|TERMS|PRIVACY|COPYRIGHT|ALL|RIGHTS|RESERVED)$/i)) {
            console.log(`‚úÖ Found product name in HTML: "${candidate}"`);
            // Use this as the product name if we haven't found one yet
            if (nameMatch === null) {
              nameMatch = {1: candidate};
            }
            break;
          }
        }
      }
    }
    
    // Extract product name (improved patterns for Lotus products)
    // nameMatch is already declared above
    
    // Try multiple patterns to find product name
    const searchContent = content || htmlContent;
    const patterns = [
      // Look for title tags or headings
      /<title[^>]*>([^<]+)<\/title>/i,
      /^#\s*([^\n]+)/,
      /^##\s*([^\n]+)/,
      // Look for product name in common formats
      /(?:Product|Item|Name|Title)[:\s]*([^\n]+)/i,
      // Look for brand names (like SALONPAS, MAMEE, NESTLE, etc.)
      /([A-Z]{2,}[A-Z\s\d\.\-&]+)/,
      // Look for any line that starts with capital letters
      /^([A-Z][A-Z\s\d\.\-&]+)/m,
      // Look for lines that contain product-like text
      /([A-Z][A-Z\s\d\.\-&]+(?:KG|G|ML|L|PACK|UNIT|PIECE|BOTTLE|CAN|BOX|PATCH|CREAM|GEL|SPRAY))/i,
      // Look for any word that's all caps and longer than 3 characters
      /\b([A-Z]{3,}[A-Z\s\d\.\-&]*)\b/,
      // Look for structured data or JSON-like content
      /"name":\s*"([^"]+)"/i,
      /"title":\s*"([^"]+)"/i,
      /"productName":\s*"([^"]+)"/i,
      // Look for HTML content with product names
      /<h1[^>]*>([^<]+)<\/h1>/i,
      /<h2[^>]*>([^<]+)<\/h2>/i,
      /<span[^>]*class="[^"]*title[^"]*"[^>]*>([^<]+)<\/span>/i,
      /<div[^>]*class="[^"]*product[^"]*"[^>]*>([^<]+)<\/div>/i,
      // Look for specific Lotus product page elements
      /<h1[^>]*class="[^"]*product-title[^"]*"[^>]*>([^<]+)<\/h1>/i,
      /<div[^>]*class="[^"]*product-name[^"]*"[^>]*>([^<]+)<\/div>/i,
      /<span[^>]*class="[^"]*product-title[^"]*"[^>]*>([^<]+)<\/span>/i,
      // Look for any text that looks like a product name in HTML
      /<[^>]*>([A-Z][A-Z\s\d\.\-&]+(?:KG|G|ML|L|PACK|UNIT|PIECE|BOTTLE|CAN|BOX|PATCH|CREAM|GEL|SPRAY))<\/[^>]*>/i,
      // Look for any text that contains common product words
      /([A-Z][A-Z\s\d\.\-&]+(?:CHOCOLATE|BISCUIT|DRINK|FOOD|CREAM|GEL|PATCH|SPRAY|POWDER|TABLET|CAPSULE|SYRUP|OIL|SOAP|SHAMPOO|CONDITIONER|LOTION|CREAM|GEL|PATCH|SPRAY|POWDER|TABLET|CAPSULE|SYRUP|OIL|SOAP|SHAMPOO|CONDITIONER|LOTION))/i,
      // Look for any line that starts with a capital letter and is longer than 5 characters
      /^([A-Z][A-Z\s\d\.\-&]{4,})/m,
      // Look for any text that looks like a brand name
      /([A-Z]{2,}[A-Z\s\d\.\-&]*)/g
    ];
    
    for (const pattern of patterns) {
      const match = searchContent.match(pattern);
      if (match && match[1] && match[1].trim().length > 3) {
        const candidate = match[1].trim();
        // Filter out common non-product words
        if (!candidate.match(/^(THE|AND|OR|FOR|WITH|FROM|THIS|THAT|PAGE|SITE|HOME|MENU|SEARCH|LOGIN|REGISTER|CART|CHECKOUT|ABOUT|CONTACT|TERMS|PRIVACY|COPYRIGHT|ALL|RIGHTS|RESERVED)$/i)) {
          nameMatch = match;
          console.log(`‚úÖ Found product name with pattern: "${candidate}"`);
          break;
        }
      }
    }
    
    // Extract price (look for currency patterns)
    const priceMatch = searchContent.match(/RM\s*(\d+\.?\d*)/i) || 
                      searchContent.match(/\$(\d+\.?\d*)/) ||
                      searchContent.match(/(\d+\.?\d*)\s*RM/i);
    
    // Extract description (filter out markdown image syntax)
    let descriptionMatch = searchContent.match(/(?:Description|Details)[:\s]*([^\n]+)/i);
    if (!descriptionMatch) {
      // Find a line that looks like a description but not markdown images
      const lines = searchContent.split('\n');
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.length > 20 && trimmed.length < 200 && 
            !trimmed.includes('![product_image]') && 
            !trimmed.includes('![image]') &&
            !trimmed.includes('![') &&
            !trimmed.includes('/jcr:content/') &&
            !trimmed.includes('.jpg') &&
            !trimmed.includes('.png')) {
          descriptionMatch = [null, trimmed];
          break;
        }
      }
    }
    
    // If no name found, try to extract from URL or use a better fallback
    let productName = 'Unknown Product';
    if (nameMatch && nameMatch[1]) {
      productName = nameMatch[1].trim();
    } else {
      // Try to extract product name from URL path
      const urlMatch = url.match(/\/product\/(\d+)/);
      if (urlMatch) {
        // Try to get a more meaningful name from the URL
        const productId = urlMatch[1];
        
        // Try to extract from the URL path or use a generic name
        if (url.includes('salonpas')) {
          productName = 'SALONPAS';
        } else if (url.includes('mamee')) {
          productName = 'MAMEE';
        } else if (url.includes('nestle')) {
          productName = 'NESTLE';
        } else if (url.includes('coca-cola')) {
          productName = 'COCA-COLA';
        } else {
          productName = `Lotus Product ${productId}`;
        }
      }
      
      // Try to find any line that looks like a product name
      const lines = searchContent.split('\n');
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.length > 3 && trimmed.length < 100 && 
            /^[A-Z]/.test(trimmed) && 
            !trimmed.includes('http') && 
            !trimmed.includes('www') &&
            !trimmed.match(/^(The|And|Or|For|With|From|This|That|Page|Site|Home|Menu|Search|Login|Register|Cart|Checkout|About|Contact|Terms|Privacy|Copyright|All|Rights|Reserved)$/i)) {
          productName = trimmed;
          console.log(`‚úÖ Fallback found product name: "${productName}"`);
          break;
        }
      }
      
      // If still no name, try to extract from the first meaningful line
      if (productName === 'Unknown Product') {
        const meaningfulLines = lines.filter(line => {
          const trimmed = line.trim();
          return trimmed.length > 3 && 
                 trimmed.length < 100 && 
                 !trimmed.includes('http') && 
                 !trimmed.includes('www') &&
                 !trimmed.match(/^(The|And|Or|For|With|From|This|That|Page|Site|Home|Menu|Search|Login|Register|Cart|Checkout|About|Contact|Terms|Privacy|Copyright|All|Rights|Reserved)$/i);
        });
        
        if (meaningfulLines.length > 0) {
          productName = meaningfulLines[0].trim();
          console.log(`‚úÖ First meaningful line found: "${productName}"`);
        }
      }
      
      // If still no name, try to extract any text that looks like a product name
      if (productName === 'Unknown Product') {
        // Try to find any text that contains common product-related words
        const productWords = ['CHOCOLATE', 'BISCUIT', 'DRINK', 'FOOD', 'CREAM', 'GEL', 'PATCH', 'SPRAY', 'POWDER', 'TABLET', 'CAPSULE', 'SYRUP', 'OIL', 'SOAP', 'SHAMPOO', 'CONDITIONER', 'LOTION', 'MILK', 'BREAD', 'RICE', 'NOODLE', 'SAUCE', 'SPICE', 'HERB', 'VITAMIN', 'SUPPLEMENT', 'MEDICINE', 'BANDAGE', 'PLASTER'];
        
        for (const line of lines) {
          const trimmed = line.trim().toUpperCase();
          for (const word of productWords) {
            if (trimmed.includes(word) && trimmed.length > 5 && trimmed.length < 100) {
              productName = line.trim();
              console.log(`‚úÖ Found product name with keyword "${word}": "${productName}"`);
              break;
            }
          }
          if (productName !== 'Unknown Product') break;
        }
      }
    }
    
    console.log(`üîç Extracted product name: "${productName}" from URL: ${url}`);
    
    const product = {
      url: url,
      name: productName,
      price: priceMatch ? `RM ${priceMatch[1]}` : 'Price not found',
      description: descriptionMatch ? descriptionMatch.trim() : content.substring(0, 200) + '...',
      scrapedAt: new Date().toISOString(),
      source: 'Lotus Firecrawl'
    };
    
    console.log(`üì¶ Created product object:`, product);
    
    // Immediately store the product in the database (only if price > 0)
    console.log(`üîç Checking if product should be stored: "${productName}" (Price: ${product.price})`);
    if (productName && productName !== 'Unknown Product') {
      const priceMatch = product.price ? product.price.match(/RM\s*(\d+\.?\d*)/i) : null;
      const priceValue = priceMatch ? parseFloat(priceMatch[1]) : 0;
      
      console.log(`üí∞ Price analysis for "${productName}": priceMatch=${priceMatch}, priceValue=${priceValue}`);
      
      if (priceValue > 0) {
        console.log(`üíæ Storing product immediately in database: "${productName}" (Price: RM ${priceValue})`);
        storeProductInDatabaseImmediately(product);
      } else {
        console.log(`‚è≠Ô∏è Skipping product with price 0: "${productName}" (Price: ${product.price})`);
      }
    } else {
      console.log(`‚è≠Ô∏è Skipping invalid product: "${productName}"`);
    }
    
    console.log(`‚úÖ Returning product from extractProductFromContent:`, product);
    return product;
    
  } catch (error) {
    console.error('‚ùå Error extracting product from content:', error);
    console.error('‚ùå Error details:', error.message, error.stack);
    return null;
  }
}

// Debug popup function for HORECA data
function showHorecaDebugPopup(data) {
  const popup = document.createElement('div');
  popup.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80%;
    height: 80%;
    background: white;
    border: 2px solid #007bff;
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    z-index: 10000;
    overflow: hidden;
    font-family: Arial, sans-serif;
  `;
  
  const header = document.createElement('div');
  header.style.cssText = `
    background: #007bff;
    color: white;
    padding: 15px;
    font-size: 18px;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
  `;
  header.innerHTML = `
    <span>üîç HORECA_WK34 Debug Data</span>
    <button onclick="this.parentElement.parentElement.remove()" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">‚úï Close</button>
  `;
  
  const content = document.createElement('div');
  content.style.cssText = `
    padding: 20px;
    height: calc(100% - 60px);
    overflow-y: auto;
    font-size: 14px;
  `;
  
  // Format the data for display
  const formattedData = JSON.stringify(data, null, 2);
  content.innerHTML = `
    <h3>üìä Raw API Response:</h3>
    <pre style="background: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap;">${formattedData}</pre>
    
    <h3>üìà Summary:</h3>
    <ul>
      <li><strong>Total Products:</strong> ${data.products ? data.products.length : 'N/A'}</li>
      <li><strong>Success:</strong> ${data.success ? '‚úÖ Yes' : '‚ùå No'}</li>
      <li><strong>Source:</strong> ${data.source || 'N/A'}</li>
      <li><strong>Response Type:</strong> ${typeof data}</li>
    </ul>
    
    <h3>üîç First 5 Products:</h3>
    <div style="background: #e9ecef; padding: 15px; border-radius: 5px;">
      ${data.products && data.products.length > 0 ? 
        data.products.slice(0, 5).map((product, index) => `
          <div style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 5px;">
            <strong>Product ${index + 1}:</strong><br>
            <strong>ID:</strong> ${product.id}<br>
            <strong>Name:</strong> ${product.name || 'N/A'}<br>
            <strong>Price:</strong> ${product.offers && product.offers[0] ? product.offers[0].price : 'N/A'}<br>
            <strong>Category:</strong> ${product.category || 'N/A'}<br>
            <strong>URL:</strong> ${product.horeca_data?.product_url || 'N/A'}
          </div>
        `).join('') : 
        '<p>No products found</p>'
      }
    </div>
  `;
  
  popup.appendChild(header);
  popup.appendChild(content);
  document.body.appendChild(popup);
}

// Load HORECA_WK34_OpenAI_Processing products directly from database
async function loadHorecaWk34ProductsFromDatabase() {
  try {
    console.log('üõí Loading HORECA_WK34_OpenAI_Processing products from PostgreSQL database...');
    
    const response = await fetch('http://localhost:5000/api/products?flyer_path=HORECA_WK34_OpenAI_Processing&limit=1000');
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.success && data.products && data.products.length > 0) {
      console.log(`‚úÖ Loaded ${data.products.length} HORECA_WK34_OpenAI_Processing products from database`);
      
      // Convert database products to our format
      const convertedProducts = data.products.map((product, index) => {
        return {
          id: `db-horeca-wk34-${product.id}`,
          title: product.name || 'Unknown Product',
          original_title: product.name || 'Unknown Product',
          brand: product.brand || 'Lotus\'s',
          category_path: product.category || 'HORECA',
          price: parseFloat(product.sale_price) || parseFloat(product.original_price) || 0,
          original_price: parseFloat(product.original_price) || parseFloat(product.sale_price) || 0,
          image_link: product.image_url || 'https://via.placeholder.com/240x240.png?text=No+Image',
          image_url: product.image_url || 'https://via.placeholder.com/240x240.png?text=No+Image',
          url: product.product_url || '#',
          product_url: product.product_url || '#',
          see_more_link: product.product_url || '#',
          flyer_path: product.flyer_path || 'HORECA_WK34_OpenAI_Processing',
          source: 'HORECA_WK34_OpenAI_Processing',
          aggregate: {
            lowPrice: parseFloat(product.sale_price) || parseFloat(product.original_price) || 0,
            highPrice: parseFloat(product.original_price) || parseFloat(product.sale_price) || 0,
            currency: product.currency || 'MYR'
          },
          offers: [{
            source: 'horeca-wk34',
            marketplace: 'horeca-wk34',
            merchant: 'Lotus\'s Malaysia',
            price: parseFloat(product.sale_price) || parseFloat(product.original_price) || 0,
            currency: product.currency || 'MYR',
            url: product.product_url || '#',
            availability: product.availability || 'in-stock'
          }]
        };
      });
      
      return convertedProducts;
    } else {
      console.log('‚ö†Ô∏è No HORECA_WK34_OpenAI_Processing products found in database');
      return [];
    }
    
  } catch (error) {
    console.log('‚ÑπÔ∏è HORECA_WK34 database query not available:', error.message);
    return [];
  }
}

// Load HORECA products from PostgreSQL database
async function loadHorecaProductsFromPostgreSQL() {
  try {
    console.log('üõí Loading HORECA products from PostgreSQL database...');
    
    console.log('üîó Making request to: http://localhost:5003/products');
    const timestamp = Date.now();
    const randomId = Math.random().toString(36).substring(7);
    const uniqueId = Math.random().toString(36).substring(2, 15);
    const fetchUrl = `http://localhost:5003/products?v=${timestamp}&r=${randomId}&t=${performance.now()}&u=${uniqueId}&cb=2025-09-19-18:35:00`;
    console.log('üîó Full fetch URL:', fetchUrl);
    console.log('üîó About to call fetch...');
    
    // Try fetch with explicit CORS settings
    let response;
    try {
      response = await fetch(fetchUrl, {
        method: 'GET',
        mode: 'cors',
        credentials: 'omit',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      });
      console.log('‚úÖ Fetch successful with CORS mode');
    } catch (fetchError) {
      console.error('‚ùå Fetch failed, trying XMLHttpRequest:', fetchError);
      
      // Fallback to XMLHttpRequest
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', fetchUrl, true);
        xhr.setRequestHeader('Accept', 'application/json');
        xhr.setRequestHeader('Content-Type', 'application/json');
        
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              try {
                const data = JSON.parse(xhr.responseText);
                console.log('‚úÖ XMLHttpRequest successful');
                showHorecaDebugPopup(data);
                
                // Process the data the same way as fetch
                if (!data.success || !data.products) {
                  console.error('‚ùå Invalid response format:', {
                    success: data.success,
                    hasProducts: !!data.products,
                    productsType: typeof data.products,
                    productsLength: data.products ? data.products.length : 'N/A'
                  });
                  reject(new Error('Invalid response format from HORECA API'));
                  return;
                }
                
                const products = data.products;
                
                // Sort HORECA products by grocery ID (ascending order)
                products.sort((a, b) => {
                  const idA = parseInt(a.id) || 0;
                  const idB = parseInt(b.id) || 0;
                  return idA - idB;
                });
                
                console.log(`üõí HORECA products loaded from API: ${products.length} products`);
                
                // Convert directly using the same approach as data viewer
                const convertedProducts = products.map((product, index) => {
                  // Get product name directly from PostgreSQL fields - try multiple fields
                  let productName = product.label || product.product_name || product.title || product.name || product.product_title || product.display_name;
                  
                  // If still no name found, try to construct from other fields
                  if (!productName || productName.trim() === '') {
                    // Try to use brand + category as fallback
                    const brand = product.brand || 'Product';
                    const category = product.product_type || 'Item';
                    productName = `${brand} ${category}`;
                  }
                  
                  // Clean the product name by removing number prefixes (1., 2., etc.) and "| Lotus's Shop Online" suffix
                  productName = productName
                    .replace(/^\d+\.\s*/, '') // Remove number prefixes like "2. ", "1. ", etc.
                    .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
                    .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
                    .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
                    .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
                    .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
                    .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '')
                    .trim();
                  
                  // Extract brand from first word
                  let brand = 'HORECA';
                  if (productName && productName.trim() !== '') {
                    const firstWord = productName.split(' ')[0];
                    if (firstWord && firstWord.length > 1) {
                      brand = firstWord;
                    }
                  }
                  
                  // Get price from offers array or direct price field
                  const productPrice = product.offers && product.offers[0] ? product.offers[0].price : (product.price || 0);
                  console.log(`üîç HORECA Product ${index}: "${productName}" (${productPrice})`);
                  
                  // Format to match Flask App structure exactly
                  const salePrice = parseFloat(productPrice) || 0;
                  const originalPrice = parseFloat(product.horeca_data?.original_price) || salePrice;
                  
                  return {
                    id: product.id || `horeca-${index}`,
                    name: productName,
                    title: productName,
                    original_title: productName,
                    brand: brand,
                    category: 'HORECA Products',
                    category_path: 'HORECA Products',
                    price: salePrice,
                    original_price: originalPrice,
                    sale_price: salePrice.toString(),
                    image_link: product.image || "https://via.placeholder.com/240x240.png?text=No+Image",
                    image_url: product.image || "https://via.placeholder.com/240x240.png?text=No+Image",
                    url: product.horeca_data?.product_url || '#',
                    product_url: product.horeca_data?.product_url || '#',
                    see_more_link: product.horeca_data?.product_url || '#',
                    discount_percentage: product.horeca_data?.discount_percentage || "0.00",
                    is_discounted: originalPrice > salePrice,
                    currency: 'MYR',
                    availability: 'in-stock',
                    aggregate: {
                      lowPrice: salePrice,
                      highPrice: originalPrice,
                      currency: 'MYR'
                    },
                    offers: [{
                      source: 'horeca',
                      marketplace: 'horeca',
                      merchant: "HORECA WK34",
                      price: salePrice,
                      currency: 'MYR',
                      url: product.horeca_data?.product_url || '#',
                      availability: 'in-stock'
                    }]
                  };
                });
                
                console.log(`‚úÖ Converted ${convertedProducts.length} HORECA products successfully`);
                resolve(convertedProducts);
                
              } catch (parseError) {
                console.error('‚ùå JSON parse error:', parseError);
                reject(parseError);
              }
            } else {
              console.error('‚ùå XMLHttpRequest failed:', xhr.status, xhr.statusText);
              reject(new Error(`XMLHttpRequest failed: ${xhr.status} ${xhr.statusText}`));
            }
          }
        };
        
        xhr.onerror = function() {
          console.error('‚ùå XMLHttpRequest network error');
          reject(new Error('XMLHttpRequest network error'));
        };
        
        xhr.send();
      });
    }
    console.log('üì° Response status:', response.status, response.statusText);
    console.log('üì° Response headers:', [...response.headers.entries()]);
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    console.log('üìä HORECA API response:', data);
    console.log('üìä Response type:', typeof data);
    console.log('üìä Has success field:', 'success' in data);
    console.log('üìä Has products field:', 'products' in data);
    
    // Show debug popup
    showHorecaDebugPopup(data);
    
    if (!data.success || !data.products) {
      console.error('‚ùå Invalid response format:', {
        success: data.success,
        hasProducts: !!data.products,
        productsType: typeof data.products,
        productsLength: data.products ? data.products.length : 'N/A'
      });
      throw new Error('Invalid response format from HORECA API');
    }
    
    const products = data.products;
    
    // Sort HORECA products by grocery ID (ascending order)
    products.sort((a, b) => {
      const idA = parseInt(a.id) || 0;
      const idB = parseInt(b.id) || 0;
      return idA - idB;
    });
    
    console.log(`üõí HORECA products loaded from API: ${products.length} products`);
    
    // Convert directly using the same approach as data viewer
    const convertedProducts = products.map((product, index) => {
      // Get product name directly from PostgreSQL fields - try multiple fields
      let productName = product.label || product.product_name || product.title || product.name || product.product_title || product.display_name;
      
      // If still no name found, try to construct from other fields
      if (!productName || productName.trim() === '') {
        // Try to use brand + category as fallback
        const brand = product.brand || 'Product';
        const category = product.product_type || 'Item';
        productName = `${brand} ${category}`;
      }
      
      // Clean the product name by removing number prefixes (1., 2., etc.) and "| Lotus's Shop Online" suffix
      productName = productName
        .replace(/^\d+\.\s*/, '') // Remove number prefixes like "2. ", "1. ", etc.
        .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
        .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '')
        .trim();
      
      // Extract brand from first word
      let brand = 'HORECA';
      if (productName && productName.trim() !== '') {
        const firstWord = productName.split(' ')[0];
        if (firstWord && firstWord.length > 1) {
          brand = firstWord;
        }
      }
      
      // Get price from offers array or direct price field
      const productPrice = product.offers && product.offers[0] ? product.offers[0].price : (product.price || 0);
      console.log(`üîç HORECA Product ${index}: "${productName}" (${productPrice})`);
      
      return {
        id: `postgres-horeca-${product.id}`,
        title: productName,
        original_title: product.name || productName,
        brand: brand,
        category_path: 'HORECA Products',
        price: parseFloat(productPrice) || 0,
        original_price: parseFloat(productPrice) || 0,
        image_link: "https://via.placeholder.com/240x240.png?text=No+Image",
        url: product.horeca_data?.product_url || '#',
        see_more_link: product.horeca_data?.product_url || '#',
        offers: [{
          source: 'horeca',
          marketplace: 'horeca',
          merchant: "HORECA",
          price: parseFloat(productPrice) || 0,
          currency: 'MYR',
          availability: 'in_stock',
          condition: 'new',
          shipping: 'free'
        }],
        aggregate: {
          currency: 'MYR',
          lowPrice: parseFloat(productPrice) || 0,
          highPrice: parseFloat(productPrice) || 0,
          offerCount: 1
        }
      };
    });
    
    console.log(`‚úÖ Converted ${convertedProducts.length} HORECA products successfully`);
    
    return convertedProducts;
    
  } catch (error) {
    console.error('‚ùå Error loading HORECA PostgreSQL data:', error);
    console.error('‚ùå Error details:', {
      name: error.name,
      message: error.message,
      stack: error.stack,
      type: typeof error
    });
    showNotification(`‚ùå Error loading HORECA PostgreSQL data: ${error.message}`, 'error');
    return [];
  }
}

// Load WK34 HORECA JSON data and display in browser
async function loadWK34HorecaJSON() {
  try {
    console.log('üìÑ Loading WK34 HORECA JSON data...');
    
    const timestamp = Date.now();
    const randomId = Math.random().toString(36).substring(7);
    const uniqueId = Math.random().toString(36).substring(2, 15);
    const fetchUrl = `http://localhost:5003/products?v=${timestamp}&r=${randomId}&t=${performance.now()}&u=${uniqueId}&cb=2025-09-19-18:45:00`;
    
    console.log('üîó Making request to:', fetchUrl);
    
    // Use XMLHttpRequest directly to avoid CORS issues
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open('GET', fetchUrl, true);
      xhr.setRequestHeader('Accept', 'application/json');
      
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            try {
              const data = JSON.parse(xhr.responseText);
              console.log('‚úÖ XMLHttpRequest successful');
              console.log('üìä WK34 HORECA JSON response:', data);
              
              // Convert JSON products to proper product tiles for grid display
              if (data.products && Array.isArray(data.products)) {
                const convertedProducts = data.products.map((product, index) => {
                  // Get product name directly from PostgreSQL fields - try multiple fields
                  let productName = product.label || product.product_name || product.title || product.name || product.product_title || product.display_name;
                  
                  // If still no name found, try to construct from other fields
                  if (!productName || productName.trim() === '') {
                    // Try to use brand + category as fallback
                    const brand = product.brand || 'Product';
                    const category = product.product_type || 'Item';
                    productName = `${brand} ${category}`;
                  }
                  
                  // Clean the product name by removing number prefixes (1., 2., etc.) and "| Lotus's Shop Online" suffix
                  productName = productName
                    .replace(/^\d+\.\s*/, '') // Remove number prefixes like "2. ", "1. ", etc.
                    .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
                    .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
                    .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
                    .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
                    .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
                    .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '')
                    .trim();
                  
                  // Extract brand from first word
                  let brand = 'HORECA WK34';
                  if (productName && productName.trim() !== '') {
                    const firstWord = productName.split(' ')[0];
                    if (firstWord && firstWord.length > 1) {
                      brand = firstWord;
                    }
                  }
                  
                  // Get price from offers array or direct price field
                  const productPrice = product.offers && product.offers[0] ? product.offers[0].price : (product.price || 0);
                  
                  // Format to match Flask App structure exactly
                  const salePrice = parseFloat(productPrice) || 0;
                  const originalPrice = parseFloat(product.horeca_data?.original_price) || salePrice;
                  
                  return {
                    id: product.id || `wk34-horeca-${index}`,
                    name: productName,
                    title: productName,
                    original_title: productName,
                    brand: brand,
                    category: 'HORECA WK34 Products',
                    category_path: 'HORECA WK34 Products',
                    price: salePrice,
                    original_price: originalPrice,
                    sale_price: salePrice.toString(),
                    image_link: product.image || "https://via.placeholder.com/240x240.png?text=No+Image",
                    image_url: product.image || "https://via.placeholder.com/240x240.png?text=No+Image",
                    url: product.horeca_data?.product_url || '#',
                    product_url: product.horeca_data?.product_url || '#',
                    see_more_link: product.horeca_data?.product_url || '#',
                    discount_percentage: product.horeca_data?.discount_percentage || "0.00",
                    is_discounted: originalPrice > salePrice,
                    currency: 'MYR',
                    availability: 'in-stock',
                    // Additional fields for tile compatibility
                    label: productName,
                    product_name: productName,
                    product_title: productName,
                    display_name: productName,
                    product_type: 'HORECA WK34 Products',
                    weight: '',
                    description: '',
                    rating: 0,
                    review_count: 0,
                    promotion_badge: '',
                    is_bundle_deal: false,
                    nutritional_info: '',
                    ingredients: '',
                    allergens: '',
                    storage_instructions: '',
                    expiry_date: '',
                    barcode: '',
                    country_of_origin: '',
                    manufacturer: '',
                    scraped_at: new Date().toISOString(),
                    run_number: index,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                    aggregate: {
                      lowPrice: salePrice,
                      highPrice: originalPrice,
                      currency: 'MYR',
                      offerCount: 1
                    },
                    offers: [{
                      source: 'wk34-horeca',
                      marketplace: 'wk34-horeca',
                      merchant: "HORECA WK34",
                      price: salePrice,
                      currency: 'MYR',
                      url: product.horeca_data?.product_url || '#',
                      availability: 'in-stock',
                      condition: 'new',
                      shipping: 'standard'
                    }]
                  };
                });
                
                console.log(`‚úÖ Converted ${convertedProducts.length} WK34 HORECA products for grid display`);
                
                // Reset pagination to first page for WK34 HORECA JSON
                currentPage = 0;
                console.log('üìÑ Reset pagination to first page for WK34 HORECA JSON');
                
                resolve(convertedProducts);
              } else {
                console.log('‚ö†Ô∏è No products found in WK34 HORECA JSON data');
                resolve([]);
              }
              
            } catch (parseError) {
              console.error('‚ùå JSON parse error:', parseError);
              reject(parseError);
            }
          } else {
            console.error('‚ùå XMLHttpRequest failed:', xhr.status, xhr.statusText);
            reject(new Error(`XMLHttpRequest failed: ${xhr.status} ${xhr.statusText}`));
          }
        }
      };
      
      xhr.onerror = function() {
        console.error('‚ùå XMLHttpRequest network error');
        reject(new Error('XMLHttpRequest network error'));
      };
      
      xhr.send();
    });
    
  } catch (error) {
    console.error('‚ùå Error loading WK34 HORECA JSON:', error);
    showNotification(`‚ùå Error loading WK34 HORECA JSON: ${error.message}`, 'error');
    return [];
  }
}

// Display JSON data directly in the grid section
function displayJSONInGrid(data) {
  const grid = document.getElementById('grid');
  if (!grid) {
    console.error('‚ùå Grid element not found');
    return;
  }
  
  // Clear existing content
  grid.innerHTML = '';
  
  // Create header
  const header = document.createElement('div');
  header.style.cssText = `
    width: 100%;
    background: #007bff;
    color: white;
    padding: 20px;
    border-radius: 8px 8px 0 0;
    margin-bottom: 0;
    text-align: center;
  `;
  header.innerHTML = `
    <h2 style="margin: 0 0 10px 0; font-size: 24px;">üõí WK34 HORECA JSON Data</h2>
    <p style="margin: 0; font-size: 16px; opacity: 0.9;">${data.products ? data.products.length : 0} products loaded from HORECA WK34 API</p>
  `;
  
  // Create content container
  const content = document.createElement('div');
  content.style.cssText = `
    background: white;
    border: 2px solid #007bff;
    border-top: none;
    border-radius: 0 0 8px 8px;
    padding: 20px;
    max-height: 70vh;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    line-height: 1.4;
  `;
  
  // Format the JSON data for display
  const formattedJSON = JSON.stringify(data, null, 2);
  content.innerHTML = `
    <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; border: 1px solid #dee2e6;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h3 style="margin: 0; color: #333; font-family: Arial, sans-serif;">üìÑ Raw JSON Response</h3>
        <button onclick="this.parentElement.parentElement.style.display='none'" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">‚úï Hide</button>
      </div>
      <pre style="background: #ffffff; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; margin: 0; border: 1px solid #e9ecef; max-height: 400px; overflow-y: auto;">${formattedJSON}</pre>
    </div>
  `;
  
  // Add to grid
  grid.appendChild(header);
  grid.appendChild(content);
  
  console.log('üìÑ JSON data displayed directly in grid section');
}

// Display JSON data in a browser popup with product detail format
function displayJSONInBrowser(data) {
  const popup = document.createElement('div');
  popup.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 95%;
    height: 95%;
    background: white;
    border: 2px solid #007bff;
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    z-index: 10000;
    overflow: hidden;
    font-family: Arial, sans-serif;
  `;
  
  const header = document.createElement('div');
  header.style.cssText = `
    background: #007bff;
    color: white;
    padding: 15px;
    font-size: 18px;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
  `;
  header.innerHTML = `
    <span>üõí WK34 HORECA Products ({data.products ? data.products.length : 0} items)</span>
    <button onclick="this.parentElement.parentElement.remove()" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">‚úï Close</button>
  `;
  
  const content = document.createElement('div');
  content.style.cssText = `
    padding: 20px;
    height: calc(100% - 60px);
    overflow-y: auto;
    font-size: 14px;
    line-height: 1.6;
  `;
  
  // Format the data as product details
  let productDetailsHTML = '';
  
  if (data.products && Array.isArray(data.products)) {
    productDetailsHTML = data.products.map((product, index) => {
      const price = product.offers && product.offers[0] ? product.offers[0].price : (product.price || 0);
      const originalPrice = product.horeca_data?.original_price || price;
      const discountPercentage = product.horeca_data?.discount_percentage || '';
      const isDiscounted = originalPrice > price;
      
      return `
        <div style="border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: #f9f9f9;">
          <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <div style="width: 60px; height: 60px; background: #e9ecef; border-radius: 5px; display: flex; align-items: center; justify-content: center; margin-right: 15px; font-size: 12px; color: #666;">
              ${product.image ? `<img src="${product.image}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 5px;" />` : 'No Image'}
            </div>
            <div style="flex: 1;">
              <h3 style="margin: 0 0 5px 0; color: #333; font-size: 16px;">${product.name || 'Unknown Product'}</h3>
              <p style="margin: 0; color: #666; font-size: 12px;">ID: ${product.id} | Category: ${product.category}</p>
            </div>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 10px;">
            <div>
              <strong>üí∞ Pricing:</strong><br>
              <span style="color: ${isDiscounted ? '#dc3545' : '#28a745'}; font-weight: bold; font-size: 16px;">
                RM ${price.toFixed(2)}
              </span>
              ${isDiscounted ? `<br><span style="text-decoration: line-through; color: #666;">RM ${originalPrice.toFixed(2)}</span>` : ''}
              ${discountPercentage ? `<br><span style="color: #dc3545; font-size: 12px;">${discountPercentage} off</span>` : ''}
            </div>
            <div>
              <strong>üè™ Marketplace:</strong><br>
              ${product.offers && product.offers[0] ? product.offers[0].merchant : 'HORECA WK34'}<br>
              <span style="color: #666; font-size: 12px;">${product.offers && product.offers[0] ? product.offers[0].promo : 'Regular Price'}</span>
            </div>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <div>
              <strong>üì¶ Availability:</strong><br>
              <span style="color: #28a745;">‚úÖ In Stock</span><br>
              <span style="color: #666; font-size: 12px;">Currency: MYR</span>
            </div>
            <div>
              <strong>üîó Links:</strong><br>
              ${product.horeca_data?.product_url ? `<a href="${product.horeca_data.product_url}" target="_blank" style="color: #007bff; text-decoration: none;">View Product ‚Üí</a>` : 'No URL available'}
            </div>
          </div>
          
          <details style="margin-top: 10px;">
            <summary style="cursor: pointer; color: #007bff; font-size: 12px;">üîç View Raw Data</summary>
            <pre style="background: #f8f9fa; padding: 10px; border-radius: 5px; font-size: 11px; margin: 10px 0 0 0; overflow-x: auto;">${JSON.stringify(product, null, 2)}</pre>
          </details>
        </div>
      `;
    }).join('');
  } else {
    productDetailsHTML = '<p style="text-align: center; color: #666; font-style: italic;">No products found in the data.</p>';
  }
  
  content.innerHTML = productDetailsHTML;
  
  popup.appendChild(header);
  popup.appendChild(content);
  document.body.appendChild(popup);
  
  console.log('üõí Product details displayed in browser popup');
}

// Load Reusable Lotus URLs from database
async function loadReusableLotusUrls() {
  try {
    console.log('üîÑ Loading Reusable Lotus URLs from database...');
    showNotification('üîÑ Loading Reusable Lotus URLs from database...', 'info');
    
    const response = await fetch('http://localhost:5005/get-reusable-lotus-urls');
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    
    console.log('üîç API Response:', data);
    
    if (!data.success || !data.urls) {
      throw new Error('Invalid response format from reusable URLs API');
    }
    
    console.log(`üì¶ Raw reusable URLs data loaded: ${data.urls.length} URLs`);
    console.log(`üîÑ Reusable URLs data:`, data);
    
    // Convert reusable URLs to product format
    const convertedProducts = data.urls.map((urlData, index) => {
      const productName = urlData.name || 'Unknown Product';
      const brand = productName.split(' ')[0] || 'Unknown Brand';
      
      console.log(`üîÑ Converting URL ${index + 1}:`, urlData);
      console.log(`üîó Product URL for ${productName}:`, urlData.url);
      
      return {
        id: `reusable-lotus-${urlData.id}`,
        title: productName,
        original_title: productName,
        brand: brand,
        category_path: urlData.type || 'General',
        price: parseFloat(urlData.price) || 0,
        original_price: parseFloat(urlData.price) || 0,
        image_link: urlData.image_url || "https://via.placeholder.com/240x240.png?text=No+Image",
        url: urlData.url || '#',
        see_more_link: urlData.url || '#',
        product_url: urlData.url,
        image_url: urlData.image_url,
        product_type: urlData.type,
        offers: [{
          source: 'lotus_reusable',
          marketplace: 'lotus',
          merchant: "Lotus Malaysia",
          price: parseFloat(urlData.price) || 0,
          currency: 'MYR',
          availability: 'in_stock',
          condition: 'new',
          shipping: 'free',
          url: urlData.url || '#'
        }],
        aggregate: {
          currency: 'MYR',
          lowPrice: parseFloat(urlData.price) || 0,
          highPrice: parseFloat(urlData.price) || 0,
          offerCount: 1
        }
      };
    });
    
    console.log(`‚úÖ Converted ${convertedProducts.length} reusable Lotus URLs successfully`);
    console.log('üîç First converted product:', convertedProducts[0]);
    showNotification(`‚úÖ Loaded ${convertedProducts.length} reusable Lotus URLs from database!`, 'success');
    
    return convertedProducts;
    
  } catch (error) {
    console.error('‚ùå Error loading reusable Lotus URLs:', error);
    showNotification(`‚ùå Error loading reusable Lotus URLs: ${error.message}`, 'error');
    return [];
  }
}

// Direct PostgreSQL Data Loader (using data viewer approach)
async function loadPostgreSQLDataDirect() {
  try {
    console.log('üóÑÔ∏è Loading PostgreSQL data directly...');
    
    const response = await fetch('http://localhost:5000/api/products?limit=10000');
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    const products = data.products || data;
    
    // Sort products by grocery ID (ascending order)
    products.sort((a, b) => {
      const idA = parseInt(a.id) || 0;
      const idB = parseInt(b.id) || 0;
      return idA - idB;
    });
    
    console.log(`üì¶ Raw PostgreSQL data loaded and sorted by ID: ${products.length} products`);
    
    // Convert directly using the same approach as data viewer
    const convertedProducts = products.map((product, index) => {
      // Get product name directly from Flask API fields - try multiple fields
      let productName = product.name || product.title || product.label || product.product_name || product.product_title || product.display_name;
      
      // If still no name found, try to construct from other fields
      if (!productName || productName.trim() === '') {
        // Try to use brand + category as fallback
        const brand = product.brand || 'Product';
        const category = product.product_type || 'Item';
        productName = `${brand} ${category}`;
      }
      
      // Clean the product name by removing number prefixes (1., 2., etc.) and "| Lotus's Shop Online" suffix
      productName = productName
        .replace(/^\d+\.\s*/, '') // Remove number prefixes like "2. ", "1. ", etc.
        .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
        .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '')
        .trim();
      
      // Extract brand from first word
      let brand = 'Lotus\'s';
      if (productName && productName.trim() !== '') {
        const firstWord = productName.split(' ')[0];
        if (firstWord && firstWord.length > 1) {
          brand = firstWord;
        }
      }
      
      console.log(`üîç Product ${index}: "${productName}" (${product.current_price})`);
      
      return {
        id: `postgres-${product.id}`,
        title: productName,
        original_title: product.product_name || product.label || productName,
        brand: brand,
        category_path: product.category_path || product.product_type || 'General',
        price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
        original_price: parseFloat(product.original_price) || parseFloat(product.sale_price) || 0,
        image_link: product.image_url || product.image_link || "https://via.placeholder.com/240x240.png?text=No+Image",
        url: product.product_url || product.see_more_link || '#',
        see_more_link: product.see_more_link || '#',
        product_url: product.product_url,
        image_url: product.image_url,
        offers: [{
          source: 'lotuss',
          marketplace: 'lotuss',
          merchant: "Lotus's",
          price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
          currency: 'MYR',
          availability: 'in_stock',
          condition: 'new',
          shipping: 'free',
          url: product.product_url || product.see_more_link || '#'
        }],
        aggregate: {
          currency: 'MYR',
          lowPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
          highPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
          offerCount: 1
        }
      };
    });
    
    console.log(`‚úÖ Converted ${convertedProducts.length} products successfully`);
    
    return convertedProducts;
    
  } catch (error) {
    console.error('‚ùå Error loading PostgreSQL data:', error);
    showNotification(`‚ùå Error loading PostgreSQL data: ${error.message}`, 'error');
    return [];
  }
}

function clearAllProducts() {
  console.log('üóëÔ∏è Clearing all products...');
  allProducts = [];
  FEED = [];
  
  // Clear the grid
  const grid = document.getElementById('grid');
  grid.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--muted);">No products loaded. Select a data source from the dropdown above.</div>';
  
  // Reset the dropdown to default
  const dataSourceSelect = document.getElementById('dataSource');
  dataSourceSelect.value = 'all';
  
  showNotification('üóëÔ∏è All products cleared!', 'info');
  console.log('‚úÖ Products cleared successfully');
}

// Load All HORECA products from PostgreSQL database (combines all flyer_path types)
async function loadAllHorecaProductsFromPostgreSQL() {
  try {
    console.log('üõí Loading All HORECA products from PostgreSQL database...');
    
    let allProducts = [];
    
    // 1. Load HORECA OpenAI products (Port 5004)
    try {
      console.log('ü§ñ Loading HORECA OpenAI products...');
      const response = await fetch('http://localhost:5004/products');
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.products && data.products.length > 0) {
          const convertedProducts = data.products.map((product, index) => {
            let productName = product.label || product.product_name || product.title || product.name || product.product_title || product.display_name;
            
            if (!productName || productName.trim() === '') {
              const brand = product.brand || 'Product';
              const category = product.product_type || 'Item';
              productName = `${brand} ${category}`;
            }
            
            productName = productName
              .replace(/^\d+\.\s*/, '')
              .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
              .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '')
              .trim();
            
            let brand = 'HORECA OpenAI';
            if (productName && productName.trim() !== '') {
              const firstWord = productName.split(' ')[0];
              if (firstWord && firstWord.length > 1) {
                brand = firstWord;
              }
            }
            
            return {
              id: `postgres-all-horeca-openai-${product.id}`,
              title: productName,
              original_title: product.product_name || product.label || productName,
              brand: brand,
              category_path: 'HORECA OpenAI Products',
              price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
              original_price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
              image_link: "https://via.placeholder.com/240x240.png?text=No+Image",
              url: product.see_more_link || '#',
              see_more_link: product.see_more_link || '#',
              product_url: product.product_url,
              image_url: product.image_url,
              offers: [{
                source: 'horeca-openai',
                marketplace: 'horeca-openai',
                merchant: "HORECA OpenAI",
                price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
                currency: 'MYR',
                availability: 'in_stock',
                condition: 'new',
                shipping: 'standard'
              }],
              aggregate: {
                currency: 'MYR',
                lowPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
                highPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
                offerCount: 1
              }
            };
          });
          allProducts = allProducts.concat(convertedProducts);
          console.log(`‚úÖ Loaded ${convertedProducts.length} HORECA OpenAI products`);
        }
      }
    } catch (error) {
      console.log('‚ÑπÔ∏è HORECA OpenAI data not available:', error.message);
    }
    
    // 2. Load HORECA products (Port 5002)
    try {
      console.log('üõí Loading HORECA products...');
      const response = await fetch('http://localhost:5002/products');
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.products && data.products.length > 0) {
          const convertedProducts = data.products.map((product, index) => {
            let productName = product.label || product.product_name || product.title || product.name || product.product_title || product.display_name;
            
            if (!productName || productName.trim() === '') {
              const brand = product.brand || 'Product';
              const category = product.product_type || 'Item';
              productName = `${brand} ${category}`;
            }
            
            productName = productName
              .replace(/^\d+\.\s*/, '')
              .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
              .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '')
              .trim();
            
            let brand = 'HORECA';
            if (productName && productName.trim() !== '') {
              const firstWord = productName.split(' ')[0];
              if (firstWord && firstWord.length > 1) {
                brand = firstWord;
              }
            }
            
            return {
              id: `postgres-all-horeca-${product.id}`,
              title: productName,
              original_title: product.product_name || product.label || productName,
              brand: brand,
              category_path: 'HORECA Products',
              price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
              original_price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
              image_link: "https://via.placeholder.com/240x240.png?text=No+Image",
              url: product.see_more_link || '#',
              see_more_link: product.see_more_link || '#',
              product_url: product.product_url,
              image_url: product.image_url,
              offers: [{
                source: 'horeca',
                marketplace: 'horeca',
                merchant: "HORECA",
                price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
                currency: 'MYR',
                availability: 'in_stock',
                condition: 'new',
                shipping: 'standard'
              }],
              aggregate: {
                currency: 'MYR',
                lowPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
                highPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
                offerCount: 1
              }
            };
          });
          allProducts = allProducts.concat(convertedProducts);
          console.log(`‚úÖ Loaded ${convertedProducts.length} HORECA products`);
        }
      }
    } catch (error) {
      console.log('‚ÑπÔ∏è HORECA data not available:', error.message);
    }
    
    // 3. Load HORECA Image OCR products (Port 5003)
    try {
      console.log('üì∑ Loading HORECA Image OCR products...');
      const response = await fetch('http://localhost:5003/products');
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.products && data.products.length > 0) {
          const convertedProducts = data.products.map((product, index) => {
            let productName = product.label || product.product_name || product.title || product.name || product.product_title || product.display_name;
            
            if (!productName || productName.trim() === '') {
              const brand = product.brand || 'Product';
              const category = product.product_type || 'Item';
              productName = `${brand} ${category}`;
            }
            
            productName = productName
              .replace(/^\d+\.\s*/, '')
              .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
              .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
              .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '')
              .trim();
            
            let brand = 'HORECA Image OCR';
            if (productName && productName.trim() !== '') {
              const firstWord = productName.split(' ')[0];
              if (firstWord && firstWord.length > 1) {
                brand = firstWord;
              }
            }
            
            return {
              id: `postgres-all-horeca-image-ocr-${product.id}`,
              title: productName,
              original_title: product.product_name || product.label || productName,
              brand: brand,
              category_path: 'HORECA Image OCR Products',
              price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
              original_price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
              image_link: "https://via.placeholder.com/240x240.png?text=No+Image",
              url: product.see_more_link || '#',
              see_more_link: product.see_more_link || '#',
              product_url: product.product_url,
              image_url: product.image_url,
              offers: [{
                source: 'horeca-image-ocr',
                marketplace: 'horeca-image-ocr',
                merchant: "HORECA Image OCR",
                price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
                currency: 'MYR',
                availability: 'in_stock',
                condition: 'new',
                shipping: 'standard'
              }],
              aggregate: {
                currency: 'MYR',
                lowPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
                highPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
                offerCount: 1
              }
            };
          });
          allProducts = allProducts.concat(convertedProducts);
          console.log(`‚úÖ Loaded ${convertedProducts.length} HORECA Image OCR products`);
        }
      }
    } catch (error) {
      console.log('‚ÑπÔ∏è HORECA Image OCR data not available:', error.message);
    }
    
    // Sort all products by ID
    allProducts.sort((a, b) => {
      const idA = parseInt(a.id.split('-').pop()) || 0;
      const idB = parseInt(b.id.split('-').pop()) || 0;
      return idA - idB;
    });
    
    console.log(`‚úÖ Loaded ${allProducts.length} total HORECA products from all sources`);
    
    return allProducts;
    
  } catch (error) {
    console.error('‚ùå Error loading All HORECA products from PostgreSQL:', error);
    return [];
  }
}

// Load Lotus Online products from AWS Lambda API
async function loadLotusOnlineAWSProducts() {
  try {
    console.log('‚òÅÔ∏è Loading Lotus Online products from AWS Lambda API...');
    
    const awsLambdaUrl = 'https://tmjzouwtwcerwulahtdbpwjbcq0xefso.lambda-url.ap-southeast-1.on.aws/';
    
    const response = await fetch(awsLambdaUrl);
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    console.log('üìä AWS Lambda API response:', data);
    
    if (!data.products || !Array.isArray(data.products)) {
      throw new Error('Invalid response format from AWS Lambda API');
    }
    
    const products = data.products;
    
    // Sort products by timestamp (newest first)
    products.sort((a, b) => {
      const timestampA = new Date(a.timestamp).getTime();
      const timestampB = new Date(b.timestamp).getTime();
      return timestampB - timestampA;
    });
    
    console.log(`‚òÅÔ∏è Lotus Online products loaded from AWS Lambda: ${products.length} products`);
    
    // Convert AWS Lambda products to our format and save to PostgreSQL
    const convertedProducts = products.map((product, index) => {
      // Extract price from sale_price (remove RM prefix)
      const salePrice = parseFloat(product.sale_price.replace('RM', '').trim()) || 0;
      const originalPrice = parseFloat(product.original_price.replace('RM', '').trim()) || 0;
      
      // Calculate savings
      const savings = originalPrice > 0 && salePrice > 0 ? originalPrice - salePrice : 0;
      const savingsText = savings > 0 ? `Save RM ${savings.toFixed(2)}` : '';
      
      // Clean product name
      let productName = product.name || 'Unknown Product';
      
      // Extract brand from first word
      let brand = 'Lotus Online';
      if (productName && productName.trim() !== '') {
        const firstWord = productName.split(' ')[0];
        if (firstWord && firstWord.length > 1) {
          brand = firstWord;
        }
      }
      
      console.log(`üîç AWS Lotus Product ${index}: "${productName}" (${product.sale_price})`);
      
      return {
        id: `aws-lotus-online-${product.uid}`,
        title: productName,
        original_title: productName,
        brand: brand,
        category_path: 'Lotus Online Products',
        price: salePrice,
        original_price: originalPrice,
        image_link: product.image || "https://via.placeholder.com/240x240.png?text=No+Image",
        url: `https://www.lotuss.com.my/en/product/${product.uid}`,
        see_more_link: `https://www.lotuss.com.my/en/product/${product.uid}`,
        product_url: `https://www.lotuss.com.my/en/product/${product.uid}`,
        image_url: product.image,
        offers: [{
          source: 'lotus-online-aws',
          marketplace: 'lotus-online-aws',
          merchant: "Lotus Online",
          price: salePrice,
          currency: 'MYR',
          availability: 'in_stock',
          condition: 'new',
          shipping: 'standard'
        }],
        aggregate: {
          currency: 'MYR',
          lowPrice: salePrice,
          highPrice: originalPrice,
          offerCount: 1
        },
        // AWS Lambda specific data
        aws_lambda_data: {
          uid: product.uid,
          timestamp: product.timestamp,
          run_number: product.run_number,
          number: product.number,
          discount: product.discount,
          original_price_text: product.original_price,
          sale_price_text: product.sale_price
        }
      };
    });
    
    // Note: Database saving is now handled by the "Save Lotus's All Products" button
    console.log(`üìã ${convertedProducts.length} AWS Lotus Online products loaded and ready for display`);
    console.log(`üí° Use the "Save Lotus's All Products" button to write these products to PostgreSQL database`);
    
    console.log(`‚úÖ Converted ${convertedProducts.length} AWS Lotus Online products successfully`);
    
    return convertedProducts;
    
  } catch (error) {
    console.error('‚ùå Error loading Lotus Online products from AWS Lambda:', error);
    return [];
  }
}

// Save AWS Lotus Online products to PostgreSQL database
async function saveAWSProductsToPostgreSQL(products) {
  try {
    console.log(`üíæ saveAWSProductsToPostgreSQL called with ${products.length} products`);
    console.log(`üîç First product sample:`, products[0]);
    
    // Show initial progress notification with counter
    showRefreshNotification(`üíæ Writing 0/${products.length} AWS Lotus Online records to PostgreSQL database...`, 'loading');
    
    // Create a progress tracking system
    let progressInterval;
    let currentProgress = 0;
    
    // Start progress simulation (since we can't get real-time updates from the API)
    const startProgressSimulation = () => {
      progressInterval = setInterval(() => {
        if (currentProgress < products.length) {
          currentProgress += Math.min(2, products.length - currentProgress); // Increment by 2 or remaining count
          const percentage = Math.round((currentProgress / products.length) * 100);
          showRefreshNotification(`üíæ Writing ${currentProgress}/${products.length} (${percentage}%) AWS Lotus Online records to PostgreSQL database...`, 'loading');
        }
      }, 200); // Update every 200ms
    };
    
    // Start the progress simulation
    startProgressSimulation();
    
    // Create a simple API endpoint to save to PostgreSQL
    console.log('üì° Making request to PostgreSQL saver...');
    console.log('üîó Request URL: http://localhost:5006/save-aws-lotus-products');
    console.log('üì¶ Request payload size:', JSON.stringify(products.map(product => ({
      label: product.title,
      flyer_path: 'Lotus_Online_AWS',
      product_name: product.title,
      data_product_id: product.aws_lambda_data.uid,
      savings: product.aws_lambda_data.discount,
      current_price: product.price,
      start_date: new Date(product.aws_lambda_data.timestamp).toISOString(),
      end_date: null,
      description: `AWS Lambda product - Run ${product.aws_lambda_data.run_number}`,
      size: '1 unit',
      quantity: '1 pack',
      product_type: 'Lotus Online',
      frozen: false,
      see_more_link: product.url,
      store: 'Lotus Online',
      store_location: 'Malaysia',
      image_url: product.image_url,
      product_url: product.url
    }))).length, 'bytes');
    
    const saveResponse = await fetch('http://localhost:5006/save-aws-lotus-products', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        products: products.map(product => ({
          // Map to grocery table format
          label: product.title,
          flyer_path: 'Lotus_Online_AWS',
          product_name: product.title,
          data_product_id: product.aws_lambda_data.uid,
          savings: product.aws_lambda_data.discount,
          current_price: product.price,
          start_date: new Date(product.aws_lambda_data.timestamp).toISOString(),
          end_date: null,
          description: `AWS Lambda product - Run ${product.aws_lambda_data.run_number}`,
          size: '1 unit',
          quantity: '1 pack',
          product_type: 'Lotus Online',
          frozen: false,
          see_more_link: product.url,
          store: 'Lotus Online',
          store_location: 'Malaysia',
          image_url: product.image_url,
          product_url: product.url
        }))
      })
    });
    
    // Clear the progress interval
    if (progressInterval) {
      clearInterval(progressInterval);
    }
    
    if (saveResponse.ok) {
      const result = await saveResponse.json();
      console.log('‚úÖ PostgreSQL save result:', result);
      
      // Show final success notification with count
      showRefreshNotification(`‚úÖ Successfully wrote ${products.length}/${products.length} (100%) AWS Lotus Online records to PostgreSQL database!`, 'success');
      return true;
    } else {
      const errorText = await saveResponse.text();
      console.error('‚ùå Failed to save to PostgreSQL:', saveResponse.status, saveResponse.statusText, errorText);
      
      // Show error notification
      showRefreshNotification(`‚ùå Failed to write ${products.length} AWS Lotus Online records to PostgreSQL database`, 'error');
      return false;
    }
    
  } catch (error) {
    console.error('‚ùå Error saving to PostgreSQL:', error);
    
    // Clear progress interval on error
    if (progressInterval) {
      clearInterval(progressInterval);
    }
    
    // Show error notification
    showRefreshNotification(`‚ùå Error writing ${products.length} AWS Lotus Online records to PostgreSQL database`, 'error');
    return false;
  }
}

// Load HORECA OpenAI products from PostgreSQL database
async function loadHorecaOpenAIProductsFromPostgreSQL() {
  try {
    console.log('ü§ñ Loading HORECA OpenAI products from PostgreSQL database...');
    
    const response = await fetch('http://localhost:5004/products');
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    console.log('üìä HORECA OpenAI API response:', data);
    
    if (!data.success || !data.products) {
      throw new Error('Invalid response format from HORECA OpenAI API');
    }
    
    const products = data.products;
    
    // Sort HORECA OpenAI products by grocery ID (ascending order)
    products.sort((a, b) => {
      const idA = parseInt(a.id) || 0;
      const idB = parseInt(b.id) || 0;
      return idA - idB;
    });
    
    console.log(`ü§ñ HORECA OpenAI products loaded from API: ${products.length} products`);
    
    // Convert directly using the same approach as data viewer
    const convertedProducts = products.map((product, index) => {
      // Get product name directly from PostgreSQL fields - try multiple fields
      let productName = product.label || product.product_name || product.title || product.name || product.product_title || product.display_name;
      
      // If still no name found, try to construct from other fields
      if (!productName || productName.trim() === '') {
        // Try to use brand + category as fallback
        const brand = product.brand || 'Product';
        const category = product.product_type || 'Item';
        productName = `${brand} ${category}`;
      }
      
      // Clean the product name by removing number prefixes (1., 2., etc.) and "| Lotus's Shop Online" suffix
      productName = productName
        .replace(/^\d+\.\s*/, '') // Remove number prefixes like "2. ", "1. ", etc.
        .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
        .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '')
        .trim();
      
      // Extract brand from first word
      let brand = 'HORECA OpenAI';
      if (productName && productName.trim() !== '') {
        const firstWord = productName.split(' ')[0];
        if (firstWord && firstWord.length > 1) {
          brand = firstWord;
        }
      }
      
      console.log(`üîç HORECA OpenAI Product ${index}: "${productName}" (${product.current_price})`);
      
      return {
        id: `postgres-horeca-openai-${product.id}`,
        title: productName,
        original_title: product.product_name || product.label || productName,
        brand: brand,
        category_path: 'HORECA OpenAI Products',
        price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
        original_price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
        image_link: "https://via.placeholder.com/240x240.png?text=No+Image",
        url: product.see_more_link || '#',
        see_more_link: product.see_more_link || '#',
        product_url: product.product_url,
        image_url: product.image_url,
        offers: [{
          source: 'horeca-openai',
          marketplace: 'horeca-openai',
          merchant: "HORECA OpenAI",
          price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
          currency: 'MYR',
          availability: 'in_stock',
          condition: 'new',
          shipping: 'standard'
        }],
        aggregate: {
          currency: 'MYR',
          lowPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
          highPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
          offerCount: 1
        }
      };
    });
    
    console.log(`‚úÖ Converted ${convertedProducts.length} HORECA OpenAI products successfully`);
    
    return convertedProducts;
    
  } catch (error) {
    console.error('‚ùå Error loading HORECA OpenAI products from PostgreSQL:', error);
    return [];
  }
}

// Convert Lotus Scraper product to standard format
function convertLotusScraperProduct(product, index) {
  const productName = product.name || 'Unknown Product';
  
  // Extract brand from first word
  let brand = 'Lotus\'s';
  if (productName && productName.trim() !== '') {
    const firstWord = productName.split(' ')[0];
    if (firstWord && firstWord.length > 1) {
      brand = firstWord;
    }
  }
  
  return {
    id: `lotus-scraper-${product.id}`,
    title: productName,
    original_title: productName,
    brand: brand,
    category_path: 'Lotus Scraper Products',
    price: parseFloat(product.sale_price) || 0,
    original_price: parseFloat(product.original_price) || parseFloat(product.sale_price) || 0,
    image_link: product.image_url || "https://via.placeholder.com/240x240.png?text=No+Image",
    url: product.product_url || '#',
    see_more_link: product.product_url || '#',
    product_url: product.product_url,
    image_url: product.image_url,
    offers: [{
      source: 'lotus-scraper',
      marketplace: 'lotus-scraper',
      merchant: "Lotus's",
      price: parseFloat(product.sale_price) || 0,
      currency: 'MYR',
      availability: 'in_stock',
      condition: 'new',
      shipping: 'standard'
    }],
    aggregate: {
      currency: 'MYR',
      lowPrice: parseFloat(product.sale_price) || 0,
      highPrice: parseFloat(product.original_price) || parseFloat(product.sale_price) || 0,
      offerCount: 1
    }
  };
}

// Load Lotus WK34 HORECA products from PostgreSQL database
async function loadLotusWK34HorecaProductsFromPostgreSQL() {
  try {
    console.log('üõí Loading Lotus WK34 HORECA products from PostgreSQL database...');
    
    const response = await fetch('http://localhost:5003/products');
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    console.log('üìä Lotus WK34 HORECA API response:', data);
    
    if (!data.success || !data.products) {
      throw new Error('Invalid response format from Lotus WK34 HORECA API');
    }
    
    const products = data.products;
    
    // Sort Lotus WK34 HORECA products by grocery ID (ascending order)
    products.sort((a, b) => {
      const idA = parseInt(a.id) || 0;
      const idB = parseInt(b.id) || 0;
      return idA - idB;
    });
    
    console.log(`üõí Lotus WK34 HORECA products loaded from API: ${products.length} products`);
    
    // Convert directly using the same approach as data viewer
    const convertedProducts = products.map((product, index) => {
      // Get product name directly from PostgreSQL fields - try multiple fields
      let productName = product.label || product.product_name || product.title || product.name || product.product_title || product.display_name;
      
      // If still no name found, try to construct from other fields
      if (!productName || productName.trim() === '') {
        // Try to use brand + category as fallback
        const brand = product.brand || 'Product';
        const category = product.product_type || 'Item';
        productName = `${brand} ${category}`;
      }
      
      // Clean the product name by removing number prefixes (1., 2., etc.) and "| Lotus's Shop Online" suffix
      productName = productName
        .replace(/^\d+\.\s*/, '') // Remove number prefixes like "2. ", "1. ", etc.
        .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
        .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '')
        .trim();
      
      // Extract brand from first word
      let brand = 'Lotus WK34 HORECA';
      if (productName && productName.trim() !== '') {
        const firstWord = productName.split(' ')[0];
        if (firstWord && firstWord.length > 1) {
          brand = firstWord;
        }
      }
      
      // Get price from offers array or direct price field
      const productPrice = product.offers && product.offers[0] ? product.offers[0].price : (product.price || 0);
      console.log(`üîç Lotus WK34 HORECA Product ${index}: "${productName}" (${productPrice})`);
      
      // Format to match Flask App structure exactly
      const salePrice = parseFloat(productPrice) || 0;
      const originalPrice = parseFloat(product.horeca_data?.original_price) || salePrice;
      
      return {
        id: product.id || `lotus-wk34-horeca-${index}`,
        name: productName,
        title: productName,
        original_title: productName,
        brand: brand,
        category: 'Lotus WK34 HORECA Products',
        category_path: 'Lotus WK34 HORECA Products',
        price: salePrice,
        original_price: originalPrice,
        sale_price: salePrice.toString(),
        image_link: product.image || "https://via.placeholder.com/240x240.png?text=No+Image",
        image_url: product.image || "https://via.placeholder.com/240x240.png?text=No+Image",
        url: product.horeca_data?.product_url || '#',
        product_url: product.horeca_data?.product_url || '#',
        see_more_link: product.horeca_data?.product_url || '#',
        discount_percentage: product.horeca_data?.discount_percentage || "0.00",
        is_discounted: originalPrice > salePrice,
        currency: 'MYR',
        availability: 'in-stock',
        aggregate: {
          lowPrice: salePrice,
          highPrice: originalPrice,
          currency: 'MYR'
        },
        offers: [{
          source: 'lotus-wk34-horeca',
          marketplace: 'lotus-wk34-horeca',
          merchant: "Lotus WK34 HORECA",
          price: salePrice,
          currency: 'MYR',
          url: product.horeca_data?.product_url || '#',
          availability: 'in-stock'
        }]
      };
    });
    
    console.log(`‚úÖ Converted ${convertedProducts.length} Lotus WK34 HORECA products successfully`);
    
    return convertedProducts;
    
  } catch (error) {
    console.error('‚ùå Error loading Lotus WK34 HORECA products from PostgreSQL:', error);
    return [];
  }
}

// Load HORECA Image OCR products from PostgreSQL database
async function loadHorecaImageOCRProductsFromPostgreSQL() {
  try {
    console.log('üì∑ Loading HORECA Image OCR products from PostgreSQL database...');
    
    const response = await fetch('http://localhost:5003/products');
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    console.log('üìä HORECA Image OCR API response:', data);
    
    if (!data.success || !data.products) {
      throw new Error('Invalid response format from HORECA Image OCR API');
    }
    
    const products = data.products;
    
    // Sort HORECA Image OCR products by grocery ID (ascending order)
    products.sort((a, b) => {
      const idA = parseInt(a.id) || 0;
      const idB = parseInt(b.id) || 0;
      return idA - idB;
    });
    
    console.log(`üì∑ HORECA Image OCR products loaded from API: ${products.length} products`);
    
    // Convert directly using the same approach as data viewer
    const convertedProducts = products.map((product, index) => {
      // Get product name directly from PostgreSQL fields - try multiple fields
      let productName = product.label || product.product_name || product.title || product.name || product.product_title || product.display_name;
      
      // If still no name found, try to construct from other fields
      if (!productName || productName.trim() === '') {
        // Try to use brand + category as fallback
        const brand = product.brand || 'Product';
        const category = product.product_type || 'Item';
        productName = `${brand} ${category}`;
      }
      
      // Clean the product name by removing number prefixes (1., 2., etc.) and "| Lotus's Shop Online" suffix
      productName = productName
        .replace(/^\d+\.\s*/, '') // Remove number prefixes like "2. ", "1. ", etc.
        .replace(/\s*\|\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*\|\s*Lotus\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*Lotus'?s?\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*Lotus\s+Shop\s+Online\s*$/gi, '')
        .replace(/\s*\|\s*Lotus'?s?\s*Shop\s*Online.*$/gi, '')
        .replace(/\s*\|\s*Lotus\s*Shop\s*Online.*$/gi, '')
        .trim();
      
      // Extract brand from first word
      let brand = 'HORECA Image OCR';
      if (productName && productName.trim() !== '') {
        const firstWord = productName.split(' ')[0];
        if (firstWord && firstWord.length > 1) {
          brand = firstWord;
        }
      }
      
      console.log(`üîç HORECA Image OCR Product ${index}: "${productName}" (${product.current_price})`);
      
      return {
        id: `postgres-horeca-image-ocr-${product.id}`,
        title: productName,
        original_title: product.product_name || product.label || productName,
        brand: brand,
        category_path: 'HORECA Image OCR Products',
        price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
        original_price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
        image_link: "https://via.placeholder.com/240x240.png?text=No+Image",
        url: product.see_more_link || '#',
        see_more_link: product.see_more_link || '#',
        product_url: product.product_url,
        image_url: product.image_url,
        offers: [{
          source: 'horeca-image-ocr',
          marketplace: 'horeca-image-ocr',
          merchant: "HORECA Image OCR",
          price: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
          currency: 'MYR',
          availability: 'in_stock',
          condition: 'new',
          shipping: 'standard'
        }],
        aggregate: {
          currency: 'MYR',
          lowPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
          highPrice: parseFloat(product.sale_price) || parseFloat(product.price) || 0,
          offerCount: 1
        }
      };
    });
    
    console.log(`‚úÖ Converted ${convertedProducts.length} HORECA Image OCR products successfully`);
    
    return convertedProducts;
    
  } catch (error) {
    console.error('‚ùå Error loading HORECA Image OCR products from PostgreSQL:', error);
    return [];
  }
}

// Lotus Scraper Integration
let lotusScraperStatusInterval = null;

// Show/hide Lotus scraper controls based on data source selection
function toggleLotusScraperControls() {
  const dataSource = document.getElementById('dataSource').value;
  const controls = document.getElementById('lotusScraperControls');
  
  if (dataSource === 'lotus_scraper') {
    controls.style.display = 'block';
    loadLotusScraperProducts();
  } else {
    controls.style.display = 'none';
    stopLotusScraperStatusUpdates();
  }
}

// Load Flask App products with pagination from localhost:5000
async function loadFlaskAppProductsPaginated(page = 1, limit = 10000) {
  try {
    console.log(`üåê Loading Flask App products from localhost:5000 (page: ${page}, limit: ${limit})...`);
    
    const response = await fetch(`http://localhost:5000/api/products?page=${page}&limit=${limit}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('üìä Flask App API response:', data);
    
    if (data.products && Array.isArray(data.products)) {
      console.log(`‚úÖ Successfully loaded ${data.products.length} Flask App products (page ${data.page} of ${data.total_pages})`);
      return {
        products: data.products,
        total: data.total,
        page: data.page,
        limit: data.limit,
        total_pages: data.total_pages,
        has_more: data.has_more,
        offset: data.offset
      };
    } else {
      console.log('‚ùå No products found in Flask App response');
      return {
        products: [],
        total: 0,
        page: 1,
        limit: limit,
        total_pages: 0,
        has_more: false,
        offset: 0
      };
    }
  } catch (error) {
    console.error('‚ùå Error loading Flask App products:', error);
    throw error;
  }
}

// Legacy function for backward compatibility
async function loadFlaskAppProducts() {
  console.log('üîÑ Loading Flask App products (legacy method)...');
  const result = await loadFlaskAppProductsPaginated(1, 10000); // Load many for backward compatibility
  return result.products;
}

// Load products from Lotus scraper database
async function loadLotusScraperProducts() {
  try {
    console.log('üîÑ Loading Lotus scraper products...');
    
    const response = await fetch('http://localhost:5000/api/products?limit=10000');
    const data = await response.json();
    
    if (data.error) {
      console.error('‚ùå Error loading Lotus products:', data.error);
      return [];
    }
    
    const products = data.products || [];
    console.log(`‚úÖ Loaded ${products.length} Lotus scraper products`);
    
    // Convert to the format expected by the existing system
    const convertedProducts = products.map((product, index) => {
      const productName = product.name || 'Unknown Product';
      
      // Extract brand from first word
      let brand = 'Lotus\'s';
      if (productName && productName.trim() !== '') {
        const firstWord = productName.split(' ')[0];
        if (firstWord && firstWord.length > 1) {
          brand = firstWord;
        }
      }
      
      return {
        id: `lotus-scraper-${product.id}`,
        title: productName,
        original_title: productName,
        brand: brand,
        category_path: 'Lotus Scraper Products',
        price: parseFloat(product.sale_price) || 0,
        original_price: parseFloat(product.original_price) || parseFloat(product.sale_price) || 0,
        image_link: product.image_url || "https://via.placeholder.com/240x240.png?text=No+Image",
        url: product.product_url || '#',
        see_more_link: product.product_url || '#',
        product_url: product.product_url,
        image_url: product.image_url,
        offers: [{
          source: 'lotus-scraper',
          marketplace: 'lotus-scraper',
          merchant: "Lotus's",
          price: parseFloat(product.sale_price) || 0,
          currency: 'MYR',
          availability: 'in_stock',
          condition: 'new',
          shipping: 'standard'
        }],
        aggregate: {
          currency: 'MYR',
          lowPrice: parseFloat(product.sale_price) || 0,
          highPrice: parseFloat(product.original_price) || parseFloat(product.sale_price) || 0,
          offerCount: 1
        }
      };
    });
    
    return convertedProducts;
    
  } catch (error) {
    console.error('‚ùå Error loading Lotus scraper products:', error);
    return [];
  }
}

// Load products from Flask app (localhost:5000)
async function loadFlaskAppProducts() {
  try {
    console.log('üåê Loading Flask app products from localhost:5000...');
    
    const response = await fetch('http://localhost:5000/api/products?limit=10000');
    const data = await response.json();
    
    if (data.error) {
      console.error('‚ùå Error loading Flask app products:', data.error);
      return [];
    }
    
    const products = data.products || [];
    console.log(`‚úÖ Loaded ${products.length} Flask app products`);
    
    // Convert to the format expected by the existing system
    const convertedProducts = products.map((product, index) => {
      const productName = product.name || 'Unknown Product';
      
      // Extract brand from first word
      let brand = 'Flask App';
      if (productName && productName.trim() !== '') {
        const firstWord = productName.split(' ')[0];
        if (firstWord && firstWord.length > 1) {
          brand = firstWord;
        }
      }
      
      return {
        id: `flask-app-${product.id}`,
        title: productName,
        original_title: productName,
        brand: brand,
        category_path: 'Flask App Products',
        price: parseFloat(product.sale_price) || 0,
        original_price: parseFloat(product.original_price) || parseFloat(product.sale_price) || 0,
        image_link: product.image_url || "https://via.placeholder.com/240x240.png?text=No+Image",
        url: product.product_url || '#',
        see_more_link: product.product_url || '#',
        product_url: product.product_url,
        image_url: product.image_url,
        offers: [{
          source: 'flask-app',
          marketplace: 'flask-app',
          merchant: "Flask App",
          price: parseFloat(product.sale_price) || 0,
          currency: 'MYR',
          availability: 'in_stock',
          condition: 'new',
          shipping: 'standard'
        }],
        aggregate: {
          currency: 'MYR',
          lowPrice: parseFloat(product.sale_price) || 0,
          highPrice: parseFloat(product.original_price) || parseFloat(product.sale_price) || 0,
          offerCount: 1
        }
      };
    });
    
    return convertedProducts;
    
  } catch (error) {
    console.error('‚ùå Error loading Flask app products:', error);
    return [];
  }
}

// Start Lotus scraper
async function startLotusScraper() {
  try {
    console.log('üöÄ Starting Lotus scraper via API...');
    
    // Update UI
    document.getElementById('startLotusScraper').style.display = 'none';
    document.getElementById('stopLotusScraper').style.display = 'inline-block';
    document.getElementById('scraperStatus').textContent = 'Starting...';
    document.getElementById('scraperProducts').textContent = '0';
    document.getElementById('scraperInserted').textContent = '0';
    document.getElementById('scraperRunNumber').textContent = '-';
    
    // Start the scraper via API
    const response = await fetch('http://localhost:5000/api/start_scraper', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.success) {
      document.getElementById('scraperStatus').textContent = 'Running';
      // Start status updates
      startLotusScraperStatusUpdates();
      console.log('üöÄ Lotus scraper started successfully via API');
      showNotification('üöÄ Lotus scraper started successfully via API!', 'success');
    } else {
      showLotusScraperError(data.message || 'Failed to start scraper');
      // Reset UI on error
      document.getElementById('startLotusScraper').style.display = 'inline-block';
      document.getElementById('stopLotusScraper').style.display = 'none';
      document.getElementById('scraperStatus').textContent = 'Error';
    }
    
  } catch (error) {
    console.error('‚ùå Error starting scraper:', error);
    showLotusScraperError('Failed to start scraper: ' + error.message);
    // Reset UI on error
    document.getElementById('startLotusScraper').style.display = 'inline-block';
    document.getElementById('stopLotusScraper').style.display = 'none';
    document.getElementById('scraperStatus').textContent = 'Error';
  }
}

// Stop Lotus scraper
async function stopLotusScraper() {
  try {
    console.log('‚èπÔ∏è Stopping Lotus scraper via API...');
    
    // Call the API to stop the scraper
    const response = await fetch('http://localhost:5000/api/stop_scraper', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.success) {
      // Update UI
      document.getElementById('startLotusScraper').style.display = 'inline-block';
      document.getElementById('stopLotusScraper').style.display = 'none';
      document.getElementById('scraperStatus').textContent = 'Stopped';
      
      // Stop status updates
      stopLotusScraperStatusUpdates();
      
      console.log('‚èπÔ∏è Lotus scraper stopped via API');
      showNotification('‚èπÔ∏è Lotus scraper stopped via API', 'info');
    } else {
      showLotusScraperError(data.message || 'Failed to stop scraper');
    }
    
  } catch (error) {
    console.error('‚ùå Error stopping scraper:', error);
    showLotusScraperError('Failed to stop scraper: ' + error.message);
  }
}

// Start status updates
function startLotusScraperStatusUpdates() {
  lotusScraperStatusInterval = setInterval(updateLotusScraperStatus, 2000);
}

// Stop status updates
function stopLotusScraperStatusUpdates() {
  if (lotusScraperStatusInterval) {
    clearInterval(lotusScraperStatusInterval);
    lotusScraperStatusInterval = null;
  }
}

// Update scraper status
async function updateLotusScraperStatus() {
  try {
    const response = await fetch('http://localhost:5000/api/scraper_status');
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Update status display
    document.getElementById('scraperStatus').textContent = data.current_status || 'Unknown';
    document.getElementById('scraperProducts').textContent = data.products_found || 0;
    document.getElementById('scraperInserted').textContent = data.products_inserted || 0;
    document.getElementById('scraperRunNumber').textContent = data.run_number || '-';
    
    // Handle errors
    if (data.error) {
      showLotusScraperError(data.error);
      // Reset UI on error
      document.getElementById('startLotusScraper').style.display = 'inline-block';
      document.getElementById('stopLotusScraper').style.display = 'none';
      document.getElementById('scraperStatus').textContent = 'Error';
      stopLotusScraperStatusUpdates();
      return;
    }
    
    // Handle completion
    if (!data.is_running && data.products_found > 0) {
      document.getElementById('scraperStatus').textContent = 'Completed';
      document.getElementById('startLotusScraper').style.display = 'inline-block';
      document.getElementById('stopLotusScraper').style.display = 'none';
      stopLotusScraperStatusUpdates();
      showNotification(`‚úÖ Scraping completed! Found ${data.products_found} products, inserted ${data.products_inserted} to database.`, 'success');
      
      // Refresh products after completion
      if (document.getElementById('dataSource').value === 'lotus_scraper') {
        render();
      }
    }
    
    // Handle running state
    if (data.is_running) {
      document.getElementById('scraperStatus').textContent = data.current_status || 'Running';
    }
    
  } catch (error) {
    console.error('Error updating scraper status:', error);
    showLotusScraperError('Failed to get scraper status: ' + error.message);
  }
}

// Show scraper error
function showLotusScraperError(message) {
  const errorDiv = document.getElementById('lotusScraperError');
  errorDiv.textContent = message;
  errorDiv.style.display = 'block';
  
  setTimeout(() => {
    errorDiv.style.display = 'none';
  }, 5000);
}

// Add event listeners for Lotus scraper
document.addEventListener('DOMContentLoaded', function() {
  // Add event listener for data source change
  const dataSourceSelect = document.getElementById('dataSource');
  dataSourceSelect.addEventListener('change', toggleLotusScraperControls);
  
  // Add event listeners for scraper buttons
  document.getElementById('startLotusScraper').addEventListener('click', startLotusScraper);
  document.getElementById('stopLotusScraper').addEventListener('click', stopLotusScraper);
  
  // Add event listener for the new Lotus scraper button
  const lotusScraperBtn = document.getElementById('lotusScraperBtn');
  if (lotusScraperBtn) {
    lotusScraperBtn.addEventListener('click', function() {
      console.log('üîÑ Lotus Real-time Scraper button clicked');
      
      // Switch to Lotus scraper data source
      dataSourceSelect.value = 'lotus_scraper';
      
      // Trigger the data source change
      const event = new Event('change');
      dataSourceSelect.dispatchEvent(event);
      
      // Show the scraper controls
      toggleLotusScraperControls();
      
      // Load Lotus scraper products
      loadLotusScraperProducts().then(products => {
        if (products && products.length > 0) {
          FEED = products;
          allProducts = products;
          currentPage = 1;
          totalPages = Math.ceil(products.length / itemsPerPage);
          render();
          showNotification(`‚úÖ Loaded ${products.length} Lotus scraper products!`, 'success');
        } else {
          FEED = [];
          allProducts = [];
          render();
          showNotification('‚ÑπÔ∏è No Lotus scraper products found. Start scraping to see products.', 'info');
        }
      }).catch(error => {
        console.error('‚ùå Error loading Lotus scraper products:', error);
        showNotification('‚ùå Error loading Lotus scraper products: ' + error.message, 'error');
      });
    });
  }
});

// Flask App pagination navigation functions
function navigateFlaskAppPage(page) {
  const dataSource = document.getElementById('dataSource').value;
  if (dataSource !== 'flask_app_localhost') return;
  
  console.log(`üîÑ Navigating to Flask App page ${page}...`);
  
  const currentLimit = (window.flaskAppPagination && window.flaskAppPagination.limit) || 10000;
  
  loadFlaskAppProductsPaginated(page, currentLimit).then(result => {
    if (result && result.products) {
      FEED = result.products;
      allProducts = result.products;
      currentPage = result.page || page;
      totalPages = result.total_pages || Math.ceil(result.total / currentLimit);
      
      // Update Flask app pagination metadata
      window.flaskAppPagination = {
        total: result.total,
        page: result.page,
        limit: result.limit,
        total_pages: result.total_pages,
        has_more: result.has_more
      };
      
      render();
      showNotification(`üìÑ Page ${result.page} of ${result.total_pages} (${result.products.length} products)`, 'info');
    }
  }).catch(error => {
    console.error('‚ùå Error navigating Flask App page:', error);
    showNotification('‚ùå Error loading page: ' + error.message, 'error');
  });
}

// Override pagination navigation for Flask App
function goToPage(page) {
  const dataSource = document.getElementById('dataSource').value;
  
  if (dataSource === 'flask_app_localhost') {
    // Use Flask App pagination
    navigateFlaskAppPage(page);
  } else {
    // Use default pagination for other sources
    if (page < 1 || page > totalPages) return;
    currentPage = page;
    render();
  }
}

function nextPage() {
  const dataSource = document.getElementById('dataSource').value;
  
  if (dataSource === 'flask_app_localhost') {
    // Use Flask App pagination
    const currentPageNum = (window.flaskAppPagination && window.flaskAppPagination.page) || 1;
    const totalPagesNum = (window.flaskAppPagination && window.flaskAppPagination.total_pages) || 1;
    if (currentPageNum < totalPagesNum) {
      navigateFlaskAppPage(currentPageNum + 1);
    }
  } else {
    // Use default pagination
    if (currentPage < totalPages) {
      currentPage++;
      render();
    }
  }
}

function prevPage() {
  const dataSource = document.getElementById('dataSource').value;
  
  if (dataSource === 'flask_app_localhost') {
    // Use Flask App pagination
    const currentPageNum = (window.flaskAppPagination && window.flaskAppPagination.page) || 1;
    if (currentPageNum > 1) {
      navigateFlaskAppPage(currentPageNum - 1);
    }
  } else {
    // Use default pagination
    if (currentPage > 1) {
      currentPage--;
      render();
    }
  }
}

// Special Price Filter Functions
function toggleSpecialPriceFilter() {
  const specialPriceFilter = document.getElementById('specialPriceFilter');
  console.log('üè∑Ô∏è Special Price filter toggled:', specialPriceFilter.checked);
  render();
}

function toggleDiscountFilter() {
  const discountFilter = document.getElementById('discountFilter');
  console.log('üí∞ Discount filter toggled:', discountFilter.checked);
  render();
}

function toggleHorecaWk34Filter() {
  const horecaWk34Filter = document.getElementById('horecaWk34Filter');
  console.log('üè¢ HORECA_WK34 filter toggled:', horecaWk34Filter.checked);
  
  // Debug: Show all products and their HORECA_WK34 matching criteria
  if (horecaWk34Filter.checked) {
    console.log('üîç Debugging HORECA_WK34 filter - checking all products:');
    FEED.slice(0, 10).forEach((product, index) => {
      const hasHorecaId = product.id?.includes('horeca-wk34') || product.id?.includes('postgres-horeca') || product.id?.includes('horeca_wk34');
      const hasHorecaSource = product.source === 'HORECA_WK34_OpenAI_Processing';
      const hasHorecaFlyerPath = product.flyer_path?.includes('HORECA_WK34_OpenAI_Processing');
      const hasHorecaCategory = product.category_path?.includes('HORECA') || product.category?.includes('HORECA') || product.subcategory?.includes('HORECA');
      const hasHorecaBrand = product.brand?.includes('HORECA');
      const hasHorecaOffers = product.offers && product.offers.some(offer => 
        offer.source === 'horeca' || offer.marketplace === 'horeca' || offer.merchant === 'HORECA'
      );
      
      console.log(`Product ${index + 1}:`, {
        title: product.title,
        id: product.id,
        source: product.source,
        flyer_path: product.flyer_path,
        category_path: product.category_path,
        category: product.category,
        subcategory: product.subcategory,
        brand: product.brand,
        matches: {
          id: hasHorecaId,
          source: hasHorecaSource,
          flyer_path: hasHorecaFlyerPath,
          category: hasHorecaCategory,
          brand: hasHorecaBrand,
          offers: hasHorecaOffers
        }
      });
    });
  }
  
  render();
}

function toggleLoadHorecaWk34Filter() {
  const loadHorecaWk34Filter = document.getElementById('loadHorecaWk34Filter');
  console.log('üîÑ Load HORECA_WK34 filter toggled:', loadHorecaWk34Filter.checked);
  
  if (loadHorecaWk34Filter.checked) {
    // Load HORECA_WK34 products from database
    loadHorecaWk34Products();
  } else {
    // Uncheck the regular HORECA_WK34 filter as well
    const horecaWk34Filter = document.getElementById('horecaWk34Filter');
    horecaWk34Filter.checked = false;
    render();
  }
}

// Load HORECA_WK34 products directly from database
async function loadHorecaWk34Products() {
  try {
    console.log('üîÑ Loading HORECA_WK34_OpenAI_Processing products from database...');
    
    const loadingElement = document.getElementById('grid');
    loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">Loading HORECA_WK34 products from database...</div>';
    
    const products = await loadHorecaWk34ProductsFromDatabase();
    
    if (products && products.length > 0) {
      allProducts = products;
      FEED = allProducts;
      console.log(`‚úÖ Loaded ${products.length} HORECA_WK34 products`);
      showNotification(`‚úÖ Loaded ${products.length} HORECA_WK34 products from database!`, 'success');
      
      // Check the regular HORECA_WK34 filter as well
      const horecaWk34Filter = document.getElementById('horecaWk34Filter');
      horecaWk34Filter.checked = true;
      
      render();
    } else {
      loadingElement.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No HORECA_WK34 products found in database</div>';
      showNotification('‚ö†Ô∏è No HORECA_WK34 products found in database', 'warning');
    }
    
  } catch (error) {
    console.error('‚ùå Error loading HORECA_WK34 products:', error);
    showNotification('‚ùå Error loading HORECA_WK34 products: ' + error.message, 'error');
  }
}

// Debug database contents
async function debugDatabaseContents() {
  try {
    console.log('üîç Debugging database contents...');
    
    // Check available flyer_paths
    const flyerPathsResponse = await fetch('http://localhost:5000/api/debug/flyer_paths');
    const flyerPathsData = await flyerPathsResponse.json();
    
    console.log('üìä Available flyer_paths in database:');
    console.log('Total products:', flyerPathsData.total_products);
    console.log('Flyer paths:', flyerPathsData.flyer_paths);
    
    // Check HORECA_WK34 specifically
    const horecaResponse = await fetch('http://localhost:5000/api/debug/horeca_wk34');
    const horecaData = await horecaResponse.json();
    
    console.log('üè¢ HORECA_WK34 debug info:');
    console.log('Exact match count:', horecaData.exact_match_count);
    console.log('HORECA-like count:', horecaData.horeca_like_count);
    console.log('WK34-like count:', horecaData.wk34_like_count);
    console.log('Sample products:', horecaData.sample_products);
    
    // Show results in a popup
    const popup = document.createElement('div');
    popup.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border: 2px solid #007bff;
      border-radius: 10px;
      padding: 20px;
      max-width: 80%;
      max-height: 80%;
      overflow-y: auto;
      z-index: 10000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    `;
    
    popup.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
        <h3 style="margin: 0; color: #007bff;">üîç Database Debug Results</h3>
        <button onclick="this.parentElement.parentElement.remove()" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">‚úï Close</button>
      </div>
      
      <div style="margin-bottom: 15px;">
        <h4>üìä Total Products: ${flyerPathsData.total_products}</h4>
        <h4>üìÅ Available Flyer Paths:</h4>
        <ul style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 5px;">
          ${flyerPathsData.flyer_paths.map(fp => `<li><strong>${fp.flyer_path || 'NULL'}</strong>: ${fp.count} products</li>`).join('')}
        </ul>
      </div>
      
      <div style="margin-bottom: 15px;">
        <h4>üè¢ HORECA_WK34 Analysis:</h4>
        <ul style="background: #e9ecef; padding: 10px; border-radius: 5px;">
          <li><strong>Exact match (HORECA_WK34_OpenAI_Processing):</strong> ${horecaData.exact_match_count} products</li>
          <li><strong>HORECA-like:</strong> ${horecaData.horeca_like_count} products</li>
          <li><strong>WK34-like:</strong> ${horecaData.wk34_like_count} products</li>
        </ul>
      </div>
      
      ${horecaData.sample_products.length > 0 ? `
        <div>
          <h4>üîç Sample HORECA Products:</h4>
          <ul style="background: #d4edda; padding: 10px; border-radius: 5px; max-height: 200px; overflow-y: auto;">
            ${horecaData.sample_products.map(p => `<li><strong>${p.name}</strong> | Flyer: ${p.flyer_path} | Brand: ${p.brand} | Category: ${p.category}</li>`).join('')}
          </ul>
        </div>
      ` : ''}
    `;
    
    document.body.appendChild(popup);
    
  } catch (error) {
    console.error('‚ùå Error debugging database:', error);
    showNotification('‚ùå Error debugging database: ' + error.message, 'error');
  }
}

// Update timestamp display
function updateTimestamp() {
  const updateTimeElement = document.getElementById('updateTime');
  if (updateTimeElement) {
    const now = new Date();
    const timeString = now.toLocaleString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
    updateTimeElement.textContent = timeString;
  }
}

// Enhanced filtering function to include special price, discount, and HORECA_WK34 filters
function applySpecialFilters(products) {
  const specialPriceFilter = document.getElementById('specialPriceFilter');
  const discountFilter = document.getElementById('discountFilter');
  const horecaWk34Filter = document.getElementById('horecaWk34Filter');
  
  if (!specialPriceFilter && !discountFilter && !horecaWk34Filter) {
    return products; // No filters available, return all products
  }
  
  return products.filter(product => {
    let passesSpecialPrice = true;
    let passesDiscount = true;
    let passesHorecaWk34 = true;
    
    // Check special price filter
    if (specialPriceFilter && specialPriceFilter.checked) {
      // Look for products with promotion badges or special pricing indicators
      const hasSpecialPrice = product.promotion_badge || 
                             product.special_price || 
                             product.promo || 
                             (product.offers && product.offers.some(offer => offer.promo)) ||
                             product.title?.toLowerCase().includes('special') ||
                             product.name?.toLowerCase().includes('special');
      passesSpecialPrice = hasSpecialPrice;
    }
    
    // Check discount filter
    if (discountFilter && discountFilter.checked) {
      // Look for products with discounts
      const hasDiscount = product.is_discounted || 
                         product.discount_percentage > 0 ||
                         (product.original_price && product.price && product.original_price > product.price) ||
                         product.promotion_badge?.toLowerCase().includes('off') ||
                         product.promotion_badge?.toLowerCase().includes('discount');
      passesDiscount = hasDiscount;
    }
    
    // Check HORECA_WK34 filter
    if (horecaWk34Filter && horecaWk34Filter.checked) {
      // Look for products from HORECA_WK34_OpenAI_Processing
      const isHorecaWk34 = product.id?.includes('horeca-wk34') ||
                          product.id?.includes('postgres-horeca') ||
                          product.source === 'HORECA_WK34_OpenAI_Processing' ||
                          product.flyer_path?.includes('HORECA_WK34_OpenAI_Processing') ||
                          product.category_path?.includes('HORECA') ||
                          product.brand?.includes('HORECA') ||
                          (product.offers && product.offers.some(offer => 
                            offer.source === 'horeca' || 
                            offer.marketplace === 'horeca' ||
                            offer.merchant === 'HORECA'
                          ));
      passesHorecaWk34 = isHorecaWk34;
    }
    
    return passesSpecialPrice && passesDiscount && passesHorecaWk34;
  });
}

// Single product filter function used by the main rendering system
function passesFilters(product) {
  const specialPriceFilter = document.getElementById('specialPriceFilter');
  const discountFilter = document.getElementById('discountFilter');
  const horecaWk34Filter = document.getElementById('horecaWk34Filter');
  
  let passesSpecialPrice = true;
  let passesDiscount = true;
  let passesHorecaWk34 = true;
  
  // Check special price filter
  if (specialPriceFilter && specialPriceFilter.checked) {
    // Look for products with promotion badges or special pricing indicators
    const hasSpecialPrice = product.promotion_badge || 
                           product.special_price || 
                           product.promo || 
                           (product.offers && product.offers.some(offer => offer.promo)) ||
                           product.title?.toLowerCase().includes('special') ||
                           product.name?.toLowerCase().includes('special');
    passesSpecialPrice = hasSpecialPrice;
  }
  
  // Check discount filter
  if (discountFilter && discountFilter.checked) {
    // Look for products with discounts
    const hasDiscount = product.is_discounted || 
                       product.discount_percentage > 0 ||
                       (product.original_price && product.price && product.original_price > product.price) ||
                       product.promotion_badge?.toLowerCase().includes('off') ||
                       product.promotion_badge?.toLowerCase().includes('discount');
    passesDiscount = hasDiscount;
  }
  
  // Check HORECA_WK34 filter
  if (horecaWk34Filter && horecaWk34Filter.checked) {
    // Look for products from HORECA_WK34_OpenAI_Processing
    const isHorecaWk34 = product.id?.includes('horeca-wk34') ||
                        product.id?.includes('postgres-horeca') ||
                        product.id?.includes('horeca_wk34') ||
                        product.source === 'HORECA_WK34_OpenAI_Processing' ||
                        product.flyer_path?.includes('HORECA_WK34_OpenAI_Processing') ||
                        product.category_path?.includes('HORECA') ||
                        product.brand?.includes('HORECA') ||
                        product.category?.includes('HORECA') ||
                        product.subcategory?.includes('HORECA') ||
                        (product.offers && product.offers.some(offer => 
                          offer.source === 'horeca' || 
                          offer.marketplace === 'horeca' ||
                          offer.merchant === 'HORECA'
                        ));
    
    // Debug logging for HORECA_WK34 filter
    if (isHorecaWk34) {
      console.log('üè¢ HORECA_WK34 product found:', {
        id: product.id,
        title: product.title,
        source: product.source,
        flyer_path: product.flyer_path,
        category_path: product.category_path,
        brand: product.brand
      });
    }
    
    passesHorecaWk34 = isHorecaWk34;
  }
  
  return passesSpecialPrice && passesDiscount && passesHorecaWk34;
}

// Initial render call
render();

// Version: 2025-09-19-18:50:00 - Fixed WK34_HORECA_JSON CORS issue
console.log('üöÄ JavaScript loaded - Version: 2025-09-19-18:50:00');
console.log('üîß Added HORECA debug popup for data inspection');
console.log('üîß Enhanced cache-busting enabled for HORECA API requests');
console.log('üîß Added detailed fetch debugging');
console.log('üîß Added WK34_HORECA_JSON dropdown for raw JSON display');
console.log('üîß Fixed CORS issue by using XMLHttpRequest directly');
console.log('üîß Added Special Price and Discount filters');
console.log('üîß Current timestamp:', Date.now());
</script>


</body>
</html>
